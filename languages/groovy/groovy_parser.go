// Code generated from GroovyParser.g4 by ANTLR 4.7.2. DO NOT EDIT.

package parser // GroovyParser

import (
	"fmt"
	"reflect"
	"strconv"

	"github.com/antlr/antlr4/runtime/Go/antlr"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = reflect.Copy
var _ = strconv.Itoa

var parserATN = []uint16{
	3, 24715, 42794, 33075, 47597, 16764, 15335, 30598, 22884, 3, 131, 1693,
	4, 2, 9, 2, 4, 3, 9, 3, 4, 4, 9, 4, 4, 5, 9, 5, 4, 6, 9, 6, 4, 7, 9, 7,
	4, 8, 9, 8, 4, 9, 9, 9, 4, 10, 9, 10, 4, 11, 9, 11, 4, 12, 9, 12, 4, 13,
	9, 13, 4, 14, 9, 14, 4, 15, 9, 15, 4, 16, 9, 16, 4, 17, 9, 17, 4, 18, 9,
	18, 4, 19, 9, 19, 4, 20, 9, 20, 4, 21, 9, 21, 4, 22, 9, 22, 4, 23, 9, 23,
	4, 24, 9, 24, 4, 25, 9, 25, 4, 26, 9, 26, 4, 27, 9, 27, 4, 28, 9, 28, 4,
	29, 9, 29, 4, 30, 9, 30, 4, 31, 9, 31, 4, 32, 9, 32, 4, 33, 9, 33, 4, 34,
	9, 34, 4, 35, 9, 35, 4, 36, 9, 36, 4, 37, 9, 37, 4, 38, 9, 38, 4, 39, 9,
	39, 4, 40, 9, 40, 4, 41, 9, 41, 4, 42, 9, 42, 4, 43, 9, 43, 4, 44, 9, 44,
	4, 45, 9, 45, 4, 46, 9, 46, 4, 47, 9, 47, 4, 48, 9, 48, 4, 49, 9, 49, 4,
	50, 9, 50, 4, 51, 9, 51, 4, 52, 9, 52, 4, 53, 9, 53, 4, 54, 9, 54, 4, 55,
	9, 55, 4, 56, 9, 56, 4, 57, 9, 57, 4, 58, 9, 58, 4, 59, 9, 59, 4, 60, 9,
	60, 4, 61, 9, 61, 4, 62, 9, 62, 4, 63, 9, 63, 4, 64, 9, 64, 4, 65, 9, 65,
	4, 66, 9, 66, 4, 67, 9, 67, 4, 68, 9, 68, 4, 69, 9, 69, 4, 70, 9, 70, 4,
	71, 9, 71, 4, 72, 9, 72, 4, 73, 9, 73, 4, 74, 9, 74, 4, 75, 9, 75, 4, 76,
	9, 76, 4, 77, 9, 77, 4, 78, 9, 78, 4, 79, 9, 79, 4, 80, 9, 80, 4, 81, 9,
	81, 4, 82, 9, 82, 4, 83, 9, 83, 4, 84, 9, 84, 4, 85, 9, 85, 4, 86, 9, 86,
	4, 87, 9, 87, 4, 88, 9, 88, 4, 89, 9, 89, 4, 90, 9, 90, 4, 91, 9, 91, 4,
	92, 9, 92, 4, 93, 9, 93, 4, 94, 9, 94, 4, 95, 9, 95, 4, 96, 9, 96, 4, 97,
	9, 97, 4, 98, 9, 98, 4, 99, 9, 99, 4, 100, 9, 100, 4, 101, 9, 101, 4, 102,
	9, 102, 4, 103, 9, 103, 4, 104, 9, 104, 4, 105, 9, 105, 4, 106, 9, 106,
	4, 107, 9, 107, 4, 108, 9, 108, 4, 109, 9, 109, 4, 110, 9, 110, 4, 111,
	9, 111, 4, 112, 9, 112, 4, 113, 9, 113, 4, 114, 9, 114, 4, 115, 9, 115,
	4, 116, 9, 116, 4, 117, 9, 117, 4, 118, 9, 118, 4, 119, 9, 119, 4, 120,
	9, 120, 4, 121, 9, 121, 4, 122, 9, 122, 4, 123, 9, 123, 4, 124, 9, 124,
	4, 125, 9, 125, 4, 126, 9, 126, 4, 127, 9, 127, 4, 128, 9, 128, 4, 129,
	9, 129, 4, 130, 9, 130, 4, 131, 9, 131, 4, 132, 9, 132, 4, 133, 9, 133,
	4, 134, 9, 134, 4, 135, 9, 135, 4, 136, 9, 136, 4, 137, 9, 137, 4, 138,
	9, 138, 4, 139, 9, 139, 4, 140, 9, 140, 4, 141, 9, 141, 4, 142, 9, 142,
	4, 143, 9, 143, 4, 144, 9, 144, 4, 145, 9, 145, 4, 146, 9, 146, 4, 147,
	9, 147, 4, 148, 9, 148, 4, 149, 9, 149, 4, 150, 9, 150, 4, 151, 9, 151,
	4, 152, 9, 152, 3, 2, 3, 2, 5, 2, 307, 10, 2, 3, 2, 5, 2, 310, 10, 2, 3,
	2, 5, 2, 313, 10, 2, 3, 2, 3, 2, 3, 3, 3, 3, 3, 3, 3, 3, 7, 3, 321, 10,
	3, 12, 3, 14, 3, 324, 11, 3, 3, 3, 5, 3, 327, 10, 3, 3, 4, 3, 4, 3, 4,
	5, 4, 332, 10, 4, 3, 5, 3, 5, 3, 5, 3, 5, 3, 6, 3, 6, 3, 6, 5, 6, 341,
	10, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 5, 6, 348, 10, 6, 3, 7, 3, 7, 3, 7,
	3, 8, 3, 8, 5, 8, 355, 10, 8, 3, 9, 5, 9, 358, 10, 9, 3, 10, 3, 10, 3,
	10, 6, 10, 363, 10, 10, 13, 10, 14, 10, 364, 3, 11, 5, 11, 368, 10, 11,
	3, 12, 3, 12, 3, 12, 6, 12, 373, 10, 12, 13, 12, 14, 12, 374, 3, 13, 3,
	13, 5, 13, 379, 10, 13, 3, 14, 3, 14, 5, 14, 383, 10, 14, 3, 15, 5, 15,
	386, 10, 15, 3, 16, 3, 16, 3, 16, 6, 16, 391, 10, 16, 13, 16, 14, 16, 392,
	3, 17, 3, 17, 3, 17, 3, 17, 3, 17, 3, 17, 3, 17, 7, 17, 402, 10, 17, 12,
	17, 14, 17, 405, 11, 17, 3, 17, 3, 17, 3, 17, 3, 18, 3, 18, 3, 18, 3, 18,
	3, 18, 5, 18, 415, 10, 18, 3, 19, 3, 19, 3, 19, 3, 19, 3, 19, 7, 19, 422,
	10, 19, 12, 19, 14, 19, 425, 11, 19, 3, 20, 3, 20, 3, 20, 3, 20, 3, 20,
	7, 20, 432, 10, 20, 12, 20, 14, 20, 435, 11, 20, 3, 21, 3, 21, 3, 21, 3,
	21, 3, 21, 3, 21, 3, 21, 3, 21, 3, 21, 3, 21, 3, 21, 5, 21, 448, 10, 21,
	3, 21, 3, 21, 3, 21, 3, 21, 5, 21, 454, 10, 21, 3, 21, 3, 21, 3, 21, 3,
	21, 3, 21, 3, 21, 3, 21, 5, 21, 463, 10, 21, 3, 21, 3, 21, 5, 21, 467,
	10, 21, 3, 21, 5, 21, 470, 10, 21, 3, 21, 3, 21, 3, 21, 3, 21, 3, 21, 3,
	21, 5, 21, 478, 10, 21, 3, 21, 5, 21, 481, 10, 21, 3, 21, 5, 21, 484, 10,
	21, 3, 21, 3, 21, 3, 22, 3, 22, 3, 22, 3, 22, 5, 22, 492, 10, 22, 3, 22,
	5, 22, 495, 10, 22, 3, 22, 5, 22, 498, 10, 22, 3, 22, 5, 22, 501, 10, 22,
	3, 22, 3, 22, 3, 22, 7, 22, 506, 10, 22, 12, 22, 14, 22, 509, 11, 22, 3,
	22, 5, 22, 512, 10, 22, 3, 22, 3, 22, 3, 23, 3, 23, 3, 23, 3, 23, 3, 23,
	3, 23, 7, 23, 522, 10, 23, 12, 23, 14, 23, 525, 11, 23, 3, 23, 3, 23, 3,
	23, 5, 23, 530, 10, 23, 3, 24, 3, 24, 3, 24, 5, 24, 535, 10, 24, 3, 24,
	5, 24, 538, 10, 24, 3, 25, 3, 25, 3, 25, 5, 25, 543, 10, 25, 3, 25, 3,
	25, 5, 25, 547, 10, 25, 3, 26, 3, 26, 3, 26, 3, 26, 3, 26, 5, 26, 554,
	10, 26, 3, 27, 3, 27, 3, 27, 3, 27, 3, 27, 3, 27, 3, 27, 3, 27, 3, 27,
	5, 27, 565, 10, 27, 3, 27, 3, 27, 5, 27, 569, 10, 27, 3, 27, 5, 27, 572,
	10, 27, 3, 27, 3, 27, 3, 27, 3, 27, 3, 27, 3, 27, 3, 27, 5, 27, 581, 10,
	27, 3, 27, 3, 27, 5, 27, 585, 10, 27, 5, 27, 587, 10, 27, 3, 28, 3, 28,
	5, 28, 591, 10, 28, 3, 29, 3, 29, 3, 29, 5, 29, 596, 10, 29, 3, 30, 3,
	30, 3, 31, 3, 31, 3, 31, 3, 31, 3, 31, 7, 31, 605, 10, 31, 12, 31, 14,
	31, 608, 11, 31, 3, 32, 3, 32, 3, 32, 3, 32, 3, 32, 3, 32, 5, 32, 616,
	10, 32, 3, 33, 3, 33, 3, 34, 3, 34, 3, 35, 3, 35, 3, 35, 3, 35, 3, 35,
	3, 35, 3, 35, 7, 35, 629, 10, 35, 12, 35, 14, 35, 632, 11, 35, 3, 35, 3,
	35, 5, 35, 636, 10, 35, 3, 36, 3, 36, 3, 36, 3, 36, 6, 36, 642, 10, 36,
	13, 36, 14, 36, 643, 3, 37, 5, 37, 647, 10, 37, 3, 38, 3, 38, 3, 38, 5,
	38, 652, 10, 38, 3, 38, 3, 38, 3, 39, 3, 39, 3, 39, 5, 39, 659, 10, 39,
	3, 39, 5, 39, 662, 10, 39, 3, 39, 3, 39, 3, 40, 3, 40, 5, 40, 668, 10,
	40, 3, 40, 5, 40, 671, 10, 40, 3, 41, 3, 41, 5, 41, 675, 10, 41, 3, 42,
	3, 42, 5, 42, 679, 10, 42, 3, 43, 3, 43, 3, 44, 3, 44, 3, 44, 3, 44, 3,
	44, 3, 44, 3, 44, 7, 44, 690, 10, 44, 12, 44, 14, 44, 693, 11, 44, 3, 44,
	3, 44, 3, 44, 3, 45, 3, 45, 3, 45, 3, 45, 3, 45, 3, 45, 3, 45, 5, 45, 705,
	10, 45, 5, 45, 707, 10, 45, 3, 46, 3, 46, 3, 46, 3, 47, 3, 47, 3, 47, 3,
	47, 3, 47, 7, 47, 717, 10, 47, 12, 47, 14, 47, 720, 11, 47, 3, 48, 3, 48,
	5, 48, 724, 10, 48, 3, 48, 3, 48, 3, 49, 3, 49, 5, 49, 730, 10, 49, 3,
	49, 3, 49, 3, 49, 3, 49, 7, 49, 736, 10, 49, 12, 49, 14, 49, 739, 11, 49,
	3, 50, 3, 50, 3, 50, 3, 51, 3, 51, 5, 51, 746, 10, 51, 3, 51, 5, 51, 749,
	10, 51, 3, 51, 3, 51, 3, 51, 3, 51, 3, 51, 3, 51, 5, 51, 757, 10, 51, 3,
	52, 3, 52, 3, 53, 3, 53, 3, 53, 7, 53, 764, 10, 53, 12, 53, 14, 53, 767,
	11, 53, 3, 54, 3, 54, 3, 54, 3, 54, 3, 54, 5, 54, 774, 10, 54, 3, 55, 3,
	55, 3, 55, 7, 55, 779, 10, 55, 12, 55, 14, 55, 782, 11, 55, 3, 56, 3, 56,
	3, 56, 3, 57, 3, 57, 3, 57, 3, 57, 7, 57, 791, 10, 57, 12, 57, 14, 57,
	794, 11, 57, 3, 58, 3, 58, 3, 58, 3, 58, 3, 58, 5, 58, 801, 10, 58, 3,
	59, 3, 59, 3, 59, 3, 59, 7, 59, 807, 10, 59, 12, 59, 14, 59, 810, 11, 59,
	3, 59, 3, 59, 3, 60, 3, 60, 3, 60, 5, 60, 817, 10, 60, 3, 60, 3, 60, 5,
	60, 821, 10, 60, 3, 61, 3, 61, 7, 61, 825, 10, 61, 12, 61, 14, 61, 828,
	11, 61, 3, 62, 3, 62, 3, 62, 3, 62, 3, 62, 3, 62, 3, 63, 3, 63, 3, 63,
	3, 63, 3, 63, 3, 63, 3, 64, 3, 64, 3, 65, 3, 65, 5, 65, 846, 10, 65, 3,
	66, 3, 66, 5, 66, 850, 10, 66, 3, 67, 3, 67, 3, 67, 5, 67, 855, 10, 67,
	3, 67, 3, 67, 3, 67, 3, 67, 5, 67, 861, 10, 67, 3, 67, 3, 67, 3, 67, 3,
	68, 3, 68, 5, 68, 868, 10, 68, 3, 69, 5, 69, 871, 10, 69, 3, 70, 3, 70,
	3, 70, 3, 70, 7, 70, 877, 10, 70, 12, 70, 14, 70, 880, 11, 70, 3, 70, 5,
	70, 883, 10, 70, 3, 71, 3, 71, 3, 71, 7, 71, 888, 10, 71, 12, 71, 14, 71,
	891, 11, 71, 3, 72, 3, 72, 3, 72, 3, 72, 5, 72, 897, 10, 72, 3, 72, 5,
	72, 900, 10, 72, 3, 73, 3, 73, 5, 73, 904, 10, 73, 3, 74, 3, 74, 3, 75,
	3, 75, 3, 75, 7, 75, 911, 10, 75, 12, 75, 14, 75, 914, 11, 75, 3, 76, 3,
	76, 3, 76, 3, 76, 3, 76, 3, 76, 3, 77, 3, 77, 5, 77, 924, 10, 77, 3, 78,
	3, 78, 3, 78, 5, 78, 929, 10, 78, 3, 79, 3, 79, 3, 79, 3, 79, 7, 79, 935,
	10, 79, 12, 79, 14, 79, 938, 11, 79, 5, 79, 940, 10, 79, 3, 79, 5, 79,
	943, 10, 79, 3, 79, 3, 79, 3, 80, 3, 80, 3, 80, 7, 80, 950, 10, 80, 12,
	80, 14, 80, 953, 11, 80, 5, 80, 955, 10, 80, 3, 80, 3, 80, 3, 80, 3, 81,
	3, 81, 5, 81, 962, 10, 81, 3, 82, 3, 82, 3, 82, 3, 83, 3, 83, 3, 83, 3,
	83, 5, 83, 971, 10, 83, 3, 84, 3, 84, 5, 84, 975, 10, 84, 3, 84, 3, 84,
	3, 84, 3, 84, 3, 84, 3, 84, 3, 84, 5, 84, 984, 10, 84, 3, 84, 5, 84, 987,
	10, 84, 3, 84, 3, 84, 3, 84, 5, 84, 992, 10, 84, 3, 85, 3, 85, 3, 85, 3,
	85, 7, 85, 998, 10, 85, 12, 85, 14, 85, 1001, 11, 85, 3, 85, 3, 85, 3,
	86, 5, 86, 1006, 10, 86, 3, 86, 3, 86, 3, 87, 3, 87, 3, 87, 3, 87, 6, 87,
	1014, 10, 87, 13, 87, 14, 87, 1015, 3, 87, 3, 87, 3, 88, 3, 88, 5, 88,
	1022, 10, 88, 3, 89, 3, 89, 3, 89, 3, 89, 3, 89, 3, 89, 5, 89, 1030, 10,
	89, 3, 89, 3, 89, 3, 89, 3, 89, 5, 89, 1036, 10, 89, 3, 90, 3, 90, 3, 90,
	3, 90, 3, 90, 3, 90, 7, 90, 1044, 10, 90, 12, 90, 14, 90, 1047, 11, 90,
	3, 90, 3, 90, 3, 90, 3, 91, 3, 91, 3, 91, 3, 91, 3, 91, 3, 91, 3, 91, 3,
	91, 3, 91, 3, 91, 3, 91, 3, 91, 3, 91, 3, 91, 3, 91, 3, 91, 3, 91, 3, 91,
	3, 91, 5, 91, 1071, 10, 91, 3, 92, 3, 92, 5, 92, 1075, 10, 92, 3, 93, 3,
	93, 5, 93, 1079, 10, 93, 3, 94, 3, 94, 5, 94, 1083, 10, 94, 3, 94, 3, 94,
	3, 94, 3, 94, 3, 94, 7, 94, 1090, 10, 94, 12, 94, 14, 94, 1093, 11, 94,
	3, 94, 3, 94, 3, 94, 5, 94, 1098, 10, 94, 3, 95, 3, 95, 3, 95, 3, 95, 3,
	95, 3, 95, 3, 95, 5, 95, 1107, 10, 95, 3, 96, 3, 96, 3, 96, 3, 96, 3, 96,
	3, 96, 3, 96, 3, 96, 3, 96, 3, 96, 3, 96, 5, 96, 1120, 10, 96, 3, 96, 3,
	96, 3, 96, 3, 96, 3, 96, 3, 96, 3, 96, 3, 96, 3, 96, 3, 96, 3, 96, 3, 96,
	3, 96, 3, 96, 3, 96, 5, 96, 1137, 10, 96, 3, 97, 3, 97, 3, 97, 3, 97, 5,
	97, 1143, 10, 97, 3, 97, 3, 97, 3, 97, 3, 97, 3, 97, 3, 98, 3, 98, 3, 98,
	7, 98, 1153, 10, 98, 12, 98, 14, 98, 1156, 11, 98, 3, 99, 3, 99, 3, 99,
	3, 99, 3, 100, 3, 100, 3, 100, 3, 100, 5, 100, 1166, 10, 100, 3, 100, 3,
	100, 3, 101, 3, 101, 3, 101, 3, 101, 7, 101, 1174, 10, 101, 12, 101, 14,
	101, 1177, 11, 101, 3, 102, 3, 102, 5, 102, 1181, 10, 102, 3, 103, 3, 103,
	3, 103, 6, 103, 1186, 10, 103, 13, 103, 14, 103, 1187, 3, 103, 3, 103,
	3, 104, 3, 104, 3, 104, 3, 104, 3, 104, 3, 104, 5, 104, 1198, 10, 104,
	3, 105, 3, 105, 5, 105, 1202, 10, 105, 3, 106, 3, 106, 5, 106, 1206, 10,
	106, 3, 106, 3, 106, 3, 106, 3, 106, 3, 107, 5, 107, 1213, 10, 107, 3,
	107, 3, 107, 5, 107, 1217, 10, 107, 3, 107, 3, 107, 5, 107, 1221, 10, 107,
	3, 108, 3, 108, 5, 108, 1225, 10, 108, 3, 109, 3, 109, 3, 110, 3, 110,
	3, 110, 3, 110, 3, 111, 3, 111, 3, 112, 3, 112, 3, 112, 3, 112, 3, 113,
	3, 113, 3, 113, 7, 113, 1242, 10, 113, 12, 113, 14, 113, 1245, 11, 113,
	3, 114, 3, 114, 3, 114, 5, 114, 1250, 10, 114, 3, 114, 3, 114, 3, 115,
	3, 115, 5, 115, 1256, 10, 115, 3, 116, 3, 116, 3, 117, 3, 117, 5, 117,
	1262, 10, 117, 3, 118, 3, 118, 3, 118, 3, 118, 3, 118, 3, 118, 3, 118,
	3, 118, 3, 118, 3, 118, 3, 118, 3, 118, 3, 118, 3, 118, 3, 118, 3, 118,
	3, 118, 5, 118, 1281, 10, 118, 3, 118, 3, 118, 3, 118, 3, 118, 3, 118,
	3, 118, 3, 118, 3, 118, 3, 118, 3, 118, 3, 118, 3, 118, 3, 118, 3, 118,
	3, 118, 3, 118, 3, 118, 3, 118, 3, 118, 3, 118, 3, 118, 3, 118, 3, 118,
	3, 118, 3, 118, 5, 118, 1308, 10, 118, 3, 118, 5, 118, 1311, 10, 118, 3,
	118, 3, 118, 3, 118, 3, 118, 3, 118, 3, 118, 3, 118, 3, 118, 3, 118, 3,
	118, 3, 118, 3, 118, 3, 118, 3, 118, 3, 118, 3, 118, 3, 118, 3, 118, 3,
	118, 3, 118, 3, 118, 3, 118, 3, 118, 3, 118, 3, 118, 3, 118, 3, 118, 3,
	118, 3, 118, 3, 118, 3, 118, 3, 118, 3, 118, 3, 118, 3, 118, 3, 118, 3,
	118, 3, 118, 3, 118, 3, 118, 3, 118, 3, 118, 3, 118, 3, 118, 3, 118, 3,
	118, 3, 118, 3, 118, 3, 118, 3, 118, 3, 118, 3, 118, 3, 118, 3, 118, 3,
	118, 3, 118, 3, 118, 3, 118, 3, 118, 3, 118, 3, 118, 3, 118, 5, 118, 1375,
	10, 118, 3, 118, 3, 118, 3, 118, 3, 118, 3, 118, 3, 118, 3, 118, 3, 118,
	3, 118, 3, 118, 3, 118, 3, 118, 3, 118, 3, 118, 7, 118, 1391, 10, 118,
	12, 118, 14, 118, 1394, 11, 118, 3, 119, 3, 119, 3, 119, 3, 119, 3, 119,
	3, 119, 3, 119, 3, 119, 3, 119, 3, 119, 5, 119, 1406, 10, 119, 3, 120,
	3, 120, 3, 120, 3, 120, 5, 120, 1412, 10, 120, 3, 120, 7, 120, 1415, 10,
	120, 12, 120, 14, 120, 1418, 11, 120, 3, 121, 3, 121, 6, 121, 1422, 10,
	121, 13, 121, 14, 121, 1423, 3, 121, 5, 121, 1427, 10, 121, 3, 122, 3,
	122, 3, 122, 3, 122, 7, 122, 1433, 10, 122, 12, 122, 14, 122, 1436, 11,
	122, 3, 123, 3, 123, 3, 123, 3, 123, 3, 123, 5, 123, 1443, 10, 123, 3,
	123, 3, 123, 3, 123, 3, 123, 5, 123, 1449, 10, 123, 3, 123, 3, 123, 3,
	123, 3, 123, 3, 123, 3, 123, 3, 123, 3, 123, 3, 123, 3, 123, 3, 123, 3,
	123, 3, 123, 3, 123, 3, 123, 3, 123, 3, 123, 3, 123, 3, 123, 3, 123, 3,
	123, 3, 123, 3, 123, 5, 123, 1474, 10, 123, 3, 124, 3, 124, 3, 124, 3,
	124, 5, 124, 1480, 10, 124, 3, 125, 3, 125, 5, 125, 1484, 10, 125, 3, 126,
	5, 126, 1487, 10, 126, 3, 126, 3, 126, 5, 126, 1491, 10, 126, 3, 126, 3,
	126, 3, 127, 5, 127, 1496, 10, 127, 3, 127, 3, 127, 3, 127, 5, 127, 1501,
	10, 127, 3, 127, 3, 127, 3, 128, 3, 128, 5, 128, 1507, 10, 128, 3, 128,
	3, 128, 3, 128, 3, 128, 3, 128, 3, 128, 3, 128, 3, 128, 3, 128, 3, 128,
	3, 128, 3, 128, 3, 128, 5, 128, 1522, 10, 128, 3, 129, 3, 129, 5, 129,
	1526, 10, 129, 3, 129, 5, 129, 1529, 10, 129, 3, 129, 3, 129, 3, 130, 3,
	130, 3, 130, 5, 130, 1536, 10, 130, 3, 130, 5, 130, 1539, 10, 130, 3, 130,
	3, 130, 3, 131, 3, 131, 3, 131, 7, 131, 1546, 10, 131, 12, 131, 14, 131,
	1549, 11, 131, 3, 132, 3, 132, 3, 132, 3, 132, 3, 132, 3, 132, 3, 132,
	3, 132, 3, 132, 3, 132, 5, 132, 1561, 10, 132, 3, 133, 3, 133, 5, 133,
	1565, 10, 133, 3, 134, 3, 134, 3, 134, 3, 134, 3, 134, 5, 134, 1572, 10,
	134, 3, 134, 3, 134, 3, 134, 3, 134, 3, 134, 3, 134, 6, 134, 1580, 10,
	134, 13, 134, 14, 134, 1581, 3, 134, 3, 134, 3, 134, 3, 134, 3, 134, 3,
	134, 3, 134, 5, 134, 1591, 10, 134, 3, 135, 3, 135, 3, 135, 5, 135, 1596,
	10, 135, 3, 135, 3, 135, 3, 135, 3, 136, 3, 136, 3, 137, 3, 137, 3, 137,
	3, 137, 5, 137, 1607, 10, 137, 5, 137, 1609, 10, 137, 3, 138, 3, 138, 3,
	138, 3, 138, 3, 138, 3, 138, 3, 139, 3, 139, 3, 139, 5, 139, 1620, 10,
	139, 3, 140, 3, 140, 5, 140, 1624, 10, 140, 3, 140, 5, 140, 1627, 10, 140,
	3, 140, 3, 140, 3, 141, 3, 141, 3, 141, 3, 141, 3, 141, 7, 141, 1636, 10,
	141, 12, 141, 14, 141, 1639, 11, 141, 3, 142, 3, 142, 3, 142, 3, 142, 3,
	142, 7, 142, 1646, 10, 142, 12, 142, 14, 142, 1649, 11, 142, 3, 143, 3,
	143, 5, 143, 1653, 10, 143, 3, 144, 3, 144, 3, 144, 5, 144, 1658, 10, 144,
	3, 145, 3, 145, 3, 146, 3, 146, 3, 147, 3, 147, 3, 147, 3, 147, 3, 147,
	3, 147, 3, 147, 3, 147, 5, 147, 1672, 10, 147, 3, 148, 3, 148, 3, 149,
	3, 149, 3, 150, 3, 150, 5, 150, 1680, 10, 150, 3, 151, 7, 151, 1683, 10,
	151, 12, 151, 14, 151, 1686, 11, 151, 3, 152, 6, 152, 1689, 10, 152, 13,
	152, 14, 152, 1690, 3, 152, 2, 3, 234, 153, 2, 4, 6, 8, 10, 12, 14, 16,
	18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52,
	54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88,
	90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112, 114, 116, 118, 120,
	122, 124, 126, 128, 130, 132, 134, 136, 138, 140, 142, 144, 146, 148, 150,
	152, 154, 156, 158, 160, 162, 164, 166, 168, 170, 172, 174, 176, 178, 180,
	182, 184, 186, 188, 190, 192, 194, 196, 198, 200, 202, 204, 206, 208, 210,
	212, 214, 216, 218, 220, 222, 224, 226, 228, 230, 232, 234, 236, 238, 240,
	242, 244, 246, 248, 250, 252, 254, 256, 258, 260, 262, 264, 266, 268, 270,
	272, 274, 276, 278, 280, 282, 284, 286, 288, 290, 292, 294, 296, 298, 300,
	302, 2, 23, 8, 2, 10, 10, 14, 14, 38, 38, 49, 49, 53, 53, 56, 56, 7, 2,
	16, 16, 24, 24, 29, 29, 41, 43, 45, 46, 8, 2, 10, 10, 14, 14, 16, 16, 29,
	29, 41, 43, 45, 46, 4, 2, 28, 28, 47, 47, 4, 2, 87, 87, 95, 95, 4, 2, 11,
	11, 95, 95, 3, 2, 102, 103, 3, 2, 92, 93, 3, 2, 102, 105, 4, 2, 106, 107,
	111, 111, 3, 2, 104, 105, 3, 2, 62, 63, 6, 2, 11, 11, 79, 79, 90, 91, 97,
	98, 5, 2, 74, 76, 96, 96, 99, 99, 3, 2, 70, 71, 5, 2, 9, 9, 36, 36, 78,
	78, 5, 2, 73, 73, 89, 89, 112, 123, 4, 2, 64, 66, 88, 88, 4, 2, 15, 15,
	55, 55, 4, 2, 9, 57, 60, 61, 4, 2, 86, 86, 129, 129, 2, 1802, 2, 304, 3,
	2, 2, 2, 4, 316, 3, 2, 2, 2, 6, 331, 3, 2, 2, 2, 8, 333, 3, 2, 2, 2, 10,
	337, 3, 2, 2, 2, 12, 349, 3, 2, 2, 2, 14, 354, 3, 2, 2, 2, 16, 357, 3,
	2, 2, 2, 18, 362, 3, 2, 2, 2, 20, 367, 3, 2, 2, 2, 22, 372, 3, 2, 2, 2,
	24, 378, 3, 2, 2, 2, 26, 382, 3, 2, 2, 2, 28, 385, 3, 2, 2, 2, 30, 390,
	3, 2, 2, 2, 32, 394, 3, 2, 2, 2, 34, 409, 3, 2, 2, 2, 36, 416, 3, 2, 2,
	2, 38, 426, 3, 2, 2, 2, 40, 447, 3, 2, 2, 2, 42, 487, 3, 2, 2, 2, 44, 515,
	3, 2, 2, 2, 46, 531, 3, 2, 2, 2, 48, 546, 3, 2, 2, 2, 50, 553, 3, 2, 2,
	2, 52, 586, 3, 2, 2, 2, 54, 590, 3, 2, 2, 2, 56, 595, 3, 2, 2, 2, 58, 597,
	3, 2, 2, 2, 60, 599, 3, 2, 2, 2, 62, 609, 3, 2, 2, 2, 64, 617, 3, 2, 2,
	2, 66, 619, 3, 2, 2, 2, 68, 621, 3, 2, 2, 2, 70, 641, 3, 2, 2, 2, 72, 646,
	3, 2, 2, 2, 74, 648, 3, 2, 2, 2, 76, 655, 3, 2, 2, 2, 78, 667, 3, 2, 2,
	2, 80, 672, 3, 2, 2, 2, 82, 676, 3, 2, 2, 2, 84, 680, 3, 2, 2, 2, 86, 682,
	3, 2, 2, 2, 88, 706, 3, 2, 2, 2, 90, 708, 3, 2, 2, 2, 92, 711, 3, 2, 2,
	2, 94, 721, 3, 2, 2, 2, 96, 729, 3, 2, 2, 2, 98, 740, 3, 2, 2, 2, 100,
	743, 3, 2, 2, 2, 102, 758, 3, 2, 2, 2, 104, 760, 3, 2, 2, 2, 106, 773,
	3, 2, 2, 2, 108, 780, 3, 2, 2, 2, 110, 783, 3, 2, 2, 2, 112, 786, 3, 2,
	2, 2, 114, 800, 3, 2, 2, 2, 116, 802, 3, 2, 2, 2, 118, 820, 3, 2, 2, 2,
	120, 822, 3, 2, 2, 2, 122, 829, 3, 2, 2, 2, 124, 835, 3, 2, 2, 2, 126,
	841, 3, 2, 2, 2, 128, 845, 3, 2, 2, 2, 130, 849, 3, 2, 2, 2, 132, 851,
	3, 2, 2, 2, 134, 867, 3, 2, 2, 2, 136, 870, 3, 2, 2, 2, 138, 872, 3, 2,
	2, 2, 140, 889, 3, 2, 2, 2, 142, 892, 3, 2, 2, 2, 144, 903, 3, 2, 2, 2,
	146, 905, 3, 2, 2, 2, 148, 907, 3, 2, 2, 2, 150, 915, 3, 2, 2, 2, 152,
	923, 3, 2, 2, 2, 154, 928, 3, 2, 2, 2, 156, 930, 3, 2, 2, 2, 158, 946,
	3, 2, 2, 2, 160, 961, 3, 2, 2, 2, 162, 963, 3, 2, 2, 2, 164, 970, 3, 2,
	2, 2, 166, 991, 3, 2, 2, 2, 168, 993, 3, 2, 2, 2, 170, 1005, 3, 2, 2, 2,
	172, 1009, 3, 2, 2, 2, 174, 1021, 3, 2, 2, 2, 176, 1023, 3, 2, 2, 2, 178,
	1037, 3, 2, 2, 2, 180, 1070, 3, 2, 2, 2, 182, 1072, 3, 2, 2, 2, 184, 1076,
	3, 2, 2, 2, 186, 1080, 3, 2, 2, 2, 188, 1099, 3, 2, 2, 2, 190, 1136, 3,
	2, 2, 2, 192, 1138, 3, 2, 2, 2, 194, 1149, 3, 2, 2, 2, 196, 1157, 3, 2,
	2, 2, 198, 1161, 3, 2, 2, 2, 200, 1169, 3, 2, 2, 2, 202, 1180, 3, 2, 2,
	2, 204, 1185, 3, 2, 2, 2, 206, 1197, 3, 2, 2, 2, 208, 1201, 3, 2, 2, 2,
	210, 1203, 3, 2, 2, 2, 212, 1212, 3, 2, 2, 2, 214, 1224, 3, 2, 2, 2, 216,
	1226, 3, 2, 2, 2, 218, 1228, 3, 2, 2, 2, 220, 1232, 3, 2, 2, 2, 222, 1234,
	3, 2, 2, 2, 224, 1238, 3, 2, 2, 2, 226, 1249, 3, 2, 2, 2, 228, 1255, 3,
	2, 2, 2, 230, 1257, 3, 2, 2, 2, 232, 1259, 3, 2, 2, 2, 234, 1280, 3, 2,
	2, 2, 236, 1405, 3, 2, 2, 2, 238, 1407, 3, 2, 2, 2, 240, 1419, 3, 2, 2,
	2, 242, 1428, 3, 2, 2, 2, 244, 1473, 3, 2, 2, 2, 246, 1479, 3, 2, 2, 2,
	248, 1483, 3, 2, 2, 2, 250, 1486, 3, 2, 2, 2, 252, 1495, 3, 2, 2, 2, 254,
	1521, 3, 2, 2, 2, 256, 1523, 3, 2, 2, 2, 258, 1532, 3, 2, 2, 2, 260, 1542,
	3, 2, 2, 2, 262, 1560, 3, 2, 2, 2, 264, 1564, 3, 2, 2, 2, 266, 1566, 3,
	2, 2, 2, 268, 1592, 3, 2, 2, 2, 270, 1600, 3, 2, 2, 2, 272, 1602, 3, 2,
	2, 2, 274, 1610, 3, 2, 2, 2, 276, 1619, 3, 2, 2, 2, 278, 1621, 3, 2, 2,
	2, 280, 1630, 3, 2, 2, 2, 282, 1640, 3, 2, 2, 2, 284, 1652, 3, 2, 2, 2,
	286, 1657, 3, 2, 2, 2, 288, 1659, 3, 2, 2, 2, 290, 1661, 3, 2, 2, 2, 292,
	1671, 3, 2, 2, 2, 294, 1673, 3, 2, 2, 2, 296, 1675, 3, 2, 2, 2, 298, 1679,
	3, 2, 2, 2, 300, 1684, 3, 2, 2, 2, 302, 1688, 3, 2, 2, 2, 304, 306, 5,
	300, 151, 2, 305, 307, 5, 8, 5, 2, 306, 305, 3, 2, 2, 2, 306, 307, 3, 2,
	2, 2, 307, 309, 3, 2, 2, 2, 308, 310, 5, 302, 152, 2, 309, 308, 3, 2, 2,
	2, 309, 310, 3, 2, 2, 2, 310, 312, 3, 2, 2, 2, 311, 313, 5, 4, 3, 2, 312,
	311, 3, 2, 2, 2, 312, 313, 3, 2, 2, 2, 313, 314, 3, 2, 2, 2, 314, 315,
	7, 2, 2, 3, 315, 3, 3, 2, 2, 2, 316, 322, 5, 6, 4, 2, 317, 318, 5, 302,
	152, 2, 318, 319, 5, 6, 4, 2, 319, 321, 3, 2, 2, 2, 320, 317, 3, 2, 2,
	2, 321, 324, 3, 2, 2, 2, 322, 320, 3, 2, 2, 2, 322, 323, 3, 2, 2, 2, 323,
	326, 3, 2, 2, 2, 324, 322, 3, 2, 2, 2, 325, 327, 5, 302, 152, 2, 326, 325,
	3, 2, 2, 2, 326, 327, 3, 2, 2, 2, 327, 5, 3, 2, 2, 2, 328, 332, 5, 10,
	6, 2, 329, 332, 5, 12, 7, 2, 330, 332, 5, 190, 96, 2, 331, 328, 3, 2, 2,
	2, 331, 329, 3, 2, 2, 2, 331, 330, 3, 2, 2, 2, 332, 7, 3, 2, 2, 2, 333,
	334, 5, 140, 71, 2, 334, 335, 7, 40, 2, 2, 335, 336, 5, 104, 53, 2, 336,
	9, 3, 2, 2, 2, 337, 338, 5, 140, 71, 2, 338, 340, 7, 35, 2, 2, 339, 341,
	7, 45, 2, 2, 340, 339, 3, 2, 2, 2, 340, 341, 3, 2, 2, 2, 341, 342, 3, 2,
	2, 2, 342, 347, 5, 104, 53, 2, 343, 344, 7, 88, 2, 2, 344, 348, 7, 106,
	2, 2, 345, 346, 7, 9, 2, 2, 346, 348, 5, 292, 147, 2, 347, 343, 3, 2, 2,
	2, 347, 345, 3, 2, 2, 2, 347, 348, 3, 2, 2, 2, 348, 11, 3, 2, 2, 2, 349,
	350, 5, 20, 11, 2, 350, 351, 5, 40, 21, 2, 351, 13, 3, 2, 2, 2, 352, 355,
	5, 24, 13, 2, 353, 355, 9, 2, 2, 2, 354, 352, 3, 2, 2, 2, 354, 353, 3,
	2, 2, 2, 355, 15, 3, 2, 2, 2, 356, 358, 5, 18, 10, 2, 357, 356, 3, 2, 2,
	2, 357, 358, 3, 2, 2, 2, 358, 17, 3, 2, 2, 2, 359, 360, 5, 14, 8, 2, 360,
	361, 5, 300, 151, 2, 361, 363, 3, 2, 2, 2, 362, 359, 3, 2, 2, 2, 363, 364,
	3, 2, 2, 2, 364, 362, 3, 2, 2, 2, 364, 365, 3, 2, 2, 2, 365, 19, 3, 2,
	2, 2, 366, 368, 5, 22, 12, 2, 367, 366, 3, 2, 2, 2, 367, 368, 3, 2, 2,
	2, 368, 21, 3, 2, 2, 2, 369, 370, 5, 24, 13, 2, 370, 371, 5, 300, 151,
	2, 371, 373, 3, 2, 2, 2, 372, 369, 3, 2, 2, 2, 373, 374, 3, 2, 2, 2, 374,
	372, 3, 2, 2, 2, 374, 375, 3, 2, 2, 2, 375, 23, 3, 2, 2, 2, 376, 379, 5,
	142, 72, 2, 377, 379, 9, 3, 2, 2, 378, 376, 3, 2, 2, 2, 378, 377, 3, 2,
	2, 2, 379, 25, 3, 2, 2, 2, 380, 383, 5, 142, 72, 2, 381, 383, 9, 4, 2,
	2, 382, 380, 3, 2, 2, 2, 382, 381, 3, 2, 2, 2, 383, 27, 3, 2, 2, 2, 384,
	386, 5, 30, 16, 2, 385, 384, 3, 2, 2, 2, 385, 386, 3, 2, 2, 2, 386, 29,
	3, 2, 2, 2, 387, 388, 5, 26, 14, 2, 388, 389, 5, 300, 151, 2, 389, 391,
	3, 2, 2, 2, 390, 387, 3, 2, 2, 2, 391, 392, 3, 2, 2, 2, 392, 390, 3, 2,
	2, 2, 392, 393, 3, 2, 2, 2, 393, 31, 3, 2, 2, 2, 394, 395, 7, 91, 2, 2,
	395, 396, 5, 300, 151, 2, 396, 403, 5, 34, 18, 2, 397, 398, 7, 87, 2, 2,
	398, 399, 5, 300, 151, 2, 399, 400, 5, 34, 18, 2, 400, 402, 3, 2, 2, 2,
	401, 397, 3, 2, 2, 2, 402, 405, 3, 2, 2, 2, 403, 401, 3, 2, 2, 2, 403,
	404, 3, 2, 2, 2, 404, 406, 3, 2, 2, 2, 405, 403, 3, 2, 2, 2, 406, 407,
	5, 300, 151, 2, 407, 408, 7, 90, 2, 2, 408, 33, 3, 2, 2, 2, 409, 414, 5,
	290, 146, 2, 410, 411, 7, 28, 2, 2, 411, 412, 5, 300, 151, 2, 412, 413,
	5, 36, 19, 2, 413, 415, 3, 2, 2, 2, 414, 410, 3, 2, 2, 2, 414, 415, 3,
	2, 2, 2, 415, 35, 3, 2, 2, 2, 416, 423, 5, 76, 39, 2, 417, 418, 7, 108,
	2, 2, 418, 419, 5, 300, 151, 2, 419, 420, 5, 76, 39, 2, 420, 422, 3, 2,
	2, 2, 421, 417, 3, 2, 2, 2, 422, 425, 3, 2, 2, 2, 423, 421, 3, 2, 2, 2,
	423, 424, 3, 2, 2, 2, 424, 37, 3, 2, 2, 2, 425, 423, 3, 2, 2, 2, 426, 433,
	5, 76, 39, 2, 427, 428, 7, 87, 2, 2, 428, 429, 5, 300, 151, 2, 429, 430,
	5, 76, 39, 2, 430, 432, 3, 2, 2, 2, 431, 427, 3, 2, 2, 2, 432, 435, 3,
	2, 2, 2, 433, 431, 3, 2, 2, 2, 433, 434, 3, 2, 2, 2, 434, 39, 3, 2, 2,
	2, 435, 433, 3, 2, 2, 2, 436, 437, 7, 21, 2, 2, 437, 448, 8, 21, 1, 2,
	438, 439, 7, 37, 2, 2, 439, 448, 8, 21, 1, 2, 440, 441, 7, 27, 2, 2, 441,
	448, 8, 21, 1, 2, 442, 443, 7, 126, 2, 2, 443, 444, 7, 37, 2, 2, 444, 448,
	8, 21, 1, 2, 445, 446, 7, 12, 2, 2, 446, 448, 8, 21, 1, 2, 447, 436, 3,
	2, 2, 2, 447, 438, 3, 2, 2, 2, 447, 440, 3, 2, 2, 2, 447, 442, 3, 2, 2,
	2, 447, 445, 3, 2, 2, 2, 448, 449, 3, 2, 2, 2, 449, 450, 5, 292, 147, 2,
	450, 483, 5, 300, 151, 2, 451, 453, 6, 21, 2, 3, 452, 454, 5, 32, 17, 2,
	453, 452, 3, 2, 2, 2, 453, 454, 3, 2, 2, 2, 454, 455, 3, 2, 2, 2, 455,
	469, 5, 300, 151, 2, 456, 466, 6, 21, 3, 3, 457, 458, 7, 28, 2, 2, 458,
	462, 5, 300, 151, 2, 459, 460, 6, 21, 4, 3, 460, 463, 5, 38, 20, 2, 461,
	463, 5, 76, 39, 2, 462, 459, 3, 2, 2, 2, 462, 461, 3, 2, 2, 2, 463, 464,
	3, 2, 2, 2, 464, 465, 5, 300, 151, 2, 465, 467, 3, 2, 2, 2, 466, 457, 3,
	2, 2, 2, 466, 467, 3, 2, 2, 2, 467, 470, 3, 2, 2, 2, 468, 470, 3, 2, 2,
	2, 469, 456, 3, 2, 2, 2, 469, 468, 3, 2, 2, 2, 470, 480, 3, 2, 2, 2, 471,
	477, 6, 21, 5, 3, 472, 473, 7, 34, 2, 2, 473, 474, 5, 300, 151, 2, 474,
	475, 5, 38, 20, 2, 475, 476, 5, 300, 151, 2, 476, 478, 3, 2, 2, 2, 477,
	472, 3, 2, 2, 2, 477, 478, 3, 2, 2, 2, 478, 481, 3, 2, 2, 2, 479, 481,
	3, 2, 2, 2, 480, 471, 3, 2, 2, 2, 480, 479, 3, 2, 2, 2, 481, 484, 3, 2,
	2, 2, 482, 484, 3, 2, 2, 2, 483, 451, 3, 2, 2, 2, 483, 482, 3, 2, 2, 2,
	484, 485, 3, 2, 2, 2, 485, 486, 5, 42, 22, 2, 486, 41, 3, 2, 2, 2, 487,
	488, 7, 82, 2, 2, 488, 497, 5, 300, 151, 2, 489, 491, 6, 22, 6, 3, 490,
	492, 5, 44, 23, 2, 491, 490, 3, 2, 2, 2, 491, 492, 3, 2, 2, 2, 492, 494,
	3, 2, 2, 2, 493, 495, 5, 302, 152, 2, 494, 493, 3, 2, 2, 2, 494, 495, 3,
	2, 2, 2, 495, 498, 3, 2, 2, 2, 496, 498, 3, 2, 2, 2, 497, 489, 3, 2, 2,
	2, 497, 496, 3, 2, 2, 2, 498, 500, 3, 2, 2, 2, 499, 501, 5, 48, 25, 2,
	500, 499, 3, 2, 2, 2, 500, 501, 3, 2, 2, 2, 501, 507, 3, 2, 2, 2, 502,
	503, 5, 302, 152, 2, 503, 504, 5, 48, 25, 2, 504, 506, 3, 2, 2, 2, 505,
	502, 3, 2, 2, 2, 506, 509, 3, 2, 2, 2, 507, 505, 3, 2, 2, 2, 507, 508,
	3, 2, 2, 2, 508, 511, 3, 2, 2, 2, 509, 507, 3, 2, 2, 2, 510, 512, 5, 302,
	152, 2, 511, 510, 3, 2, 2, 2, 511, 512, 3, 2, 2, 2, 512, 513, 3, 2, 2,
	2, 513, 514, 7, 83, 2, 2, 514, 43, 3, 2, 2, 2, 515, 523, 5, 46, 24, 2,
	516, 517, 5, 300, 151, 2, 517, 518, 7, 87, 2, 2, 518, 519, 5, 300, 151,
	2, 519, 520, 5, 46, 24, 2, 520, 522, 3, 2, 2, 2, 521, 516, 3, 2, 2, 2,
	522, 525, 3, 2, 2, 2, 523, 521, 3, 2, 2, 2, 523, 524, 3, 2, 2, 2, 524,
	529, 3, 2, 2, 2, 525, 523, 3, 2, 2, 2, 526, 527, 5, 300, 151, 2, 527, 528,
	7, 87, 2, 2, 528, 530, 3, 2, 2, 2, 529, 526, 3, 2, 2, 2, 529, 530, 3, 2,
	2, 2, 530, 45, 3, 2, 2, 2, 531, 532, 5, 140, 71, 2, 532, 534, 5, 292, 147,
	2, 533, 535, 5, 278, 140, 2, 534, 533, 3, 2, 2, 2, 534, 535, 3, 2, 2, 2,
	535, 537, 3, 2, 2, 2, 536, 538, 5, 270, 136, 2, 537, 536, 3, 2, 2, 2, 537,
	538, 3, 2, 2, 2, 538, 47, 3, 2, 2, 2, 539, 547, 7, 86, 2, 2, 540, 541,
	7, 45, 2, 2, 541, 543, 5, 300, 151, 2, 542, 540, 3, 2, 2, 2, 542, 543,
	3, 2, 2, 2, 543, 544, 3, 2, 2, 2, 544, 547, 5, 158, 80, 2, 545, 547, 5,
	50, 26, 2, 546, 539, 3, 2, 2, 2, 546, 542, 3, 2, 2, 2, 546, 545, 3, 2,
	2, 2, 547, 49, 3, 2, 2, 2, 548, 554, 5, 52, 27, 2, 549, 554, 5, 58, 30,
	2, 550, 551, 5, 16, 9, 2, 551, 552, 5, 40, 21, 2, 552, 554, 3, 2, 2, 2,
	553, 548, 3, 2, 2, 2, 553, 549, 3, 2, 2, 2, 553, 550, 3, 2, 2, 2, 554,
	51, 3, 2, 2, 2, 555, 556, 6, 27, 7, 3, 556, 557, 5, 56, 29, 2, 557, 558,
	5, 54, 28, 2, 558, 559, 7, 80, 2, 2, 559, 564, 5, 298, 150, 2, 560, 561,
	7, 24, 2, 2, 561, 562, 5, 300, 151, 2, 562, 563, 5, 154, 78, 2, 563, 565,
	3, 2, 2, 2, 564, 560, 3, 2, 2, 2, 564, 565, 3, 2, 2, 2, 565, 587, 3, 2,
	2, 2, 566, 568, 5, 16, 9, 2, 567, 569, 5, 32, 17, 2, 568, 567, 3, 2, 2,
	2, 568, 569, 3, 2, 2, 2, 569, 571, 3, 2, 2, 2, 570, 572, 5, 56, 29, 2,
	571, 570, 3, 2, 2, 2, 571, 572, 3, 2, 2, 2, 572, 573, 3, 2, 2, 2, 573,
	574, 5, 54, 28, 2, 574, 580, 5, 94, 48, 2, 575, 576, 5, 300, 151, 2, 576,
	577, 7, 52, 2, 2, 577, 578, 5, 300, 151, 2, 578, 579, 5, 92, 47, 2, 579,
	581, 3, 2, 2, 2, 580, 575, 3, 2, 2, 2, 580, 581, 3, 2, 2, 2, 581, 582,
	3, 2, 2, 2, 582, 584, 5, 300, 151, 2, 583, 585, 5, 102, 52, 2, 584, 583,
	3, 2, 2, 2, 584, 585, 3, 2, 2, 2, 585, 587, 3, 2, 2, 2, 586, 555, 3, 2,
	2, 2, 586, 566, 3, 2, 2, 2, 587, 53, 3, 2, 2, 2, 588, 591, 5, 292, 147,
	2, 589, 591, 5, 288, 145, 2, 590, 588, 3, 2, 2, 2, 590, 589, 3, 2, 2, 2,
	591, 55, 3, 2, 2, 2, 592, 596, 5, 74, 38, 2, 593, 594, 6, 29, 8, 3, 594,
	596, 7, 55, 2, 2, 595, 592, 3, 2, 2, 2, 595, 593, 3, 2, 2, 2, 596, 57,
	3, 2, 2, 2, 597, 598, 5, 166, 84, 2, 598, 59, 3, 2, 2, 2, 599, 606, 5,
	62, 32, 2, 600, 601, 7, 87, 2, 2, 601, 602, 5, 300, 151, 2, 602, 603, 5,
	62, 32, 2, 603, 605, 3, 2, 2, 2, 604, 600, 3, 2, 2, 2, 605, 608, 3, 2,
	2, 2, 606, 604, 3, 2, 2, 2, 606, 607, 3, 2, 2, 2, 607, 61, 3, 2, 2, 2,
	608, 606, 3, 2, 2, 2, 609, 615, 5, 64, 33, 2, 610, 611, 5, 300, 151, 2,
	611, 612, 7, 89, 2, 2, 612, 613, 5, 300, 151, 2, 613, 614, 5, 66, 34, 2,
	614, 616, 3, 2, 2, 2, 615, 610, 3, 2, 2, 2, 615, 616, 3, 2, 2, 2, 616,
	63, 3, 2, 2, 2, 617, 618, 5, 292, 147, 2, 618, 65, 3, 2, 2, 2, 619, 620,
	5, 228, 115, 2, 620, 67, 3, 2, 2, 2, 621, 622, 5, 66, 34, 2, 622, 630,
	5, 300, 151, 2, 623, 624, 7, 87, 2, 2, 624, 625, 5, 300, 151, 2, 625, 626,
	5, 66, 34, 2, 626, 627, 5, 300, 151, 2, 627, 629, 3, 2, 2, 2, 628, 623,
	3, 2, 2, 2, 629, 632, 3, 2, 2, 2, 630, 628, 3, 2, 2, 2, 630, 631, 3, 2,
	2, 2, 631, 633, 3, 2, 2, 2, 632, 630, 3, 2, 2, 2, 633, 635, 5, 300, 151,
	2, 634, 636, 7, 87, 2, 2, 635, 634, 3, 2, 2, 2, 635, 636, 3, 2, 2, 2, 636,
	69, 3, 2, 2, 2, 637, 638, 5, 140, 71, 2, 638, 639, 7, 84, 2, 2, 639, 640,
	7, 85, 2, 2, 640, 642, 3, 2, 2, 2, 641, 637, 3, 2, 2, 2, 642, 643, 3, 2,
	2, 2, 643, 641, 3, 2, 2, 2, 643, 644, 3, 2, 2, 2, 644, 71, 3, 2, 2, 2,
	645, 647, 5, 70, 36, 2, 646, 645, 3, 2, 2, 2, 646, 647, 3, 2, 2, 2, 647,
	73, 3, 2, 2, 2, 648, 651, 5, 140, 71, 2, 649, 652, 5, 84, 43, 2, 650, 652,
	5, 82, 42, 2, 651, 649, 3, 2, 2, 2, 651, 650, 3, 2, 2, 2, 652, 653, 3,
	2, 2, 2, 653, 654, 5, 72, 37, 2, 654, 75, 3, 2, 2, 2, 655, 661, 5, 140,
	71, 2, 656, 659, 5, 84, 43, 2, 657, 659, 7, 55, 2, 2, 658, 656, 3, 2, 2,
	2, 658, 657, 3, 2, 2, 2, 659, 662, 3, 2, 2, 2, 660, 662, 5, 80, 41, 2,
	661, 658, 3, 2, 2, 2, 661, 660, 3, 2, 2, 2, 662, 663, 3, 2, 2, 2, 663,
	664, 5, 72, 37, 2, 664, 77, 3, 2, 2, 2, 665, 668, 5, 110, 56, 2, 666, 668,
	5, 112, 57, 2, 667, 665, 3, 2, 2, 2, 667, 666, 3, 2, 2, 2, 668, 670, 3,
	2, 2, 2, 669, 671, 5, 86, 44, 2, 670, 669, 3, 2, 2, 2, 670, 671, 3, 2,
	2, 2, 671, 79, 3, 2, 2, 2, 672, 674, 5, 110, 56, 2, 673, 675, 5, 86, 44,
	2, 674, 673, 3, 2, 2, 2, 674, 675, 3, 2, 2, 2, 675, 81, 3, 2, 2, 2, 676,
	678, 5, 112, 57, 2, 677, 679, 5, 86, 44, 2, 678, 677, 3, 2, 2, 2, 678,
	679, 3, 2, 2, 2, 679, 83, 3, 2, 2, 2, 680, 681, 7, 15, 2, 2, 681, 85, 3,
	2, 2, 2, 682, 683, 7, 91, 2, 2, 683, 684, 5, 300, 151, 2, 684, 691, 5,
	88, 45, 2, 685, 686, 7, 87, 2, 2, 686, 687, 5, 300, 151, 2, 687, 688, 5,
	88, 45, 2, 688, 690, 3, 2, 2, 2, 689, 685, 3, 2, 2, 2, 690, 693, 3, 2,
	2, 2, 691, 689, 3, 2, 2, 2, 691, 692, 3, 2, 2, 2, 692, 694, 3, 2, 2, 2,
	693, 691, 3, 2, 2, 2, 694, 695, 5, 300, 151, 2, 695, 696, 7, 90, 2, 2,
	696, 87, 3, 2, 2, 2, 697, 707, 5, 76, 39, 2, 698, 699, 5, 140, 71, 2, 699,
	704, 7, 94, 2, 2, 700, 701, 9, 5, 2, 2, 701, 702, 5, 300, 151, 2, 702,
	703, 5, 76, 39, 2, 703, 705, 3, 2, 2, 2, 704, 700, 3, 2, 2, 2, 704, 705,
	3, 2, 2, 2, 705, 707, 3, 2, 2, 2, 706, 697, 3, 2, 2, 2, 706, 698, 3, 2,
	2, 2, 707, 89, 3, 2, 2, 2, 708, 709, 5, 140, 71, 2, 709, 710, 5, 110, 56,
	2, 710, 91, 3, 2, 2, 2, 711, 718, 5, 90, 46, 2, 712, 713, 7, 87, 2, 2,
	713, 714, 5, 300, 151, 2, 714, 715, 5, 90, 46, 2, 715, 717, 3, 2, 2, 2,
	716, 712, 3, 2, 2, 2, 717, 720, 3, 2, 2, 2, 718, 716, 3, 2, 2, 2, 718,
	719, 3, 2, 2, 2, 719, 93, 3, 2, 2, 2, 720, 718, 3, 2, 2, 2, 721, 723, 7,
	80, 2, 2, 722, 724, 5, 96, 49, 2, 723, 722, 3, 2, 2, 2, 723, 724, 3, 2,
	2, 2, 724, 725, 3, 2, 2, 2, 725, 726, 5, 298, 150, 2, 726, 95, 3, 2, 2,
	2, 727, 730, 5, 100, 51, 2, 728, 730, 5, 98, 50, 2, 729, 727, 3, 2, 2,
	2, 729, 728, 3, 2, 2, 2, 730, 737, 3, 2, 2, 2, 731, 732, 7, 87, 2, 2, 732,
	733, 5, 300, 151, 2, 733, 734, 5, 100, 51, 2, 734, 736, 3, 2, 2, 2, 735,
	731, 3, 2, 2, 2, 736, 739, 3, 2, 2, 2, 737, 735, 3, 2, 2, 2, 737, 738,
	3, 2, 2, 2, 738, 97, 3, 2, 2, 2, 739, 737, 3, 2, 2, 2, 740, 741, 5, 76,
	39, 2, 741, 742, 7, 50, 2, 2, 742, 99, 3, 2, 2, 2, 743, 745, 5, 28, 15,
	2, 744, 746, 5, 76, 39, 2, 745, 744, 3, 2, 2, 2, 745, 746, 3, 2, 2, 2,
	746, 748, 3, 2, 2, 2, 747, 749, 7, 127, 2, 2, 748, 747, 3, 2, 2, 2, 748,
	749, 3, 2, 2, 2, 749, 750, 3, 2, 2, 2, 750, 756, 5, 64, 33, 2, 751, 752,
	5, 300, 151, 2, 752, 753, 7, 89, 2, 2, 753, 754, 5, 300, 151, 2, 754, 755,
	5, 234, 118, 2, 755, 757, 3, 2, 2, 2, 756, 751, 3, 2, 2, 2, 756, 757, 3,
	2, 2, 2, 757, 101, 3, 2, 2, 2, 758, 759, 5, 158, 80, 2, 759, 103, 3, 2,
	2, 2, 760, 765, 5, 106, 54, 2, 761, 762, 7, 88, 2, 2, 762, 764, 5, 106,
	54, 2, 763, 761, 3, 2, 2, 2, 764, 767, 3, 2, 2, 2, 765, 763, 3, 2, 2, 2,
	765, 766, 3, 2, 2, 2, 766, 105, 3, 2, 2, 2, 767, 765, 3, 2, 2, 2, 768,
	774, 5, 292, 147, 2, 769, 774, 7, 10, 2, 2, 770, 774, 7, 11, 2, 2, 771,
	774, 7, 9, 2, 2, 772, 774, 7, 12, 2, 2, 773, 768, 3, 2, 2, 2, 773, 769,
	3, 2, 2, 2, 773, 770, 3, 2, 2, 2, 773, 771, 3, 2, 2, 2, 773, 772, 3, 2,
	2, 2, 774, 107, 3, 2, 2, 2, 775, 776, 5, 106, 54, 2, 776, 777, 7, 88, 2,
	2, 777, 779, 3, 2, 2, 2, 778, 775, 3, 2, 2, 2, 779, 782, 3, 2, 2, 2, 780,
	778, 3, 2, 2, 2, 780, 781, 3, 2, 2, 2, 781, 109, 3, 2, 2, 2, 782, 780,
	3, 2, 2, 2, 783, 784, 5, 108, 55, 2, 784, 785, 5, 292, 147, 2, 785, 111,
	3, 2, 2, 2, 786, 787, 5, 108, 55, 2, 787, 792, 5, 290, 146, 2, 788, 789,
	7, 88, 2, 2, 789, 791, 5, 290, 146, 2, 790, 788, 3, 2, 2, 2, 791, 794,
	3, 2, 2, 2, 792, 790, 3, 2, 2, 2, 792, 793, 3, 2, 2, 2, 793, 113, 3, 2,
	2, 2, 794, 792, 3, 2, 2, 2, 795, 801, 7, 58, 2, 2, 796, 801, 7, 59, 2,
	2, 797, 801, 5, 288, 145, 2, 798, 801, 7, 60, 2, 2, 799, 801, 7, 61, 2,
	2, 800, 795, 3, 2, 2, 2, 800, 796, 3, 2, 2, 2, 800, 797, 3, 2, 2, 2, 800,
	798, 3, 2, 2, 2, 800, 799, 3, 2, 2, 2, 801, 115, 3, 2, 2, 2, 802, 803,
	7, 4, 2, 2, 803, 808, 5, 118, 60, 2, 804, 805, 7, 6, 2, 2, 805, 807, 5,
	118, 60, 2, 806, 804, 3, 2, 2, 2, 807, 810, 3, 2, 2, 2, 808, 806, 3, 2,
	2, 2, 808, 809, 3, 2, 2, 2, 809, 811, 3, 2, 2, 2, 810, 808, 3, 2, 2, 2,
	811, 812, 7, 5, 2, 2, 812, 117, 3, 2, 2, 2, 813, 821, 5, 120, 61, 2, 814,
	816, 7, 82, 2, 2, 815, 817, 5, 230, 116, 2, 816, 815, 3, 2, 2, 2, 816,
	817, 3, 2, 2, 2, 817, 818, 3, 2, 2, 2, 818, 821, 7, 83, 2, 2, 819, 821,
	5, 132, 67, 2, 820, 813, 3, 2, 2, 2, 820, 814, 3, 2, 2, 2, 820, 819, 3,
	2, 2, 2, 821, 119, 3, 2, 2, 2, 822, 826, 5, 292, 147, 2, 823, 825, 7, 7,
	2, 2, 824, 823, 3, 2, 2, 2, 825, 828, 3, 2, 2, 2, 826, 824, 3, 2, 2, 2,
	826, 827, 3, 2, 2, 2, 827, 121, 3, 2, 2, 2, 828, 826, 3, 2, 2, 2, 829,
	830, 5, 126, 64, 2, 830, 831, 5, 300, 151, 2, 831, 832, 7, 77, 2, 2, 832,
	833, 5, 300, 151, 2, 833, 834, 5, 130, 66, 2, 834, 123, 3, 2, 2, 2, 835,
	836, 5, 128, 65, 2, 836, 837, 5, 300, 151, 2, 837, 838, 7, 77, 2, 2, 838,
	839, 5, 300, 151, 2, 839, 840, 5, 130, 66, 2, 840, 125, 3, 2, 2, 2, 841,
	842, 5, 94, 48, 2, 842, 127, 3, 2, 2, 2, 843, 846, 5, 94, 48, 2, 844, 846,
	5, 64, 33, 2, 845, 843, 3, 2, 2, 2, 845, 844, 3, 2, 2, 2, 846, 129, 3,
	2, 2, 2, 847, 850, 5, 158, 80, 2, 848, 850, 5, 230, 116, 2, 849, 847, 3,
	2, 2, 2, 849, 848, 3, 2, 2, 2, 850, 131, 3, 2, 2, 2, 851, 852, 7, 82, 2,
	2, 852, 860, 5, 300, 151, 2, 853, 855, 5, 96, 49, 2, 854, 853, 3, 2, 2,
	2, 854, 855, 3, 2, 2, 2, 855, 856, 3, 2, 2, 2, 856, 857, 5, 300, 151, 2,
	857, 858, 7, 77, 2, 2, 858, 859, 5, 300, 151, 2, 859, 861, 3, 2, 2, 2,
	860, 854, 3, 2, 2, 2, 860, 861, 3, 2, 2, 2, 861, 862, 3, 2, 2, 2, 862,
	863, 5, 136, 69, 2, 863, 864, 7, 83, 2, 2, 864, 133, 3, 2, 2, 2, 865, 868,
	5, 132, 67, 2, 866, 868, 5, 122, 62, 2, 867, 865, 3, 2, 2, 2, 867, 866,
	3, 2, 2, 2, 868, 135, 3, 2, 2, 2, 869, 871, 5, 138, 70, 2, 870, 869, 3,
	2, 2, 2, 870, 871, 3, 2, 2, 2, 871, 137, 3, 2, 2, 2, 872, 878, 5, 160,
	81, 2, 873, 874, 5, 302, 152, 2, 874, 875, 5, 160, 81, 2, 875, 877, 3,
	2, 2, 2, 876, 873, 3, 2, 2, 2, 877, 880, 3, 2, 2, 2, 878, 876, 3, 2, 2,
	2, 878, 879, 3, 2, 2, 2, 879, 882, 3, 2, 2, 2, 880, 878, 3, 2, 2, 2, 881,
	883, 5, 302, 152, 2, 882, 881, 3, 2, 2, 2, 882, 883, 3, 2, 2, 2, 883, 139,
	3, 2, 2, 2, 884, 885, 5, 142, 72, 2, 885, 886, 5, 300, 151, 2, 886, 888,
	3, 2, 2, 2, 887, 884, 3, 2, 2, 2, 888, 891, 3, 2, 2, 2, 889, 887, 3, 2,
	2, 2, 889, 890, 3, 2, 2, 2, 890, 141, 3, 2, 2, 2, 891, 889, 3, 2, 2, 2,
	892, 893, 7, 126, 2, 2, 893, 899, 5, 146, 74, 2, 894, 896, 7, 80, 2, 2,
	895, 897, 5, 144, 73, 2, 896, 895, 3, 2, 2, 2, 896, 897, 3, 2, 2, 2, 897,
	898, 3, 2, 2, 2, 898, 900, 5, 298, 150, 2, 899, 894, 3, 2, 2, 2, 899, 900,
	3, 2, 2, 2, 900, 143, 3, 2, 2, 2, 901, 904, 5, 148, 75, 2, 902, 904, 5,
	154, 78, 2, 903, 901, 3, 2, 2, 2, 903, 902, 3, 2, 2, 2, 904, 145, 3, 2,
	2, 2, 905, 906, 5, 110, 56, 2, 906, 147, 3, 2, 2, 2, 907, 912, 5, 150,
	76, 2, 908, 909, 7, 87, 2, 2, 909, 911, 5, 150, 76, 2, 910, 908, 3, 2,
	2, 2, 911, 914, 3, 2, 2, 2, 912, 910, 3, 2, 2, 2, 912, 913, 3, 2, 2, 2,
	913, 149, 3, 2, 2, 2, 914, 912, 3, 2, 2, 2, 915, 916, 5, 152, 77, 2, 916,
	917, 5, 300, 151, 2, 917, 918, 7, 89, 2, 2, 918, 919, 5, 300, 151, 2, 919,
	920, 5, 154, 78, 2, 920, 151, 3, 2, 2, 2, 921, 924, 5, 292, 147, 2, 922,
	924, 5, 296, 149, 2, 923, 921, 3, 2, 2, 2, 923, 922, 3, 2, 2, 2, 924, 153,
	3, 2, 2, 2, 925, 929, 5, 156, 79, 2, 926, 929, 5, 142, 72, 2, 927, 929,
	5, 234, 118, 2, 928, 925, 3, 2, 2, 2, 928, 926, 3, 2, 2, 2, 928, 927, 3,
	2, 2, 2, 929, 155, 3, 2, 2, 2, 930, 939, 7, 84, 2, 2, 931, 936, 5, 154,
	78, 2, 932, 933, 7, 87, 2, 2, 933, 935, 5, 154, 78, 2, 934, 932, 3, 2,
	2, 2, 935, 938, 3, 2, 2, 2, 936, 934, 3, 2, 2, 2, 936, 937, 3, 2, 2, 2,
	937, 940, 3, 2, 2, 2, 938, 936, 3, 2, 2, 2, 939, 931, 3, 2, 2, 2, 939,
	940, 3, 2, 2, 2, 940, 942, 3, 2, 2, 2, 941, 943, 7, 87, 2, 2, 942, 941,
	3, 2, 2, 2, 942, 943, 3, 2, 2, 2, 943, 944, 3, 2, 2, 2, 944, 945, 7, 85,
	2, 2, 945, 157, 3, 2, 2, 2, 946, 954, 7, 82, 2, 2, 947, 955, 5, 300, 151,
	2, 948, 950, 5, 302, 152, 2, 949, 948, 3, 2, 2, 2, 950, 953, 3, 2, 2, 2,
	951, 949, 3, 2, 2, 2, 951, 952, 3, 2, 2, 2, 952, 955, 3, 2, 2, 2, 953,
	951, 3, 2, 2, 2, 954, 947, 3, 2, 2, 2, 954, 951, 3, 2, 2, 2, 955, 956,
	3, 2, 2, 2, 956, 957, 5, 136, 69, 2, 957, 958, 7, 83, 2, 2, 958, 159, 3,
	2, 2, 2, 959, 962, 5, 162, 82, 2, 960, 962, 5, 190, 96, 2, 961, 959, 3,
	2, 2, 2, 961, 960, 3, 2, 2, 2, 962, 161, 3, 2, 2, 2, 963, 964, 6, 82, 9,
	2, 964, 965, 5, 166, 84, 2, 965, 163, 3, 2, 2, 2, 966, 967, 6, 83, 10,
	3, 967, 971, 5, 30, 16, 2, 968, 969, 6, 83, 11, 3, 969, 971, 5, 18, 10,
	2, 970, 966, 3, 2, 2, 2, 970, 968, 3, 2, 2, 2, 971, 165, 3, 2, 2, 2, 972,
	983, 5, 164, 83, 2, 973, 975, 5, 76, 39, 2, 974, 973, 3, 2, 2, 2, 974,
	975, 3, 2, 2, 2, 975, 976, 3, 2, 2, 2, 976, 984, 5, 60, 31, 2, 977, 978,
	5, 168, 85, 2, 978, 979, 5, 300, 151, 2, 979, 980, 7, 89, 2, 2, 980, 981,
	5, 300, 151, 2, 981, 982, 5, 66, 34, 2, 982, 984, 3, 2, 2, 2, 983, 974,
	3, 2, 2, 2, 983, 977, 3, 2, 2, 2, 984, 992, 3, 2, 2, 2, 985, 987, 5, 164,
	83, 2, 986, 985, 3, 2, 2, 2, 986, 987, 3, 2, 2, 2, 987, 988, 3, 2, 2, 2,
	988, 989, 5, 76, 39, 2, 989, 990, 5, 60, 31, 2, 990, 992, 3, 2, 2, 2, 991,
	972, 3, 2, 2, 2, 991, 986, 3, 2, 2, 2, 992, 167, 3, 2, 2, 2, 993, 994,
	7, 80, 2, 2, 994, 999, 5, 170, 86, 2, 995, 996, 7, 87, 2, 2, 996, 998,
	5, 170, 86, 2, 997, 995, 3, 2, 2, 2, 998, 1001, 3, 2, 2, 2, 999, 997, 3,
	2, 2, 2, 999, 1000, 3, 2, 2, 2, 1000, 1002, 3, 2, 2, 2, 1001, 999, 3, 2,
	2, 2, 1002, 1003, 5, 298, 150, 2, 1003, 169, 3, 2, 2, 2, 1004, 1006, 5,
	76, 39, 2, 1005, 1004, 3, 2, 2, 2, 1005, 1006, 3, 2, 2, 2, 1006, 1007,
	3, 2, 2, 2, 1007, 1008, 5, 64, 33, 2, 1008, 171, 3, 2, 2, 2, 1009, 1010,
	7, 80, 2, 2, 1010, 1013, 5, 64, 33, 2, 1011, 1012, 7, 87, 2, 2, 1012, 1014,
	5, 64, 33, 2, 1013, 1011, 3, 2, 2, 2, 1014, 1015, 3, 2, 2, 2, 1015, 1013,
	3, 2, 2, 2, 1015, 1016, 3, 2, 2, 2, 1016, 1017, 3, 2, 2, 2, 1017, 1018,
	5, 298, 150, 2, 1018, 173, 3, 2, 2, 2, 1019, 1022, 5, 176, 89, 2, 1020,
	1022, 5, 178, 90, 2, 1021, 1019, 3, 2, 2, 2, 1021, 1020, 3, 2, 2, 2, 1022,
	175, 3, 2, 2, 2, 1023, 1024, 7, 32, 2, 2, 1024, 1025, 5, 222, 112, 2, 1025,
	1026, 5, 300, 151, 2, 1026, 1035, 5, 190, 96, 2, 1027, 1030, 5, 300, 151,
	2, 1028, 1030, 5, 302, 152, 2, 1029, 1027, 3, 2, 2, 2, 1029, 1028, 3, 2,
	2, 2, 1030, 1031, 3, 2, 2, 2, 1031, 1032, 7, 26, 2, 2, 1032, 1033, 5, 300,
	151, 2, 1033, 1034, 5, 190, 96, 2, 1034, 1036, 3, 2, 2, 2, 1035, 1029,
	3, 2, 2, 2, 1035, 1036, 3, 2, 2, 2, 1036, 177, 3, 2, 2, 2, 1037, 1038,
	7, 48, 2, 2, 1038, 1039, 5, 222, 112, 2, 1039, 1040, 5, 300, 151, 2, 1040,
	1041, 7, 82, 2, 2, 1041, 1045, 5, 300, 151, 2, 1042, 1044, 5, 204, 103,
	2, 1043, 1042, 3, 2, 2, 2, 1044, 1047, 3, 2, 2, 2, 1045, 1043, 3, 2, 2,
	2, 1045, 1046, 3, 2, 2, 2, 1046, 1048, 3, 2, 2, 2, 1047, 1045, 3, 2, 2,
	2, 1048, 1049, 5, 300, 151, 2, 1049, 1050, 7, 83, 2, 2, 1050, 179, 3, 2,
	2, 2, 1051, 1052, 7, 31, 2, 2, 1052, 1053, 7, 80, 2, 2, 1053, 1054, 5,
	208, 105, 2, 1054, 1055, 5, 298, 150, 2, 1055, 1056, 5, 300, 151, 2, 1056,
	1057, 5, 190, 96, 2, 1057, 1071, 3, 2, 2, 2, 1058, 1059, 7, 57, 2, 2, 1059,
	1060, 5, 222, 112, 2, 1060, 1061, 5, 300, 151, 2, 1061, 1062, 5, 190, 96,
	2, 1062, 1071, 3, 2, 2, 2, 1063, 1064, 7, 25, 2, 2, 1064, 1065, 5, 300,
	151, 2, 1065, 1066, 5, 190, 96, 2, 1066, 1067, 5, 300, 151, 2, 1067, 1068,
	7, 57, 2, 2, 1068, 1069, 5, 222, 112, 2, 1069, 1071, 3, 2, 2, 2, 1070,
	1051, 3, 2, 2, 2, 1070, 1058, 3, 2, 2, 2, 1070, 1063, 3, 2, 2, 2, 1071,
	181, 3, 2, 2, 2, 1072, 1074, 7, 23, 2, 2, 1073, 1075, 5, 292, 147, 2, 1074,
	1073, 3, 2, 2, 2, 1074, 1075, 3, 2, 2, 2, 1075, 183, 3, 2, 2, 2, 1076,
	1078, 7, 18, 2, 2, 1077, 1079, 5, 292, 147, 2, 1078, 1077, 3, 2, 2, 2,
	1078, 1079, 3, 2, 2, 2, 1079, 185, 3, 2, 2, 2, 1080, 1082, 7, 54, 2, 2,
	1081, 1083, 5, 198, 100, 2, 1082, 1081, 3, 2, 2, 2, 1082, 1083, 3, 2, 2,
	2, 1083, 1084, 3, 2, 2, 2, 1084, 1085, 5, 300, 151, 2, 1085, 1091, 5, 158,
	80, 2, 1086, 1087, 5, 300, 151, 2, 1087, 1088, 5, 192, 97, 2, 1088, 1090,
	3, 2, 2, 2, 1089, 1086, 3, 2, 2, 2, 1090, 1093, 3, 2, 2, 2, 1091, 1089,
	3, 2, 2, 2, 1091, 1092, 3, 2, 2, 2, 1092, 1097, 3, 2, 2, 2, 1093, 1091,
	3, 2, 2, 2, 1094, 1095, 5, 300, 151, 2, 1095, 1096, 5, 196, 99, 2, 1096,
	1098, 3, 2, 2, 2, 1097, 1094, 3, 2, 2, 2, 1097, 1098, 3, 2, 2, 2, 1098,
	187, 3, 2, 2, 2, 1099, 1100, 7, 17, 2, 2, 1100, 1106, 5, 234, 118, 2, 1101,
	1102, 5, 300, 151, 2, 1102, 1103, 9, 6, 2, 2, 1103, 1104, 5, 300, 151,
	2, 1104, 1105, 5, 234, 118, 2, 1105, 1107, 3, 2, 2, 2, 1106, 1101, 3, 2,
	2, 2, 1106, 1107, 3, 2, 2, 2, 1107, 189, 3, 2, 2, 2, 1108, 1137, 5, 158,
	80, 2, 1109, 1137, 5, 174, 88, 2, 1110, 1137, 5, 180, 91, 2, 1111, 1137,
	5, 186, 94, 2, 1112, 1113, 7, 49, 2, 2, 1113, 1114, 5, 222, 112, 2, 1114,
	1115, 5, 300, 151, 2, 1115, 1116, 5, 158, 80, 2, 1116, 1137, 3, 2, 2, 2,
	1117, 1119, 7, 44, 2, 2, 1118, 1120, 5, 234, 118, 2, 1119, 1118, 3, 2,
	2, 2, 1119, 1120, 3, 2, 2, 2, 1120, 1137, 3, 2, 2, 2, 1121, 1122, 7, 51,
	2, 2, 1122, 1137, 5, 234, 118, 2, 1123, 1137, 5, 184, 93, 2, 1124, 1137,
	5, 182, 92, 2, 1125, 1126, 5, 292, 147, 2, 1126, 1127, 7, 95, 2, 2, 1127,
	1128, 5, 300, 151, 2, 1128, 1129, 5, 190, 96, 2, 1129, 1137, 3, 2, 2, 2,
	1130, 1137, 5, 188, 95, 2, 1131, 1137, 5, 162, 82, 2, 1132, 1133, 6, 96,
	12, 2, 1133, 1137, 5, 52, 27, 2, 1134, 1137, 5, 230, 116, 2, 1135, 1137,
	7, 86, 2, 2, 1136, 1108, 3, 2, 2, 2, 1136, 1109, 3, 2, 2, 2, 1136, 1110,
	3, 2, 2, 2, 1136, 1111, 3, 2, 2, 2, 1136, 1112, 3, 2, 2, 2, 1136, 1117,
	3, 2, 2, 2, 1136, 1121, 3, 2, 2, 2, 1136, 1123, 3, 2, 2, 2, 1136, 1124,
	3, 2, 2, 2, 1136, 1125, 3, 2, 2, 2, 1136, 1130, 3, 2, 2, 2, 1136, 1131,
	3, 2, 2, 2, 1136, 1132, 3, 2, 2, 2, 1136, 1134, 3, 2, 2, 2, 1136, 1135,
	3, 2, 2, 2, 1137, 191, 3, 2, 2, 2, 1138, 1139, 7, 20, 2, 2, 1139, 1140,
	7, 80, 2, 2, 1140, 1142, 5, 28, 15, 2, 1141, 1143, 5, 194, 98, 2, 1142,
	1141, 3, 2, 2, 2, 1142, 1143, 3, 2, 2, 2, 1143, 1144, 3, 2, 2, 2, 1144,
	1145, 5, 292, 147, 2, 1145, 1146, 5, 298, 150, 2, 1146, 1147, 5, 300, 151,
	2, 1147, 1148, 5, 158, 80, 2, 1148, 193, 3, 2, 2, 2, 1149, 1154, 5, 110,
	56, 2, 1150, 1151, 7, 109, 2, 2, 1151, 1153, 5, 110, 56, 2, 1152, 1150,
	3, 2, 2, 2, 1153, 1156, 3, 2, 2, 2, 1154, 1152, 3, 2, 2, 2, 1154, 1155,
	3, 2, 2, 2, 1155, 195, 3, 2, 2, 2, 1156, 1154, 3, 2, 2, 2, 1157, 1158,
	7, 30, 2, 2, 1158, 1159, 5, 300, 151, 2, 1159, 1160, 5, 158, 80, 2, 1160,
	197, 3, 2, 2, 2, 1161, 1162, 7, 80, 2, 2, 1162, 1163, 5, 300, 151, 2, 1163,
	1165, 5, 200, 101, 2, 1164, 1166, 5, 302, 152, 2, 1165, 1164, 3, 2, 2,
	2, 1165, 1166, 3, 2, 2, 2, 1166, 1167, 3, 2, 2, 2, 1167, 1168, 5, 298,
	150, 2, 1168, 199, 3, 2, 2, 2, 1169, 1175, 5, 202, 102, 2, 1170, 1171,
	5, 302, 152, 2, 1171, 1172, 5, 202, 102, 2, 1172, 1174, 3, 2, 2, 2, 1173,
	1170, 3, 2, 2, 2, 1174, 1177, 3, 2, 2, 2, 1175, 1173, 3, 2, 2, 2, 1175,
	1176, 3, 2, 2, 2, 1176, 201, 3, 2, 2, 2, 1177, 1175, 3, 2, 2, 2, 1178,
	1181, 5, 162, 82, 2, 1179, 1181, 5, 234, 118, 2, 1180, 1178, 3, 2, 2, 2,
	1180, 1179, 3, 2, 2, 2, 1181, 203, 3, 2, 2, 2, 1182, 1183, 5, 206, 104,
	2, 1183, 1184, 5, 300, 151, 2, 1184, 1186, 3, 2, 2, 2, 1185, 1182, 3, 2,
	2, 2, 1186, 1187, 3, 2, 2, 2, 1187, 1185, 3, 2, 2, 2, 1187, 1188, 3, 2,
	2, 2, 1188, 1189, 3, 2, 2, 2, 1189, 1190, 5, 138, 70, 2, 1190, 205, 3,
	2, 2, 2, 1191, 1192, 7, 19, 2, 2, 1192, 1193, 5, 234, 118, 2, 1193, 1194,
	7, 95, 2, 2, 1194, 1198, 3, 2, 2, 2, 1195, 1196, 7, 24, 2, 2, 1196, 1198,
	7, 95, 2, 2, 1197, 1191, 3, 2, 2, 2, 1197, 1195, 3, 2, 2, 2, 1198, 207,
	3, 2, 2, 2, 1199, 1202, 5, 210, 106, 2, 1200, 1202, 5, 212, 107, 2, 1201,
	1199, 3, 2, 2, 2, 1201, 1200, 3, 2, 2, 2, 1202, 209, 3, 2, 2, 2, 1203,
	1205, 5, 28, 15, 2, 1204, 1206, 5, 76, 39, 2, 1205, 1204, 3, 2, 2, 2, 1205,
	1206, 3, 2, 2, 2, 1206, 1207, 3, 2, 2, 2, 1207, 1208, 5, 64, 33, 2, 1208,
	1209, 9, 7, 2, 2, 1209, 1210, 5, 234, 118, 2, 1210, 211, 3, 2, 2, 2, 1211,
	1213, 5, 214, 108, 2, 1212, 1211, 3, 2, 2, 2, 1212, 1213, 3, 2, 2, 2, 1213,
	1214, 3, 2, 2, 2, 1214, 1216, 7, 86, 2, 2, 1215, 1217, 5, 234, 118, 2,
	1216, 1215, 3, 2, 2, 2, 1216, 1217, 3, 2, 2, 2, 1217, 1218, 3, 2, 2, 2,
	1218, 1220, 7, 86, 2, 2, 1219, 1221, 5, 216, 109, 2, 1220, 1219, 3, 2,
	2, 2, 1220, 1221, 3, 2, 2, 2, 1221, 213, 3, 2, 2, 2, 1222, 1225, 5, 162,
	82, 2, 1223, 1225, 5, 224, 113, 2, 1224, 1222, 3, 2, 2, 2, 1224, 1223,
	3, 2, 2, 2, 1225, 215, 3, 2, 2, 2, 1226, 1227, 5, 224, 113, 2, 1227, 217,
	3, 2, 2, 2, 1228, 1229, 7, 80, 2, 2, 1229, 1230, 5, 76, 39, 2, 1230, 1231,
	5, 298, 150, 2, 1231, 219, 3, 2, 2, 2, 1232, 1233, 5, 222, 112, 2, 1233,
	221, 3, 2, 2, 2, 1234, 1235, 7, 80, 2, 2, 1235, 1236, 5, 228, 115, 2, 1236,
	1237, 5, 298, 150, 2, 1237, 223, 3, 2, 2, 2, 1238, 1243, 5, 226, 114, 2,
	1239, 1240, 7, 87, 2, 2, 1240, 1242, 5, 226, 114, 2, 1241, 1239, 3, 2,
	2, 2, 1242, 1245, 3, 2, 2, 2, 1243, 1241, 3, 2, 2, 2, 1243, 1244, 3, 2,
	2, 2, 1244, 225, 3, 2, 2, 2, 1245, 1243, 3, 2, 2, 2, 1246, 1247, 7, 106,
	2, 2, 1247, 1250, 8, 114, 1, 2, 1248, 1250, 3, 2, 2, 2, 1249, 1246, 3,
	2, 2, 2, 1249, 1248, 3, 2, 2, 2, 1250, 1251, 3, 2, 2, 2, 1251, 1252, 5,
	234, 118, 2, 1252, 227, 3, 2, 2, 2, 1253, 1256, 5, 230, 116, 2, 1254, 1256,
	5, 124, 63, 2, 1255, 1253, 3, 2, 2, 2, 1255, 1254, 3, 2, 2, 2, 1256, 229,
	3, 2, 2, 2, 1257, 1258, 5, 238, 120, 2, 1258, 231, 3, 2, 2, 2, 1259, 1261,
	5, 242, 122, 2, 1260, 1262, 9, 8, 2, 2, 1261, 1260, 3, 2, 2, 2, 1261, 1262,
	3, 2, 2, 2, 1262, 233, 3, 2, 2, 2, 1263, 1264, 8, 118, 1, 2, 1264, 1265,
	5, 218, 110, 2, 1265, 1266, 5, 236, 119, 2, 1266, 1281, 3, 2, 2, 2, 1267,
	1281, 5, 232, 117, 2, 1268, 1269, 9, 9, 2, 2, 1269, 1270, 5, 300, 151,
	2, 1270, 1271, 5, 234, 118, 20, 1271, 1281, 3, 2, 2, 2, 1272, 1273, 9,
	10, 2, 2, 1273, 1281, 5, 234, 118, 18, 1274, 1275, 5, 172, 87, 2, 1275,
	1276, 5, 300, 151, 2, 1276, 1277, 7, 89, 2, 2, 1277, 1278, 5, 300, 151,
	2, 1278, 1279, 5, 230, 116, 2, 1279, 1281, 3, 2, 2, 2, 1280, 1263, 3, 2,
	2, 2, 1280, 1267, 3, 2, 2, 2, 1280, 1268, 3, 2, 2, 2, 1280, 1272, 3, 2,
	2, 2, 1280, 1274, 3, 2, 2, 2, 1281, 1392, 3, 2, 2, 2, 1282, 1283, 12, 19,
	2, 2, 1283, 1284, 7, 72, 2, 2, 1284, 1285, 5, 300, 151, 2, 1285, 1286,
	5, 234, 118, 20, 1286, 1391, 3, 2, 2, 2, 1287, 1288, 12, 17, 2, 2, 1288,
	1289, 5, 300, 151, 2, 1289, 1290, 9, 11, 2, 2, 1290, 1291, 5, 300, 151,
	2, 1291, 1292, 5, 234, 118, 18, 1292, 1391, 3, 2, 2, 2, 1293, 1294, 12,
	16, 2, 2, 1294, 1295, 9, 12, 2, 2, 1295, 1296, 5, 300, 151, 2, 1296, 1297,
	5, 234, 118, 17, 1297, 1391, 3, 2, 2, 2, 1298, 1299, 12, 15, 2, 2, 1299,
	1310, 5, 300, 151, 2, 1300, 1301, 7, 91, 2, 2, 1301, 1308, 7, 91, 2, 2,
	1302, 1303, 7, 90, 2, 2, 1303, 1304, 7, 90, 2, 2, 1304, 1308, 7, 90, 2,
	2, 1305, 1306, 7, 90, 2, 2, 1306, 1308, 7, 90, 2, 2, 1307, 1300, 3, 2,
	2, 2, 1307, 1302, 3, 2, 2, 2, 1307, 1305, 3, 2, 2, 2, 1308, 1311, 3, 2,
	2, 2, 1309, 1311, 9, 13, 2, 2, 1310, 1307, 3, 2, 2, 2, 1310, 1309, 3, 2,
	2, 2, 1311, 1312, 3, 2, 2, 2, 1312, 1313, 5, 300, 151, 2, 1313, 1314, 5,
	234, 118, 16, 1314, 1391, 3, 2, 2, 2, 1315, 1316, 12, 13, 2, 2, 1316, 1317,
	5, 300, 151, 2, 1317, 1318, 9, 14, 2, 2, 1318, 1319, 5, 300, 151, 2, 1319,
	1320, 5, 234, 118, 14, 1320, 1391, 3, 2, 2, 2, 1321, 1322, 12, 12, 2, 2,
	1322, 1323, 5, 300, 151, 2, 1323, 1324, 9, 15, 2, 2, 1324, 1325, 5, 300,
	151, 2, 1325, 1326, 5, 234, 118, 13, 1326, 1391, 3, 2, 2, 2, 1327, 1328,
	12, 11, 2, 2, 1328, 1329, 5, 300, 151, 2, 1329, 1330, 9, 16, 2, 2, 1330,
	1331, 5, 300, 151, 2, 1331, 1332, 5, 234, 118, 12, 1332, 1391, 3, 2, 2,
	2, 1333, 1334, 12, 10, 2, 2, 1334, 1335, 5, 300, 151, 2, 1335, 1336, 7,
	108, 2, 2, 1336, 1337, 5, 300, 151, 2, 1337, 1338, 5, 234, 118, 11, 1338,
	1391, 3, 2, 2, 2, 1339, 1340, 12, 9, 2, 2, 1340, 1341, 5, 300, 151, 2,
	1341, 1342, 7, 110, 2, 2, 1342, 1343, 5, 300, 151, 2, 1343, 1344, 5, 234,
	118, 10, 1344, 1391, 3, 2, 2, 2, 1345, 1346, 12, 8, 2, 2, 1346, 1347, 5,
	300, 151, 2, 1347, 1348, 7, 109, 2, 2, 1348, 1349, 5, 300, 151, 2, 1349,
	1350, 5, 234, 118, 9, 1350, 1391, 3, 2, 2, 2, 1351, 1352, 12, 7, 2, 2,
	1352, 1353, 5, 300, 151, 2, 1353, 1354, 7, 100, 2, 2, 1354, 1355, 5, 300,
	151, 2, 1355, 1356, 5, 234, 118, 8, 1356, 1391, 3, 2, 2, 2, 1357, 1358,
	12, 6, 2, 2, 1358, 1359, 5, 300, 151, 2, 1359, 1360, 7, 101, 2, 2, 1360,
	1361, 5, 300, 151, 2, 1361, 1362, 5, 234, 118, 7, 1362, 1391, 3, 2, 2,
	2, 1363, 1364, 12, 5, 2, 2, 1364, 1374, 5, 300, 151, 2, 1365, 1366, 7,
	94, 2, 2, 1366, 1367, 5, 300, 151, 2, 1367, 1368, 5, 234, 118, 2, 1368,
	1369, 5, 300, 151, 2, 1369, 1370, 7, 95, 2, 2, 1370, 1371, 5, 300, 151,
	2, 1371, 1375, 3, 2, 2, 2, 1372, 1373, 7, 67, 2, 2, 1373, 1375, 5, 300,
	151, 2, 1374, 1365, 3, 2, 2, 2, 1374, 1372, 3, 2, 2, 2, 1375, 1376, 3,
	2, 2, 2, 1376, 1377, 5, 234, 118, 5, 1377, 1391, 3, 2, 2, 2, 1378, 1379,
	12, 14, 2, 2, 1379, 1380, 5, 300, 151, 2, 1380, 1381, 9, 17, 2, 2, 1381,
	1382, 5, 300, 151, 2, 1382, 1383, 5, 76, 39, 2, 1383, 1391, 3, 2, 2, 2,
	1384, 1385, 12, 3, 2, 2, 1385, 1386, 5, 300, 151, 2, 1386, 1387, 9, 18,
	2, 2, 1387, 1388, 5, 300, 151, 2, 1388, 1389, 5, 228, 115, 2, 1389, 1391,
	3, 2, 2, 2, 1390, 1282, 3, 2, 2, 2, 1390, 1287, 3, 2, 2, 2, 1390, 1293,
	3, 2, 2, 2, 1390, 1298, 3, 2, 2, 2, 1390, 1315, 3, 2, 2, 2, 1390, 1321,
	3, 2, 2, 2, 1390, 1327, 3, 2, 2, 2, 1390, 1333, 3, 2, 2, 2, 1390, 1339,
	3, 2, 2, 2, 1390, 1345, 3, 2, 2, 2, 1390, 1351, 3, 2, 2, 2, 1390, 1357,
	3, 2, 2, 2, 1390, 1363, 3, 2, 2, 2, 1390, 1378, 3, 2, 2, 2, 1390, 1384,
	3, 2, 2, 2, 1391, 1394, 3, 2, 2, 2, 1392, 1390, 3, 2, 2, 2, 1392, 1393,
	3, 2, 2, 2, 1393, 235, 3, 2, 2, 2, 1394, 1392, 3, 2, 2, 2, 1395, 1396,
	5, 218, 110, 2, 1396, 1397, 5, 236, 119, 2, 1397, 1406, 3, 2, 2, 2, 1398,
	1406, 5, 232, 117, 2, 1399, 1400, 9, 9, 2, 2, 1400, 1401, 5, 300, 151,
	2, 1401, 1402, 5, 236, 119, 2, 1402, 1406, 3, 2, 2, 2, 1403, 1404, 9, 10,
	2, 2, 1404, 1406, 5, 236, 119, 2, 1405, 1395, 3, 2, 2, 2, 1405, 1398, 3,
	2, 2, 2, 1405, 1399, 3, 2, 2, 2, 1405, 1403, 3, 2, 2, 2, 1406, 237, 3,
	2, 2, 2, 1407, 1411, 5, 234, 118, 2, 1408, 1409, 6, 120, 28, 3, 1409, 1412,
	5, 280, 141, 2, 1410, 1412, 3, 2, 2, 2, 1411, 1408, 3, 2, 2, 2, 1411, 1410,
	3, 2, 2, 2, 1412, 1416, 3, 2, 2, 2, 1413, 1415, 5, 240, 121, 2, 1414, 1413,
	3, 2, 2, 2, 1415, 1418, 3, 2, 2, 2, 1416, 1414, 3, 2, 2, 2, 1416, 1417,
	3, 2, 2, 2, 1417, 239, 3, 2, 2, 2, 1418, 1416, 3, 2, 2, 2, 1419, 1426,
	5, 254, 128, 2, 1420, 1422, 5, 244, 123, 2, 1421, 1420, 3, 2, 2, 2, 1422,
	1423, 3, 2, 2, 2, 1423, 1421, 3, 2, 2, 2, 1423, 1424, 3, 2, 2, 2, 1424,
	1427, 3, 2, 2, 2, 1425, 1427, 5, 280, 141, 2, 1426, 1421, 3, 2, 2, 2, 1426,
	1425, 3, 2, 2, 2, 1426, 1427, 3, 2, 2, 2, 1427, 241, 3, 2, 2, 2, 1428,
	1434, 5, 254, 128, 2, 1429, 1430, 5, 244, 123, 2, 1430, 1431, 8, 122, 1,
	2, 1431, 1433, 3, 2, 2, 2, 1432, 1429, 3, 2, 2, 2, 1433, 1436, 3, 2, 2,
	2, 1434, 1432, 3, 2, 2, 2, 1434, 1435, 3, 2, 2, 2, 1435, 243, 3, 2, 2,
	2, 1436, 1434, 3, 2, 2, 2, 1437, 1448, 5, 300, 151, 2, 1438, 1439, 9, 19,
	2, 2, 1439, 1442, 5, 300, 151, 2, 1440, 1443, 7, 126, 2, 2, 1441, 1443,
	5, 274, 138, 2, 1442, 1440, 3, 2, 2, 2, 1442, 1441, 3, 2, 2, 2, 1442, 1443,
	3, 2, 2, 2, 1443, 1449, 3, 2, 2, 2, 1444, 1445, 7, 68, 2, 2, 1445, 1449,
	5, 300, 151, 2, 1446, 1447, 7, 69, 2, 2, 1447, 1449, 5, 300, 151, 2, 1448,
	1438, 3, 2, 2, 2, 1448, 1444, 3, 2, 2, 2, 1448, 1446, 3, 2, 2, 2, 1449,
	1450, 3, 2, 2, 2, 1450, 1451, 5, 246, 124, 2, 1451, 1452, 8, 123, 1, 2,
	1452, 1474, 3, 2, 2, 2, 1453, 1454, 5, 300, 151, 2, 1454, 1455, 7, 88,
	2, 2, 1455, 1456, 5, 300, 151, 2, 1456, 1457, 7, 39, 2, 2, 1457, 1458,
	5, 266, 134, 2, 1458, 1459, 8, 123, 1, 2, 1459, 1474, 3, 2, 2, 2, 1460,
	1461, 5, 278, 140, 2, 1461, 1462, 8, 123, 1, 2, 1462, 1474, 3, 2, 2, 2,
	1463, 1464, 5, 300, 151, 2, 1464, 1465, 5, 134, 68, 2, 1465, 1466, 8, 123,
	1, 2, 1466, 1474, 3, 2, 2, 2, 1467, 1468, 5, 250, 126, 2, 1468, 1469, 8,
	123, 1, 2, 1469, 1474, 3, 2, 2, 2, 1470, 1471, 5, 252, 127, 2, 1471, 1472,
	8, 123, 1, 2, 1472, 1474, 3, 2, 2, 2, 1473, 1437, 3, 2, 2, 2, 1473, 1453,
	3, 2, 2, 2, 1473, 1460, 3, 2, 2, 2, 1473, 1463, 3, 2, 2, 2, 1473, 1467,
	3, 2, 2, 2, 1473, 1470, 3, 2, 2, 2, 1474, 245, 3, 2, 2, 2, 1475, 1480,
	5, 292, 147, 2, 1476, 1480, 5, 288, 145, 2, 1477, 1480, 5, 248, 125, 2,
	1478, 1480, 5, 296, 149, 2, 1479, 1475, 3, 2, 2, 2, 1479, 1476, 3, 2, 2,
	2, 1479, 1477, 3, 2, 2, 2, 1479, 1478, 3, 2, 2, 2, 1480, 247, 3, 2, 2,
	2, 1481, 1484, 5, 220, 111, 2, 1482, 1484, 5, 116, 59, 2, 1483, 1481, 3,
	2, 2, 2, 1483, 1482, 3, 2, 2, 2, 1484, 249, 3, 2, 2, 2, 1485, 1487, 7,
	94, 2, 2, 1486, 1485, 3, 2, 2, 2, 1486, 1487, 3, 2, 2, 2, 1487, 1488, 3,
	2, 2, 2, 1488, 1490, 7, 84, 2, 2, 1489, 1491, 5, 224, 113, 2, 1490, 1489,
	3, 2, 2, 2, 1490, 1491, 3, 2, 2, 2, 1491, 1492, 3, 2, 2, 2, 1492, 1493,
	7, 85, 2, 2, 1493, 251, 3, 2, 2, 2, 1494, 1496, 7, 94, 2, 2, 1495, 1494,
	3, 2, 2, 2, 1495, 1496, 3, 2, 2, 2, 1496, 1497, 3, 2, 2, 2, 1497, 1500,
	7, 84, 2, 2, 1498, 1501, 5, 260, 131, 2, 1499, 1501, 7, 95, 2, 2, 1500,
	1498, 3, 2, 2, 2, 1500, 1499, 3, 2, 2, 2, 1501, 1502, 3, 2, 2, 2, 1502,
	1503, 7, 85, 2, 2, 1503, 253, 3, 2, 2, 2, 1504, 1506, 5, 292, 147, 2, 1505,
	1507, 5, 86, 44, 2, 1506, 1505, 3, 2, 2, 2, 1506, 1507, 3, 2, 2, 2, 1507,
	1522, 3, 2, 2, 2, 1508, 1522, 5, 114, 58, 2, 1509, 1522, 5, 116, 59, 2,
	1510, 1511, 7, 39, 2, 2, 1511, 1512, 5, 300, 151, 2, 1512, 1513, 5, 266,
	134, 2, 1513, 1522, 3, 2, 2, 2, 1514, 1522, 7, 50, 2, 2, 1515, 1522, 7,
	47, 2, 2, 1516, 1522, 5, 220, 111, 2, 1517, 1522, 5, 134, 68, 2, 1518,
	1522, 5, 256, 129, 2, 1519, 1522, 5, 258, 130, 2, 1520, 1522, 5, 294, 148,
	2, 1521, 1504, 3, 2, 2, 2, 1521, 1508, 3, 2, 2, 2, 1521, 1509, 3, 2, 2,
	2, 1521, 1510, 3, 2, 2, 2, 1521, 1514, 3, 2, 2, 2, 1521, 1515, 3, 2, 2,
	2, 1521, 1516, 3, 2, 2, 2, 1521, 1517, 3, 2, 2, 2, 1521, 1518, 3, 2, 2,
	2, 1521, 1519, 3, 2, 2, 2, 1521, 1520, 3, 2, 2, 2, 1522, 255, 3, 2, 2,
	2, 1523, 1525, 7, 84, 2, 2, 1524, 1526, 5, 224, 113, 2, 1525, 1524, 3,
	2, 2, 2, 1525, 1526, 3, 2, 2, 2, 1526, 1528, 3, 2, 2, 2, 1527, 1529, 7,
	87, 2, 2, 1528, 1527, 3, 2, 2, 2, 1528, 1529, 3, 2, 2, 2, 1529, 1530, 3,
	2, 2, 2, 1530, 1531, 7, 85, 2, 2, 1531, 257, 3, 2, 2, 2, 1532, 1538, 7,
	84, 2, 2, 1533, 1535, 5, 260, 131, 2, 1534, 1536, 7, 87, 2, 2, 1535, 1534,
	3, 2, 2, 2, 1535, 1536, 3, 2, 2, 2, 1536, 1539, 3, 2, 2, 2, 1537, 1539,
	7, 95, 2, 2, 1538, 1533, 3, 2, 2, 2, 1538, 1537, 3, 2, 2, 2, 1539, 1540,
	3, 2, 2, 2, 1540, 1541, 7, 85, 2, 2, 1541, 259, 3, 2, 2, 2, 1542, 1547,
	5, 262, 132, 2, 1543, 1544, 7, 87, 2, 2, 1544, 1546, 5, 262, 132, 2, 1545,
	1543, 3, 2, 2, 2, 1546, 1549, 3, 2, 2, 2, 1547, 1545, 3, 2, 2, 2, 1547,
	1548, 3, 2, 2, 2, 1548, 261, 3, 2, 2, 2, 1549, 1547, 3, 2, 2, 2, 1550,
	1551, 5, 264, 133, 2, 1551, 1552, 7, 95, 2, 2, 1552, 1553, 5, 300, 151,
	2, 1553, 1554, 5, 234, 118, 2, 1554, 1561, 3, 2, 2, 2, 1555, 1556, 7, 106,
	2, 2, 1556, 1557, 7, 95, 2, 2, 1557, 1558, 5, 300, 151, 2, 1558, 1559,
	5, 234, 118, 2, 1559, 1561, 3, 2, 2, 2, 1560, 1550, 3, 2, 2, 2, 1560, 1555,
	3, 2, 2, 2, 1561, 263, 3, 2, 2, 2, 1562, 1565, 5, 296, 149, 2, 1563, 1565,
	5, 254, 128, 2, 1564, 1562, 3, 2, 2, 2, 1564, 1563, 3, 2, 2, 2, 1565, 265,
	3, 2, 2, 2, 1566, 1590, 5, 272, 137, 2, 1567, 1568, 6, 134, 29, 3, 1568,
	1569, 5, 300, 151, 2, 1569, 1571, 5, 278, 140, 2, 1570, 1572, 5, 270, 136,
	2, 1571, 1570, 3, 2, 2, 2, 1571, 1572, 3, 2, 2, 2, 1572, 1591, 3, 2, 2,
	2, 1573, 1579, 6, 134, 30, 3, 1574, 1575, 5, 140, 71, 2, 1575, 1576, 7,
	84, 2, 2, 1576, 1577, 5, 234, 118, 2, 1577, 1578, 7, 85, 2, 2, 1578, 1580,
	3, 2, 2, 2, 1579, 1574, 3, 2, 2, 2, 1580, 1581, 3, 2, 2, 2, 1581, 1579,
	3, 2, 2, 2, 1581, 1582, 3, 2, 2, 2, 1582, 1583, 3, 2, 2, 2, 1583, 1584,
	5, 72, 37, 2, 1584, 1591, 3, 2, 2, 2, 1585, 1586, 6, 134, 31, 3, 1586,
	1587, 5, 70, 36, 2, 1587, 1588, 5, 300, 151, 2, 1588, 1589, 5, 268, 135,
	2, 1589, 1591, 3, 2, 2, 2, 1590, 1567, 3, 2, 2, 2, 1590, 1573, 3, 2, 2,
	2, 1590, 1585, 3, 2, 2, 2, 1591, 267, 3, 2, 2, 2, 1592, 1593, 7, 82, 2,
	2, 1593, 1595, 5, 300, 151, 2, 1594, 1596, 5, 68, 35, 2, 1595, 1594, 3,
	2, 2, 2, 1595, 1596, 3, 2, 2, 2, 1596, 1597, 3, 2, 2, 2, 1597, 1598, 5,
	300, 151, 2, 1598, 1599, 7, 83, 2, 2, 1599, 269, 3, 2, 2, 2, 1600, 1601,
	5, 42, 22, 2, 1601, 271, 3, 2, 2, 2, 1602, 1608, 5, 140, 71, 2, 1603, 1609,
	5, 84, 43, 2, 1604, 1606, 5, 110, 56, 2, 1605, 1607, 5, 276, 139, 2, 1606,
	1605, 3, 2, 2, 2, 1606, 1607, 3, 2, 2, 2, 1607, 1609, 3, 2, 2, 2, 1608,
	1603, 3, 2, 2, 2, 1608, 1604, 3, 2, 2, 2, 1609, 273, 3, 2, 2, 2, 1610,
	1611, 7, 91, 2, 2, 1611, 1612, 5, 300, 151, 2, 1612, 1613, 5, 38, 20, 2,
	1613, 1614, 5, 300, 151, 2, 1614, 1615, 7, 90, 2, 2, 1615, 275, 3, 2, 2,
	2, 1616, 1617, 7, 91, 2, 2, 1617, 1620, 7, 90, 2, 2, 1618, 1620, 5, 86,
	44, 2, 1619, 1616, 3, 2, 2, 2, 1619, 1618, 3, 2, 2, 2, 1620, 277, 3, 2,
	2, 2, 1621, 1623, 7, 80, 2, 2, 1622, 1624, 5, 282, 142, 2, 1623, 1622,
	3, 2, 2, 2, 1623, 1624, 3, 2, 2, 2, 1624, 1626, 3, 2, 2, 2, 1625, 1627,
	7, 87, 2, 2, 1626, 1625, 3, 2, 2, 2, 1626, 1627, 3, 2, 2, 2, 1627, 1628,
	3, 2, 2, 2, 1628, 1629, 5, 298, 150, 2, 1629, 279, 3, 2, 2, 2, 1630, 1637,
	5, 284, 143, 2, 1631, 1632, 7, 87, 2, 2, 1632, 1633, 5, 300, 151, 2, 1633,
	1634, 5, 284, 143, 2, 1634, 1636, 3, 2, 2, 2, 1635, 1631, 3, 2, 2, 2, 1636,
	1639, 3, 2, 2, 2, 1637, 1635, 3, 2, 2, 2, 1637, 1638, 3, 2, 2, 2, 1638,
	281, 3, 2, 2, 2, 1639, 1637, 3, 2, 2, 2, 1640, 1647, 5, 286, 144, 2, 1641,
	1642, 7, 87, 2, 2, 1642, 1643, 5, 300, 151, 2, 1643, 1644, 5, 286, 144,
	2, 1644, 1646, 3, 2, 2, 2, 1645, 1641, 3, 2, 2, 2, 1646, 1649, 3, 2, 2,
	2, 1647, 1645, 3, 2, 2, 2, 1647, 1648, 3, 2, 2, 2, 1648, 283, 3, 2, 2,
	2, 1649, 1647, 3, 2, 2, 2, 1650, 1653, 5, 226, 114, 2, 1651, 1653, 5, 262,
	132, 2, 1652, 1650, 3, 2, 2, 2, 1652, 1651, 3, 2, 2, 2, 1653, 285, 3, 2,
	2, 2, 1654, 1658, 5, 226, 114, 2, 1655, 1658, 5, 124, 63, 2, 1656, 1658,
	5, 262, 132, 2, 1657, 1654, 3, 2, 2, 2, 1657, 1655, 3, 2, 2, 2, 1657, 1656,
	3, 2, 2, 2, 1658, 287, 3, 2, 2, 2, 1659, 1660, 7, 3, 2, 2, 1660, 289, 3,
	2, 2, 2, 1661, 1662, 7, 124, 2, 2, 1662, 291, 3, 2, 2, 2, 1663, 1672, 7,
	125, 2, 2, 1664, 1672, 7, 124, 2, 2, 1665, 1672, 7, 14, 2, 2, 1666, 1667,
	6, 147, 32, 2, 1667, 1672, 7, 45, 2, 2, 1668, 1672, 7, 11, 2, 2, 1669,
	1672, 7, 12, 2, 2, 1670, 1672, 7, 9, 2, 2, 1671, 1663, 3, 2, 2, 2, 1671,
	1664, 3, 2, 2, 2, 1671, 1665, 3, 2, 2, 2, 1671, 1666, 3, 2, 2, 2, 1671,
	1668, 3, 2, 2, 2, 1671, 1669, 3, 2, 2, 2, 1671, 1670, 3, 2, 2, 2, 1672,
	293, 3, 2, 2, 2, 1673, 1674, 9, 20, 2, 2, 1674, 295, 3, 2, 2, 2, 1675,
	1676, 9, 21, 2, 2, 1676, 297, 3, 2, 2, 2, 1677, 1680, 7, 81, 2, 2, 1678,
	1680, 8, 150, 1, 2, 1679, 1677, 3, 2, 2, 2, 1679, 1678, 3, 2, 2, 2, 1680,
	299, 3, 2, 2, 2, 1681, 1683, 7, 129, 2, 2, 1682, 1681, 3, 2, 2, 2, 1683,
	1686, 3, 2, 2, 2, 1684, 1682, 3, 2, 2, 2, 1684, 1685, 3, 2, 2, 2, 1685,
	301, 3, 2, 2, 2, 1686, 1684, 3, 2, 2, 2, 1687, 1689, 9, 22, 2, 2, 1688,
	1687, 3, 2, 2, 2, 1689, 1690, 3, 2, 2, 2, 1690, 1688, 3, 2, 2, 2, 1690,
	1691, 3, 2, 2, 2, 1691, 303, 3, 2, 2, 2, 190, 306, 309, 312, 322, 326,
	331, 340, 347, 354, 357, 364, 367, 374, 378, 382, 385, 392, 403, 414, 423,
	433, 447, 453, 462, 466, 469, 477, 480, 483, 491, 494, 497, 500, 507, 511,
	523, 529, 534, 537, 542, 546, 553, 564, 568, 571, 580, 584, 586, 590, 595,
	606, 615, 630, 635, 643, 646, 651, 658, 661, 667, 670, 674, 678, 691, 704,
	706, 718, 723, 729, 737, 745, 748, 756, 765, 773, 780, 792, 800, 808, 816,
	820, 826, 845, 849, 854, 860, 867, 870, 878, 882, 889, 896, 899, 903, 912,
	923, 928, 936, 939, 942, 951, 954, 961, 970, 974, 983, 986, 991, 999, 1005,
	1015, 1021, 1029, 1035, 1045, 1070, 1074, 1078, 1082, 1091, 1097, 1106,
	1119, 1136, 1142, 1154, 1165, 1175, 1180, 1187, 1197, 1201, 1205, 1212,
	1216, 1220, 1224, 1243, 1249, 1255, 1261, 1280, 1307, 1310, 1374, 1390,
	1392, 1405, 1411, 1416, 1423, 1426, 1434, 1442, 1448, 1473, 1479, 1483,
	1486, 1490, 1495, 1500, 1506, 1521, 1525, 1528, 1535, 1538, 1547, 1560,
	1564, 1571, 1581, 1590, 1595, 1606, 1608, 1619, 1623, 1626, 1637, 1647,
	1652, 1657, 1671, 1679, 1684, 1690,
}
var deserializer = antlr.NewATNDeserializer(nil)
var deserializedATN = deserializer.DeserializeFromUInt16(parserATN)

var literalNames = []string{
	"", "", "", "", "", "", "", "'as'", "'def'", "'in'", "'trait'", "'threadsafe'",
	"'var'", "", "'abstract'", "'assert'", "'break'", "'case'", "'catch'",
	"'class'", "'const'", "'continue'", "'default'", "'do'", "'else'", "'enum'",
	"'extends'", "'final'", "'finally'", "'for'", "'if'", "'goto'", "'implements'",
	"'import'", "'instanceof'", "'interface'", "'native'", "'new'", "'package'",
	"'private'", "'protected'", "'public'", "'return'", "'static'", "'strictfp'",
	"'super'", "'switch'", "'synchronized'", "'this'", "'throw'", "'throws'",
	"'transient'", "'try'", "'void'", "'volatile'", "'while'", "", "", "",
	"'null'", "'..'", "'..<'", "'*.'", "'?.'", "'??.'", "'?:'", "'.&'", "'::'",
	"'=~'", "'==~'", "'**'", "'**='", "'<=>'", "'==='", "'!=='", "'->'", "'!instanceof'",
	"'!in'", "", "", "", "", "", "", "';'", "','", "", "'='", "'>'", "'<'",
	"'!'", "'~'", "'?'", "':'", "'=='", "'<='", "'>='", "'!='", "'&&'", "'||'",
	"'++'", "'--'", "'+'", "'-'", "'*'", "", "'&'", "'|'", "'^'", "'%'", "'+='",
	"'-='", "'*='", "'/='", "'&='", "'|='", "'^='", "'%='", "'<<='", "'>>='",
	"'>>>='", "'?='", "", "", "'@'", "'...'",
}
var symbolicNames = []string{
	"", "StringLiteral", "GStringBegin", "GStringEnd", "GStringPart", "GStringPathPart",
	"RollBackOne", "AS", "DEF", "IN", "TRAIT", "THREADSAFE", "VAR", "BuiltInPrimitiveType",
	"ABSTRACT", "ASSERT", "BREAK", "CASE", "CATCH", "CLASS", "CONST", "CONTINUE",
	"DEFAULT", "DO", "ELSE", "ENUM", "EXTENDS", "FINAL", "FINALLY", "FOR",
	"IF", "GOTO", "IMPLEMENTS", "IMPORT", "INSTANCEOF", "INTERFACE", "NATIVE",
	"NEW", "PACKAGE", "PRIVATE", "PROTECTED", "PUBLIC", "RETURN", "STATIC",
	"STRICTFP", "SUPER", "SWITCH", "SYNCHRONIZED", "THIS", "THROW", "THROWS",
	"TRANSIENT", "TRY", "VOID", "VOLATILE", "WHILE", "IntegerLiteral", "FloatingPointLiteral",
	"BooleanLiteral", "NullLiteral", "RANGE_INCLUSIVE", "RANGE_EXCLUSIVE",
	"SPREAD_DOT", "SAFE_DOT", "SAFE_CHAIN_DOT", "ELVIS", "METHOD_POINTER",
	"METHOD_REFERENCE", "REGEX_FIND", "REGEX_MATCH", "POWER", "POWER_ASSIGN",
	"SPACESHIP", "IDENTICAL", "NOT_IDENTICAL", "ARROW", "NOT_INSTANCEOF", "NOT_IN",
	"LPAREN", "RPAREN", "LBRACE", "RBRACE", "LBRACK", "RBRACK", "SEMI", "COMMA",
	"DOT", "ASSIGN", "GT", "LT", "NOT", "BITNOT", "QUESTION", "COLON", "EQUAL",
	"LE", "GE", "NOTEQUAL", "AND", "OR", "INC", "DEC", "ADD", "SUB", "MUL",
	"DIV", "BITAND", "BITOR", "XOR", "MOD", "ADD_ASSIGN", "SUB_ASSIGN", "MUL_ASSIGN",
	"DIV_ASSIGN", "AND_ASSIGN", "OR_ASSIGN", "XOR_ASSIGN", "MOD_ASSIGN", "LSHIFT_ASSIGN",
	"RSHIFT_ASSIGN", "URSHIFT_ASSIGN", "ELVIS_ASSIGN", "CapitalizedIdentifier",
	"Identifier", "AT", "ELLIPSIS", "WS", "NL", "SH_COMMENT", "UNEXPECTED_CHAR",
}

var ruleNames = []string{
	"compilationUnit", "scriptStatements", "scriptStatement", "packageDeclaration",
	"importDeclaration", "typeDeclaration", "modifier", "modifiersOpt", "modifiers",
	"classOrInterfaceModifiersOpt", "classOrInterfaceModifiers", "classOrInterfaceModifier",
	"variableModifier", "variableModifiersOpt", "variableModifiers", "typeParameters",
	"typeParameter", "typeBound", "typeList", "classDeclaration", "classBody",
	"enumConstants", "enumConstant", "classBodyDeclaration", "memberDeclaration",
	"methodDeclaration", "methodName", "returnType", "fieldDeclaration", "variableDeclarators",
	"variableDeclarator", "variableDeclaratorId", "variableInitializer", "variableInitializers",
	"dims", "dimsOpt", "standardType", "typeType", "classOrInterfaceType",
	"generalClassOrInterfaceType", "standardClassOrInterfaceType", "primitiveType",
	"typeArguments", "typeArgument", "annotatedQualifiedClassName", "qualifiedClassNameList",
	"formalParameters", "formalParameterList", "thisFormalParameter", "formalParameter",
	"methodBody", "qualifiedName", "qualifiedNameElement", "qualifiedNameElements",
	"qualifiedClassName", "qualifiedStandardClassName", "literal", "gstring",
	"gstringValue", "gstringPath", "lambdaExpression", "standardLambdaExpression",
	"lambdaParameters", "standardLambdaParameters", "lambdaBody", "closure",
	"closureOrLambdaExpression", "blockStatementsOpt", "blockStatements", "annotationsOpt",
	"annotation", "elementValues", "annotationName", "elementValuePairs", "elementValuePair",
	"elementValuePairName", "elementValue", "elementValueArrayInitializer",
	"block", "blockStatement", "localVariableDeclaration", "classifiedModifiers",
	"variableDeclaration", "typeNamePairs", "typeNamePair", "variableNames",
	"conditionalStatement", "ifElseStatement", "switchStatement", "loopStatement",
	"continueStatement", "breakStatement", "tryCatchStatement", "assertStatement",
	"statement", "catchClause", "catchType", "finallyBlock", "resources", "resourceList",
	"resource", "switchBlockStatementGroup", "switchLabel", "forControl", "enhancedForControl",
	"classicalForControl", "forInit", "forUpdate", "castParExpression", "parExpression",
	"expressionInPar", "expressionList", "expressionListElement", "enhancedStatementExpression",
	"statementExpression", "postfixExpression", "expression", "castOperandExpression",
	"commandExpression", "commandArgument", "pathExpression", "pathElement",
	"namePart", "dynamicMemberName", "indexPropertyArgs", "namedPropertyArgs",
	"primary", "list", "normalMap", "mapEntryList", "mapEntry", "mapEntryLabel",
	"creator", "arrayInitializer", "anonymousInnerClassDeclaration", "createdName",
	"nonWildcardTypeArguments", "typeArgumentsOrDiamond", "arguments", "argumentList",
	"enhancedArgumentList", "argumentListElement", "enhancedArgumentListElement",
	"stringLiteral", "className", "identifier", "builtInType", "keywords",
	"rparen", "nls", "sep",
}
var decisionToDFA = make([]*antlr.DFA, len(deserializedATN.DecisionToState))

func init() {
	for index, ds := range deserializedATN.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(ds, index)
	}
}

type GroovyParser struct {
	AbstractParser
}

func NewGroovyParser(input antlr.TokenStream) *GroovyParser {
	this := new(GroovyParser)

	this.BaseParser = antlr.NewBaseParser(input)

	this.Interpreter = antlr.NewParserATNSimulator(this, deserializedATN, decisionToDFA, antlr.NewPredictionContextCache())
	this.RuleNames = ruleNames
	this.LiteralNames = literalNames
	this.SymbolicNames = symbolicNames
	this.GrammarFileName = "GroovyParser.g4"

	return this
}

// GroovyParser tokens.
const (
	GroovyParserEOF                   = antlr.TokenEOF
	GroovyParserStringLiteral         = 1
	GroovyParserGStringBegin          = 2
	GroovyParserGStringEnd            = 3
	GroovyParserGStringPart           = 4
	GroovyParserGStringPathPart       = 5
	GroovyParserRollBackOne           = 6
	GroovyParserAS                    = 7
	GroovyParserDEF                   = 8
	GroovyParserIN                    = 9
	GroovyParserTRAIT                 = 10
	GroovyParserTHREADSAFE            = 11
	GroovyParserVAR                   = 12
	GroovyParserBuiltInPrimitiveType  = 13
	GroovyParserABSTRACT              = 14
	GroovyParserASSERT                = 15
	GroovyParserBREAK                 = 16
	GroovyParserCASE                  = 17
	GroovyParserCATCH                 = 18
	GroovyParserCLASS                 = 19
	GroovyParserCONST                 = 20
	GroovyParserCONTINUE              = 21
	GroovyParserDEFAULT               = 22
	GroovyParserDO                    = 23
	GroovyParserELSE                  = 24
	GroovyParserENUM                  = 25
	GroovyParserEXTENDS               = 26
	GroovyParserFINAL                 = 27
	GroovyParserFINALLY               = 28
	GroovyParserFOR                   = 29
	GroovyParserIF                    = 30
	GroovyParserGOTO                  = 31
	GroovyParserIMPLEMENTS            = 32
	GroovyParserIMPORT                = 33
	GroovyParserINSTANCEOF            = 34
	GroovyParserINTERFACE             = 35
	GroovyParserNATIVE                = 36
	GroovyParserNEW                   = 37
	GroovyParserPACKAGE               = 38
	GroovyParserPRIVATE               = 39
	GroovyParserPROTECTED             = 40
	GroovyParserPUBLIC                = 41
	GroovyParserRETURN                = 42
	GroovyParserSTATIC                = 43
	GroovyParserSTRICTFP              = 44
	GroovyParserSUPER                 = 45
	GroovyParserSWITCH                = 46
	GroovyParserSYNCHRONIZED          = 47
	GroovyParserTHIS                  = 48
	GroovyParserTHROW                 = 49
	GroovyParserTHROWS                = 50
	GroovyParserTRANSIENT             = 51
	GroovyParserTRY                   = 52
	GroovyParserVOID                  = 53
	GroovyParserVOLATILE              = 54
	GroovyParserWHILE                 = 55
	GroovyParserIntegerLiteral        = 56
	GroovyParserFloatingPointLiteral  = 57
	GroovyParserBooleanLiteral        = 58
	GroovyParserNullLiteral           = 59
	GroovyParserRANGE_INCLUSIVE       = 60
	GroovyParserRANGE_EXCLUSIVE       = 61
	GroovyParserSPREAD_DOT            = 62
	GroovyParserSAFE_DOT              = 63
	GroovyParserSAFE_CHAIN_DOT        = 64
	GroovyParserELVIS                 = 65
	GroovyParserMETHOD_POINTER        = 66
	GroovyParserMETHOD_REFERENCE      = 67
	GroovyParserREGEX_FIND            = 68
	GroovyParserREGEX_MATCH           = 69
	GroovyParserPOWER                 = 70
	GroovyParserPOWER_ASSIGN          = 71
	GroovyParserSPACESHIP             = 72
	GroovyParserIDENTICAL             = 73
	GroovyParserNOT_IDENTICAL         = 74
	GroovyParserARROW                 = 75
	GroovyParserNOT_INSTANCEOF        = 76
	GroovyParserNOT_IN                = 77
	GroovyParserLPAREN                = 78
	GroovyParserRPAREN                = 79
	GroovyParserLBRACE                = 80
	GroovyParserRBRACE                = 81
	GroovyParserLBRACK                = 82
	GroovyParserRBRACK                = 83
	GroovyParserSEMI                  = 84
	GroovyParserCOMMA                 = 85
	GroovyParserDOT                   = 86
	GroovyParserASSIGN                = 87
	GroovyParserGT                    = 88
	GroovyParserLT                    = 89
	GroovyParserNOT                   = 90
	GroovyParserBITNOT                = 91
	GroovyParserQUESTION              = 92
	GroovyParserCOLON                 = 93
	GroovyParserEQUAL                 = 94
	GroovyParserLE                    = 95
	GroovyParserGE                    = 96
	GroovyParserNOTEQUAL              = 97
	GroovyParserAND                   = 98
	GroovyParserOR                    = 99
	GroovyParserINC                   = 100
	GroovyParserDEC                   = 101
	GroovyParserADD                   = 102
	GroovyParserSUB                   = 103
	GroovyParserMUL                   = 104
	GroovyParserDIV                   = 105
	GroovyParserBITAND                = 106
	GroovyParserBITOR                 = 107
	GroovyParserXOR                   = 108
	GroovyParserMOD                   = 109
	GroovyParserADD_ASSIGN            = 110
	GroovyParserSUB_ASSIGN            = 111
	GroovyParserMUL_ASSIGN            = 112
	GroovyParserDIV_ASSIGN            = 113
	GroovyParserAND_ASSIGN            = 114
	GroovyParserOR_ASSIGN             = 115
	GroovyParserXOR_ASSIGN            = 116
	GroovyParserMOD_ASSIGN            = 117
	GroovyParserLSHIFT_ASSIGN         = 118
	GroovyParserRSHIFT_ASSIGN         = 119
	GroovyParserURSHIFT_ASSIGN        = 120
	GroovyParserELVIS_ASSIGN          = 121
	GroovyParserCapitalizedIdentifier = 122
	GroovyParserIdentifier            = 123
	GroovyParserAT                    = 124
	GroovyParserELLIPSIS              = 125
	GroovyParserWS                    = 126
	GroovyParserNL                    = 127
	GroovyParserSH_COMMENT            = 128
	GroovyParserUNEXPECTED_CHAR       = 129
)

// GroovyParser rules.
const (
	GroovyParserRULE_compilationUnit                = 0
	GroovyParserRULE_scriptStatements               = 1
	GroovyParserRULE_scriptStatement                = 2
	GroovyParserRULE_packageDeclaration             = 3
	GroovyParserRULE_importDeclaration              = 4
	GroovyParserRULE_typeDeclaration                = 5
	GroovyParserRULE_modifier                       = 6
	GroovyParserRULE_modifiersOpt                   = 7
	GroovyParserRULE_modifiers                      = 8
	GroovyParserRULE_classOrInterfaceModifiersOpt   = 9
	GroovyParserRULE_classOrInterfaceModifiers      = 10
	GroovyParserRULE_classOrInterfaceModifier       = 11
	GroovyParserRULE_variableModifier               = 12
	GroovyParserRULE_variableModifiersOpt           = 13
	GroovyParserRULE_variableModifiers              = 14
	GroovyParserRULE_typeParameters                 = 15
	GroovyParserRULE_typeParameter                  = 16
	GroovyParserRULE_typeBound                      = 17
	GroovyParserRULE_typeList                       = 18
	GroovyParserRULE_classDeclaration               = 19
	GroovyParserRULE_classBody                      = 20
	GroovyParserRULE_enumConstants                  = 21
	GroovyParserRULE_enumConstant                   = 22
	GroovyParserRULE_classBodyDeclaration           = 23
	GroovyParserRULE_memberDeclaration              = 24
	GroovyParserRULE_methodDeclaration              = 25
	GroovyParserRULE_methodName                     = 26
	GroovyParserRULE_returnType                     = 27
	GroovyParserRULE_fieldDeclaration               = 28
	GroovyParserRULE_variableDeclarators            = 29
	GroovyParserRULE_variableDeclarator             = 30
	GroovyParserRULE_variableDeclaratorId           = 31
	GroovyParserRULE_variableInitializer            = 32
	GroovyParserRULE_variableInitializers           = 33
	GroovyParserRULE_dims                           = 34
	GroovyParserRULE_dimsOpt                        = 35
	GroovyParserRULE_standardType                   = 36
	GroovyParserRULE_typeType                       = 37
	GroovyParserRULE_classOrInterfaceType           = 38
	GroovyParserRULE_generalClassOrInterfaceType    = 39
	GroovyParserRULE_standardClassOrInterfaceType   = 40
	GroovyParserRULE_primitiveType                  = 41
	GroovyParserRULE_typeArguments                  = 42
	GroovyParserRULE_typeArgument                   = 43
	GroovyParserRULE_annotatedQualifiedClassName    = 44
	GroovyParserRULE_qualifiedClassNameList         = 45
	GroovyParserRULE_formalParameters               = 46
	GroovyParserRULE_formalParameterList            = 47
	GroovyParserRULE_thisFormalParameter            = 48
	GroovyParserRULE_formalParameter                = 49
	GroovyParserRULE_methodBody                     = 50
	GroovyParserRULE_qualifiedName                  = 51
	GroovyParserRULE_qualifiedNameElement           = 52
	GroovyParserRULE_qualifiedNameElements          = 53
	GroovyParserRULE_qualifiedClassName             = 54
	GroovyParserRULE_qualifiedStandardClassName     = 55
	GroovyParserRULE_literal                        = 56
	GroovyParserRULE_gstring                        = 57
	GroovyParserRULE_gstringValue                   = 58
	GroovyParserRULE_gstringPath                    = 59
	GroovyParserRULE_lambdaExpression               = 60
	GroovyParserRULE_standardLambdaExpression       = 61
	GroovyParserRULE_lambdaParameters               = 62
	GroovyParserRULE_standardLambdaParameters       = 63
	GroovyParserRULE_lambdaBody                     = 64
	GroovyParserRULE_closure                        = 65
	GroovyParserRULE_closureOrLambdaExpression      = 66
	GroovyParserRULE_blockStatementsOpt             = 67
	GroovyParserRULE_blockStatements                = 68
	GroovyParserRULE_annotationsOpt                 = 69
	GroovyParserRULE_annotation                     = 70
	GroovyParserRULE_elementValues                  = 71
	GroovyParserRULE_annotationName                 = 72
	GroovyParserRULE_elementValuePairs              = 73
	GroovyParserRULE_elementValuePair               = 74
	GroovyParserRULE_elementValuePairName           = 75
	GroovyParserRULE_elementValue                   = 76
	GroovyParserRULE_elementValueArrayInitializer   = 77
	GroovyParserRULE_block                          = 78
	GroovyParserRULE_blockStatement                 = 79
	GroovyParserRULE_localVariableDeclaration       = 80
	GroovyParserRULE_classifiedModifiers            = 81
	GroovyParserRULE_variableDeclaration            = 82
	GroovyParserRULE_typeNamePairs                  = 83
	GroovyParserRULE_typeNamePair                   = 84
	GroovyParserRULE_variableNames                  = 85
	GroovyParserRULE_conditionalStatement           = 86
	GroovyParserRULE_ifElseStatement                = 87
	GroovyParserRULE_switchStatement                = 88
	GroovyParserRULE_loopStatement                  = 89
	GroovyParserRULE_continueStatement              = 90
	GroovyParserRULE_breakStatement                 = 91
	GroovyParserRULE_tryCatchStatement              = 92
	GroovyParserRULE_assertStatement                = 93
	GroovyParserRULE_statement                      = 94
	GroovyParserRULE_catchClause                    = 95
	GroovyParserRULE_catchType                      = 96
	GroovyParserRULE_finallyBlock                   = 97
	GroovyParserRULE_resources                      = 98
	GroovyParserRULE_resourceList                   = 99
	GroovyParserRULE_resource                       = 100
	GroovyParserRULE_switchBlockStatementGroup      = 101
	GroovyParserRULE_switchLabel                    = 102
	GroovyParserRULE_forControl                     = 103
	GroovyParserRULE_enhancedForControl             = 104
	GroovyParserRULE_classicalForControl            = 105
	GroovyParserRULE_forInit                        = 106
	GroovyParserRULE_forUpdate                      = 107
	GroovyParserRULE_castParExpression              = 108
	GroovyParserRULE_parExpression                  = 109
	GroovyParserRULE_expressionInPar                = 110
	GroovyParserRULE_expressionList                 = 111
	GroovyParserRULE_expressionListElement          = 112
	GroovyParserRULE_enhancedStatementExpression    = 113
	GroovyParserRULE_statementExpression            = 114
	GroovyParserRULE_postfixExpression              = 115
	GroovyParserRULE_expression                     = 116
	GroovyParserRULE_castOperandExpression          = 117
	GroovyParserRULE_commandExpression              = 118
	GroovyParserRULE_commandArgument                = 119
	GroovyParserRULE_pathExpression                 = 120
	GroovyParserRULE_pathElement                    = 121
	GroovyParserRULE_namePart                       = 122
	GroovyParserRULE_dynamicMemberName              = 123
	GroovyParserRULE_indexPropertyArgs              = 124
	GroovyParserRULE_namedPropertyArgs              = 125
	GroovyParserRULE_primary                        = 126
	GroovyParserRULE_list                           = 127
	GroovyParserRULE_normalMap                      = 128
	GroovyParserRULE_mapEntryList                   = 129
	GroovyParserRULE_mapEntry                       = 130
	GroovyParserRULE_mapEntryLabel                  = 131
	GroovyParserRULE_creator                        = 132
	GroovyParserRULE_arrayInitializer               = 133
	GroovyParserRULE_anonymousInnerClassDeclaration = 134
	GroovyParserRULE_createdName                    = 135
	GroovyParserRULE_nonWildcardTypeArguments       = 136
	GroovyParserRULE_typeArgumentsOrDiamond         = 137
	GroovyParserRULE_arguments                      = 138
	GroovyParserRULE_argumentList                   = 139
	GroovyParserRULE_enhancedArgumentList           = 140
	GroovyParserRULE_argumentListElement            = 141
	GroovyParserRULE_enhancedArgumentListElement    = 142
	GroovyParserRULE_stringLiteral                  = 143
	GroovyParserRULE_className                      = 144
	GroovyParserRULE_identifier                     = 145
	GroovyParserRULE_builtInType                    = 146
	GroovyParserRULE_keywords                       = 147
	GroovyParserRULE_rparen                         = 148
	GroovyParserRULE_nls                            = 149
	GroovyParserRULE_sep                            = 150
)

// ICompilationUnitContext is an interface to support dynamic dispatch.
type ICompilationUnitContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCompilationUnitContext differentiates from other interfaces.
	IsCompilationUnitContext()
}

type CompilationUnitContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyCompilationUnitContext() *CompilationUnitContext {
	var p = new(CompilationUnitContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_compilationUnit
	return p
}

func (*CompilationUnitContext) IsCompilationUnitContext() {}

func NewCompilationUnitContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CompilationUnitContext {
	var p = new(CompilationUnitContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_compilationUnit

	return p
}

func (s *CompilationUnitContext) GetParser() antlr.Parser { return s.parser }

func (s *CompilationUnitContext) Nls() INlsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INlsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *CompilationUnitContext) EOF() antlr.TerminalNode {
	return s.GetToken(GroovyParserEOF, 0)
}

func (s *CompilationUnitContext) PackageDeclaration() IPackageDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPackageDeclarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPackageDeclarationContext)
}

func (s *CompilationUnitContext) Sep() ISepContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISepContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISepContext)
}

func (s *CompilationUnitContext) ScriptStatements() IScriptStatementsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IScriptStatementsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IScriptStatementsContext)
}

func (s *CompilationUnitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CompilationUnitContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CompilationUnitContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterCompilationUnit(s)
	}
}

func (s *CompilationUnitContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitCompilationUnit(s)
	}
}

func (p *GroovyParser) CompilationUnit() (localctx ICompilationUnitContext) {
	localctx = NewCompilationUnitContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, GroovyParserRULE_compilationUnit)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(302)
		p.Nls()
	}
	p.SetState(304)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 0, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(303)
			p.PackageDeclaration()
		}

	}
	p.SetState(307)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 1, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(306)
			p.Sep()
		}

	}
	p.SetState(310)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 2, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(309)
			p.ScriptStatements()
		}

	}
	{
		p.SetState(312)
		p.Match(GroovyParserEOF)
	}

	return localctx
}

// IScriptStatementsContext is an interface to support dynamic dispatch.
type IScriptStatementsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsScriptStatementsContext differentiates from other interfaces.
	IsScriptStatementsContext()
}

type ScriptStatementsContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyScriptStatementsContext() *ScriptStatementsContext {
	var p = new(ScriptStatementsContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_scriptStatements
	return p
}

func (*ScriptStatementsContext) IsScriptStatementsContext() {}

func NewScriptStatementsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ScriptStatementsContext {
	var p = new(ScriptStatementsContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_scriptStatements

	return p
}

func (s *ScriptStatementsContext) GetParser() antlr.Parser { return s.parser }

func (s *ScriptStatementsContext) AllScriptStatement() []IScriptStatementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IScriptStatementContext)(nil)).Elem())
	var tst = make([]IScriptStatementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IScriptStatementContext)
		}
	}

	return tst
}

func (s *ScriptStatementsContext) ScriptStatement(i int) IScriptStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IScriptStatementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IScriptStatementContext)
}

func (s *ScriptStatementsContext) AllSep() []ISepContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISepContext)(nil)).Elem())
	var tst = make([]ISepContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISepContext)
		}
	}

	return tst
}

func (s *ScriptStatementsContext) Sep(i int) ISepContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISepContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISepContext)
}

func (s *ScriptStatementsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScriptStatementsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ScriptStatementsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterScriptStatements(s)
	}
}

func (s *ScriptStatementsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitScriptStatements(s)
	}
}

func (p *GroovyParser) ScriptStatements() (localctx IScriptStatementsContext) {
	localctx = NewScriptStatementsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, GroovyParserRULE_scriptStatements)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(314)
		p.ScriptStatement()
	}
	p.SetState(320)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 3, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(315)
				p.Sep()
			}
			{
				p.SetState(316)
				p.ScriptStatement()
			}

		}
		p.SetState(322)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 3, p.GetParserRuleContext())
	}
	p.SetState(324)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == GroovyParserSEMI || _la == GroovyParserNL {
		{
			p.SetState(323)
			p.Sep()
		}

	}

	return localctx
}

// IScriptStatementContext is an interface to support dynamic dispatch.
type IScriptStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsScriptStatementContext differentiates from other interfaces.
	IsScriptStatementContext()
}

type ScriptStatementContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyScriptStatementContext() *ScriptStatementContext {
	var p = new(ScriptStatementContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_scriptStatement
	return p
}

func (*ScriptStatementContext) IsScriptStatementContext() {}

func NewScriptStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ScriptStatementContext {
	var p = new(ScriptStatementContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_scriptStatement

	return p
}

func (s *ScriptStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ScriptStatementContext) ImportDeclaration() IImportDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IImportDeclarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IImportDeclarationContext)
}

func (s *ScriptStatementContext) TypeDeclaration() ITypeDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeDeclarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeDeclarationContext)
}

func (s *ScriptStatementContext) Statement() IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *ScriptStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScriptStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ScriptStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterScriptStatement(s)
	}
}

func (s *ScriptStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitScriptStatement(s)
	}
}

func (p *GroovyParser) ScriptStatement() (localctx IScriptStatementContext) {
	localctx = NewScriptStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, GroovyParserRULE_scriptStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(329)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 5, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(326)
			p.ImportDeclaration()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(327)
			p.TypeDeclaration()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(328)
			p.Statement()
		}

	}

	return localctx
}

// IPackageDeclarationContext is an interface to support dynamic dispatch.
type IPackageDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPackageDeclarationContext differentiates from other interfaces.
	IsPackageDeclarationContext()
}

type PackageDeclarationContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyPackageDeclarationContext() *PackageDeclarationContext {
	var p = new(PackageDeclarationContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_packageDeclaration
	return p
}

func (*PackageDeclarationContext) IsPackageDeclarationContext() {}

func NewPackageDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PackageDeclarationContext {
	var p = new(PackageDeclarationContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_packageDeclaration

	return p
}

func (s *PackageDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *PackageDeclarationContext) AnnotationsOpt() IAnnotationsOptContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotationsOptContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAnnotationsOptContext)
}

func (s *PackageDeclarationContext) PACKAGE() antlr.TerminalNode {
	return s.GetToken(GroovyParserPACKAGE, 0)
}

func (s *PackageDeclarationContext) QualifiedName() IQualifiedNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *PackageDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PackageDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PackageDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterPackageDeclaration(s)
	}
}

func (s *PackageDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitPackageDeclaration(s)
	}
}

func (p *GroovyParser) PackageDeclaration() (localctx IPackageDeclarationContext) {
	localctx = NewPackageDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, GroovyParserRULE_packageDeclaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(331)
		p.AnnotationsOpt()
	}
	{
		p.SetState(332)
		p.Match(GroovyParserPACKAGE)
	}
	{
		p.SetState(333)
		p.QualifiedName()
	}

	return localctx
}

// IImportDeclarationContext is an interface to support dynamic dispatch.
type IImportDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetAlias returns the alias rule contexts.
	GetAlias() IIdentifierContext

	// SetAlias sets the alias rule contexts.
	SetAlias(IIdentifierContext)

	// IsImportDeclarationContext differentiates from other interfaces.
	IsImportDeclarationContext()
}

type ImportDeclarationContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
	alias  IIdentifierContext
}

func NewEmptyImportDeclarationContext() *ImportDeclarationContext {
	var p = new(ImportDeclarationContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_importDeclaration
	return p
}

func (*ImportDeclarationContext) IsImportDeclarationContext() {}

func NewImportDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImportDeclarationContext {
	var p = new(ImportDeclarationContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_importDeclaration

	return p
}

func (s *ImportDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *ImportDeclarationContext) GetAlias() IIdentifierContext { return s.alias }

func (s *ImportDeclarationContext) SetAlias(v IIdentifierContext) { s.alias = v }

func (s *ImportDeclarationContext) AnnotationsOpt() IAnnotationsOptContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotationsOptContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAnnotationsOptContext)
}

func (s *ImportDeclarationContext) IMPORT() antlr.TerminalNode {
	return s.GetToken(GroovyParserIMPORT, 0)
}

func (s *ImportDeclarationContext) QualifiedName() IQualifiedNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ImportDeclarationContext) STATIC() antlr.TerminalNode {
	return s.GetToken(GroovyParserSTATIC, 0)
}

func (s *ImportDeclarationContext) DOT() antlr.TerminalNode {
	return s.GetToken(GroovyParserDOT, 0)
}

func (s *ImportDeclarationContext) MUL() antlr.TerminalNode {
	return s.GetToken(GroovyParserMUL, 0)
}

func (s *ImportDeclarationContext) AS() antlr.TerminalNode {
	return s.GetToken(GroovyParserAS, 0)
}

func (s *ImportDeclarationContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ImportDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImportDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterImportDeclaration(s)
	}
}

func (s *ImportDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitImportDeclaration(s)
	}
}

func (p *GroovyParser) ImportDeclaration() (localctx IImportDeclarationContext) {
	localctx = NewImportDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, GroovyParserRULE_importDeclaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(335)
		p.AnnotationsOpt()
	}
	{
		p.SetState(336)
		p.Match(GroovyParserIMPORT)
	}
	p.SetState(338)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 6, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(337)
			p.Match(GroovyParserSTATIC)
		}

	}
	{
		p.SetState(340)
		p.QualifiedName()
	}
	p.SetState(345)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case GroovyParserDOT:
		{
			p.SetState(341)
			p.Match(GroovyParserDOT)
		}
		{
			p.SetState(342)
			p.Match(GroovyParserMUL)
		}

	case GroovyParserAS:
		{
			p.SetState(343)
			p.Match(GroovyParserAS)
		}
		{
			p.SetState(344)

			var _x = p.Identifier()

			localctx.(*ImportDeclarationContext).alias = _x
		}

	case GroovyParserEOF, GroovyParserSEMI, GroovyParserNL:

	default:
	}

	return localctx
}

// ITypeDeclarationContext is an interface to support dynamic dispatch.
type ITypeDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeDeclarationContext differentiates from other interfaces.
	IsTypeDeclarationContext()
}

type TypeDeclarationContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeDeclarationContext() *TypeDeclarationContext {
	var p = new(TypeDeclarationContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_typeDeclaration
	return p
}

func (*TypeDeclarationContext) IsTypeDeclarationContext() {}

func NewTypeDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeDeclarationContext {
	var p = new(TypeDeclarationContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_typeDeclaration

	return p
}

func (s *TypeDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeDeclarationContext) ClassOrInterfaceModifiersOpt() IClassOrInterfaceModifiersOptContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClassOrInterfaceModifiersOptContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClassOrInterfaceModifiersOptContext)
}

func (s *TypeDeclarationContext) ClassDeclaration() IClassDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClassDeclarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClassDeclarationContext)
}

func (s *TypeDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterTypeDeclaration(s)
	}
}

func (s *TypeDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitTypeDeclaration(s)
	}
}

func (p *GroovyParser) TypeDeclaration() (localctx ITypeDeclarationContext) {
	localctx = NewTypeDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, GroovyParserRULE_typeDeclaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(347)
		p.ClassOrInterfaceModifiersOpt()
	}
	{
		p.SetState(348)
		p.ClassDeclaration()
	}

	return localctx
}

// IModifierContext is an interface to support dynamic dispatch.
type IModifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetM returns the m token.
	GetM() antlr.Token

	// SetM sets the m token.
	SetM(antlr.Token)

	// IsModifierContext differentiates from other interfaces.
	IsModifierContext()
}

type ModifierContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
	m      antlr.Token
}

func NewEmptyModifierContext() *ModifierContext {
	var p = new(ModifierContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_modifier
	return p
}

func (*ModifierContext) IsModifierContext() {}

func NewModifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ModifierContext {
	var p = new(ModifierContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_modifier

	return p
}

func (s *ModifierContext) GetParser() antlr.Parser { return s.parser }

func (s *ModifierContext) GetM() antlr.Token { return s.m }

func (s *ModifierContext) SetM(v antlr.Token) { s.m = v }

func (s *ModifierContext) ClassOrInterfaceModifier() IClassOrInterfaceModifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClassOrInterfaceModifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClassOrInterfaceModifierContext)
}

func (s *ModifierContext) NATIVE() antlr.TerminalNode {
	return s.GetToken(GroovyParserNATIVE, 0)
}

func (s *ModifierContext) SYNCHRONIZED() antlr.TerminalNode {
	return s.GetToken(GroovyParserSYNCHRONIZED, 0)
}

func (s *ModifierContext) TRANSIENT() antlr.TerminalNode {
	return s.GetToken(GroovyParserTRANSIENT, 0)
}

func (s *ModifierContext) VOLATILE() antlr.TerminalNode {
	return s.GetToken(GroovyParserVOLATILE, 0)
}

func (s *ModifierContext) DEF() antlr.TerminalNode {
	return s.GetToken(GroovyParserDEF, 0)
}

func (s *ModifierContext) VAR() antlr.TerminalNode {
	return s.GetToken(GroovyParserVAR, 0)
}

func (s *ModifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ModifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterModifier(s)
	}
}

func (s *ModifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitModifier(s)
	}
}

func (p *GroovyParser) Modifier() (localctx IModifierContext) {
	localctx = NewModifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, GroovyParserRULE_modifier)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(352)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case GroovyParserABSTRACT, GroovyParserDEFAULT, GroovyParserFINAL, GroovyParserPRIVATE, GroovyParserPROTECTED, GroovyParserPUBLIC, GroovyParserSTATIC, GroovyParserSTRICTFP, GroovyParserAT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(350)
			p.ClassOrInterfaceModifier()
		}

	case GroovyParserDEF, GroovyParserVAR, GroovyParserNATIVE, GroovyParserSYNCHRONIZED, GroovyParserTRANSIENT, GroovyParserVOLATILE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(351)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*ModifierContext).m = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == GroovyParserDEF || _la == GroovyParserVAR || (((_la-36)&-(0x1f+1)) == 0 && ((1<<uint((_la-36)))&((1<<(GroovyParserNATIVE-36))|(1<<(GroovyParserSYNCHRONIZED-36))|(1<<(GroovyParserTRANSIENT-36))|(1<<(GroovyParserVOLATILE-36)))) != 0)) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*ModifierContext).m = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IModifiersOptContext is an interface to support dynamic dispatch.
type IModifiersOptContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModifiersOptContext differentiates from other interfaces.
	IsModifiersOptContext()
}

type ModifiersOptContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyModifiersOptContext() *ModifiersOptContext {
	var p = new(ModifiersOptContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_modifiersOpt
	return p
}

func (*ModifiersOptContext) IsModifiersOptContext() {}

func NewModifiersOptContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ModifiersOptContext {
	var p = new(ModifiersOptContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_modifiersOpt

	return p
}

func (s *ModifiersOptContext) GetParser() antlr.Parser { return s.parser }

func (s *ModifiersOptContext) Modifiers() IModifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModifiersContext)
}

func (s *ModifiersOptContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModifiersOptContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ModifiersOptContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterModifiersOpt(s)
	}
}

func (s *ModifiersOptContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitModifiersOpt(s)
	}
}

func (p *GroovyParser) ModifiersOpt() (localctx IModifiersOptContext) {
	localctx = NewModifiersOptContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, GroovyParserRULE_modifiersOpt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(355)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 9, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(354)
			p.Modifiers()
		}

	}

	return localctx
}

// IModifiersContext is an interface to support dynamic dispatch.
type IModifiersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModifiersContext differentiates from other interfaces.
	IsModifiersContext()
}

type ModifiersContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyModifiersContext() *ModifiersContext {
	var p = new(ModifiersContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_modifiers
	return p
}

func (*ModifiersContext) IsModifiersContext() {}

func NewModifiersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ModifiersContext {
	var p = new(ModifiersContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_modifiers

	return p
}

func (s *ModifiersContext) GetParser() antlr.Parser { return s.parser }

func (s *ModifiersContext) AllModifier() []IModifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IModifierContext)(nil)).Elem())
	var tst = make([]IModifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IModifierContext)
		}
	}

	return tst
}

func (s *ModifiersContext) Modifier(i int) IModifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IModifierContext)
}

func (s *ModifiersContext) AllNls() []INlsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INlsContext)(nil)).Elem())
	var tst = make([]INlsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INlsContext)
		}
	}

	return tst
}

func (s *ModifiersContext) Nls(i int) INlsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INlsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *ModifiersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModifiersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ModifiersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterModifiers(s)
	}
}

func (s *ModifiersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitModifiers(s)
	}
}

func (p *GroovyParser) Modifiers() (localctx IModifiersContext) {
	localctx = NewModifiersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, GroovyParserRULE_modifiers)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(360)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(357)
				p.Modifier()
			}
			{
				p.SetState(358)
				p.Nls()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(362)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 10, p.GetParserRuleContext())
	}

	return localctx
}

// IClassOrInterfaceModifiersOptContext is an interface to support dynamic dispatch.
type IClassOrInterfaceModifiersOptContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClassOrInterfaceModifiersOptContext differentiates from other interfaces.
	IsClassOrInterfaceModifiersOptContext()
}

type ClassOrInterfaceModifiersOptContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassOrInterfaceModifiersOptContext() *ClassOrInterfaceModifiersOptContext {
	var p = new(ClassOrInterfaceModifiersOptContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_classOrInterfaceModifiersOpt
	return p
}

func (*ClassOrInterfaceModifiersOptContext) IsClassOrInterfaceModifiersOptContext() {}

func NewClassOrInterfaceModifiersOptContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassOrInterfaceModifiersOptContext {
	var p = new(ClassOrInterfaceModifiersOptContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_classOrInterfaceModifiersOpt

	return p
}

func (s *ClassOrInterfaceModifiersOptContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassOrInterfaceModifiersOptContext) ClassOrInterfaceModifiers() IClassOrInterfaceModifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClassOrInterfaceModifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClassOrInterfaceModifiersContext)
}

func (s *ClassOrInterfaceModifiersOptContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassOrInterfaceModifiersOptContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassOrInterfaceModifiersOptContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterClassOrInterfaceModifiersOpt(s)
	}
}

func (s *ClassOrInterfaceModifiersOptContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitClassOrInterfaceModifiersOpt(s)
	}
}

func (p *GroovyParser) ClassOrInterfaceModifiersOpt() (localctx IClassOrInterfaceModifiersOptContext) {
	localctx = NewClassOrInterfaceModifiersOptContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, GroovyParserRULE_classOrInterfaceModifiersOpt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(365)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 11, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(364)
			p.ClassOrInterfaceModifiers()
		}

	}

	return localctx
}

// IClassOrInterfaceModifiersContext is an interface to support dynamic dispatch.
type IClassOrInterfaceModifiersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClassOrInterfaceModifiersContext differentiates from other interfaces.
	IsClassOrInterfaceModifiersContext()
}

type ClassOrInterfaceModifiersContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassOrInterfaceModifiersContext() *ClassOrInterfaceModifiersContext {
	var p = new(ClassOrInterfaceModifiersContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_classOrInterfaceModifiers
	return p
}

func (*ClassOrInterfaceModifiersContext) IsClassOrInterfaceModifiersContext() {}

func NewClassOrInterfaceModifiersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassOrInterfaceModifiersContext {
	var p = new(ClassOrInterfaceModifiersContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_classOrInterfaceModifiers

	return p
}

func (s *ClassOrInterfaceModifiersContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassOrInterfaceModifiersContext) AllClassOrInterfaceModifier() []IClassOrInterfaceModifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IClassOrInterfaceModifierContext)(nil)).Elem())
	var tst = make([]IClassOrInterfaceModifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IClassOrInterfaceModifierContext)
		}
	}

	return tst
}

func (s *ClassOrInterfaceModifiersContext) ClassOrInterfaceModifier(i int) IClassOrInterfaceModifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClassOrInterfaceModifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IClassOrInterfaceModifierContext)
}

func (s *ClassOrInterfaceModifiersContext) AllNls() []INlsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INlsContext)(nil)).Elem())
	var tst = make([]INlsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INlsContext)
		}
	}

	return tst
}

func (s *ClassOrInterfaceModifiersContext) Nls(i int) INlsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INlsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *ClassOrInterfaceModifiersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassOrInterfaceModifiersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassOrInterfaceModifiersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterClassOrInterfaceModifiers(s)
	}
}

func (s *ClassOrInterfaceModifiersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitClassOrInterfaceModifiers(s)
	}
}

func (p *GroovyParser) ClassOrInterfaceModifiers() (localctx IClassOrInterfaceModifiersContext) {
	localctx = NewClassOrInterfaceModifiersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, GroovyParserRULE_classOrInterfaceModifiers)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(370)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(367)
				p.ClassOrInterfaceModifier()
			}
			{
				p.SetState(368)
				p.Nls()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(372)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 12, p.GetParserRuleContext())
	}

	return localctx
}

// IClassOrInterfaceModifierContext is an interface to support dynamic dispatch.
type IClassOrInterfaceModifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetM returns the m token.
	GetM() antlr.Token

	// SetM sets the m token.
	SetM(antlr.Token)

	// IsClassOrInterfaceModifierContext differentiates from other interfaces.
	IsClassOrInterfaceModifierContext()
}

type ClassOrInterfaceModifierContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
	m      antlr.Token
}

func NewEmptyClassOrInterfaceModifierContext() *ClassOrInterfaceModifierContext {
	var p = new(ClassOrInterfaceModifierContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_classOrInterfaceModifier
	return p
}

func (*ClassOrInterfaceModifierContext) IsClassOrInterfaceModifierContext() {}

func NewClassOrInterfaceModifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassOrInterfaceModifierContext {
	var p = new(ClassOrInterfaceModifierContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_classOrInterfaceModifier

	return p
}

func (s *ClassOrInterfaceModifierContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassOrInterfaceModifierContext) GetM() antlr.Token { return s.m }

func (s *ClassOrInterfaceModifierContext) SetM(v antlr.Token) { s.m = v }

func (s *ClassOrInterfaceModifierContext) Annotation() IAnnotationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *ClassOrInterfaceModifierContext) PUBLIC() antlr.TerminalNode {
	return s.GetToken(GroovyParserPUBLIC, 0)
}

func (s *ClassOrInterfaceModifierContext) PROTECTED() antlr.TerminalNode {
	return s.GetToken(GroovyParserPROTECTED, 0)
}

func (s *ClassOrInterfaceModifierContext) PRIVATE() antlr.TerminalNode {
	return s.GetToken(GroovyParserPRIVATE, 0)
}

func (s *ClassOrInterfaceModifierContext) STATIC() antlr.TerminalNode {
	return s.GetToken(GroovyParserSTATIC, 0)
}

func (s *ClassOrInterfaceModifierContext) ABSTRACT() antlr.TerminalNode {
	return s.GetToken(GroovyParserABSTRACT, 0)
}

func (s *ClassOrInterfaceModifierContext) FINAL() antlr.TerminalNode {
	return s.GetToken(GroovyParserFINAL, 0)
}

func (s *ClassOrInterfaceModifierContext) STRICTFP() antlr.TerminalNode {
	return s.GetToken(GroovyParserSTRICTFP, 0)
}

func (s *ClassOrInterfaceModifierContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(GroovyParserDEFAULT, 0)
}

func (s *ClassOrInterfaceModifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassOrInterfaceModifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassOrInterfaceModifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterClassOrInterfaceModifier(s)
	}
}

func (s *ClassOrInterfaceModifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitClassOrInterfaceModifier(s)
	}
}

func (p *GroovyParser) ClassOrInterfaceModifier() (localctx IClassOrInterfaceModifierContext) {
	localctx = NewClassOrInterfaceModifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, GroovyParserRULE_classOrInterfaceModifier)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(376)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case GroovyParserAT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(374)
			p.Annotation()
		}

	case GroovyParserABSTRACT, GroovyParserDEFAULT, GroovyParserFINAL, GroovyParserPRIVATE, GroovyParserPROTECTED, GroovyParserPUBLIC, GroovyParserSTATIC, GroovyParserSTRICTFP:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(375)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*ClassOrInterfaceModifierContext).m = _lt

			_la = p.GetTokenStream().LA(1)

			if !(((_la-14)&-(0x1f+1)) == 0 && ((1<<uint((_la-14)))&((1<<(GroovyParserABSTRACT-14))|(1<<(GroovyParserDEFAULT-14))|(1<<(GroovyParserFINAL-14))|(1<<(GroovyParserPRIVATE-14))|(1<<(GroovyParserPROTECTED-14))|(1<<(GroovyParserPUBLIC-14))|(1<<(GroovyParserSTATIC-14))|(1<<(GroovyParserSTRICTFP-14)))) != 0) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*ClassOrInterfaceModifierContext).m = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IVariableModifierContext is an interface to support dynamic dispatch.
type IVariableModifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetM returns the m token.
	GetM() antlr.Token

	// SetM sets the m token.
	SetM(antlr.Token)

	// IsVariableModifierContext differentiates from other interfaces.
	IsVariableModifierContext()
}

type VariableModifierContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
	m      antlr.Token
}

func NewEmptyVariableModifierContext() *VariableModifierContext {
	var p = new(VariableModifierContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_variableModifier
	return p
}

func (*VariableModifierContext) IsVariableModifierContext() {}

func NewVariableModifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableModifierContext {
	var p = new(VariableModifierContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_variableModifier

	return p
}

func (s *VariableModifierContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableModifierContext) GetM() antlr.Token { return s.m }

func (s *VariableModifierContext) SetM(v antlr.Token) { s.m = v }

func (s *VariableModifierContext) Annotation() IAnnotationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *VariableModifierContext) FINAL() antlr.TerminalNode {
	return s.GetToken(GroovyParserFINAL, 0)
}

func (s *VariableModifierContext) DEF() antlr.TerminalNode {
	return s.GetToken(GroovyParserDEF, 0)
}

func (s *VariableModifierContext) VAR() antlr.TerminalNode {
	return s.GetToken(GroovyParserVAR, 0)
}

func (s *VariableModifierContext) PUBLIC() antlr.TerminalNode {
	return s.GetToken(GroovyParserPUBLIC, 0)
}

func (s *VariableModifierContext) PROTECTED() antlr.TerminalNode {
	return s.GetToken(GroovyParserPROTECTED, 0)
}

func (s *VariableModifierContext) PRIVATE() antlr.TerminalNode {
	return s.GetToken(GroovyParserPRIVATE, 0)
}

func (s *VariableModifierContext) STATIC() antlr.TerminalNode {
	return s.GetToken(GroovyParserSTATIC, 0)
}

func (s *VariableModifierContext) ABSTRACT() antlr.TerminalNode {
	return s.GetToken(GroovyParserABSTRACT, 0)
}

func (s *VariableModifierContext) STRICTFP() antlr.TerminalNode {
	return s.GetToken(GroovyParserSTRICTFP, 0)
}

func (s *VariableModifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableModifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableModifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterVariableModifier(s)
	}
}

func (s *VariableModifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitVariableModifier(s)
	}
}

func (p *GroovyParser) VariableModifier() (localctx IVariableModifierContext) {
	localctx = NewVariableModifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, GroovyParserRULE_variableModifier)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(380)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case GroovyParserAT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(378)
			p.Annotation()
		}

	case GroovyParserDEF, GroovyParserVAR, GroovyParserABSTRACT, GroovyParserFINAL, GroovyParserPRIVATE, GroovyParserPROTECTED, GroovyParserPUBLIC, GroovyParserSTATIC, GroovyParserSTRICTFP:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(379)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*VariableModifierContext).m = _lt

			_la = p.GetTokenStream().LA(1)

			if !((((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<GroovyParserDEF)|(1<<GroovyParserVAR)|(1<<GroovyParserABSTRACT)|(1<<GroovyParserFINAL))) != 0) || (((_la-39)&-(0x1f+1)) == 0 && ((1<<uint((_la-39)))&((1<<(GroovyParserPRIVATE-39))|(1<<(GroovyParserPROTECTED-39))|(1<<(GroovyParserPUBLIC-39))|(1<<(GroovyParserSTATIC-39))|(1<<(GroovyParserSTRICTFP-39)))) != 0)) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*VariableModifierContext).m = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IVariableModifiersOptContext is an interface to support dynamic dispatch.
type IVariableModifiersOptContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVariableModifiersOptContext differentiates from other interfaces.
	IsVariableModifiersOptContext()
}

type VariableModifiersOptContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableModifiersOptContext() *VariableModifiersOptContext {
	var p = new(VariableModifiersOptContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_variableModifiersOpt
	return p
}

func (*VariableModifiersOptContext) IsVariableModifiersOptContext() {}

func NewVariableModifiersOptContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableModifiersOptContext {
	var p = new(VariableModifiersOptContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_variableModifiersOpt

	return p
}

func (s *VariableModifiersOptContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableModifiersOptContext) VariableModifiers() IVariableModifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableModifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariableModifiersContext)
}

func (s *VariableModifiersOptContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableModifiersOptContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableModifiersOptContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterVariableModifiersOpt(s)
	}
}

func (s *VariableModifiersOptContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitVariableModifiersOpt(s)
	}
}

func (p *GroovyParser) VariableModifiersOpt() (localctx IVariableModifiersOptContext) {
	localctx = NewVariableModifiersOptContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, GroovyParserRULE_variableModifiersOpt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(383)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 15, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(382)
			p.VariableModifiers()
		}

	}

	return localctx
}

// IVariableModifiersContext is an interface to support dynamic dispatch.
type IVariableModifiersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVariableModifiersContext differentiates from other interfaces.
	IsVariableModifiersContext()
}

type VariableModifiersContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableModifiersContext() *VariableModifiersContext {
	var p = new(VariableModifiersContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_variableModifiers
	return p
}

func (*VariableModifiersContext) IsVariableModifiersContext() {}

func NewVariableModifiersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableModifiersContext {
	var p = new(VariableModifiersContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_variableModifiers

	return p
}

func (s *VariableModifiersContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableModifiersContext) AllVariableModifier() []IVariableModifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IVariableModifierContext)(nil)).Elem())
	var tst = make([]IVariableModifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IVariableModifierContext)
		}
	}

	return tst
}

func (s *VariableModifiersContext) VariableModifier(i int) IVariableModifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableModifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IVariableModifierContext)
}

func (s *VariableModifiersContext) AllNls() []INlsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INlsContext)(nil)).Elem())
	var tst = make([]INlsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INlsContext)
		}
	}

	return tst
}

func (s *VariableModifiersContext) Nls(i int) INlsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INlsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *VariableModifiersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableModifiersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableModifiersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterVariableModifiers(s)
	}
}

func (s *VariableModifiersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitVariableModifiers(s)
	}
}

func (p *GroovyParser) VariableModifiers() (localctx IVariableModifiersContext) {
	localctx = NewVariableModifiersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, GroovyParserRULE_variableModifiers)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(388)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(385)
				p.VariableModifier()
			}
			{
				p.SetState(386)
				p.Nls()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(390)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 16, p.GetParserRuleContext())
	}

	return localctx
}

// ITypeParametersContext is an interface to support dynamic dispatch.
type ITypeParametersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeParametersContext differentiates from other interfaces.
	IsTypeParametersContext()
}

type TypeParametersContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeParametersContext() *TypeParametersContext {
	var p = new(TypeParametersContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_typeParameters
	return p
}

func (*TypeParametersContext) IsTypeParametersContext() {}

func NewTypeParametersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeParametersContext {
	var p = new(TypeParametersContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_typeParameters

	return p
}

func (s *TypeParametersContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeParametersContext) LT() antlr.TerminalNode {
	return s.GetToken(GroovyParserLT, 0)
}

func (s *TypeParametersContext) AllNls() []INlsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INlsContext)(nil)).Elem())
	var tst = make([]INlsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INlsContext)
		}
	}

	return tst
}

func (s *TypeParametersContext) Nls(i int) INlsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INlsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *TypeParametersContext) AllTypeParameter() []ITypeParameterContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITypeParameterContext)(nil)).Elem())
	var tst = make([]ITypeParameterContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITypeParameterContext)
		}
	}

	return tst
}

func (s *TypeParametersContext) TypeParameter(i int) ITypeParameterContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeParameterContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITypeParameterContext)
}

func (s *TypeParametersContext) GT() antlr.TerminalNode {
	return s.GetToken(GroovyParserGT, 0)
}

func (s *TypeParametersContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(GroovyParserCOMMA)
}

func (s *TypeParametersContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(GroovyParserCOMMA, i)
}

func (s *TypeParametersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeParametersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeParametersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterTypeParameters(s)
	}
}

func (s *TypeParametersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitTypeParameters(s)
	}
}

func (p *GroovyParser) TypeParameters() (localctx ITypeParametersContext) {
	localctx = NewTypeParametersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, GroovyParserRULE_typeParameters)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(392)
		p.Match(GroovyParserLT)
	}
	{
		p.SetState(393)
		p.Nls()
	}
	{
		p.SetState(394)
		p.TypeParameter()
	}
	p.SetState(401)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == GroovyParserCOMMA {
		{
			p.SetState(395)
			p.Match(GroovyParserCOMMA)
		}
		{
			p.SetState(396)
			p.Nls()
		}
		{
			p.SetState(397)
			p.TypeParameter()
		}

		p.SetState(403)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(404)
		p.Nls()
	}
	{
		p.SetState(405)
		p.Match(GroovyParserGT)
	}

	return localctx
}

// ITypeParameterContext is an interface to support dynamic dispatch.
type ITypeParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeParameterContext differentiates from other interfaces.
	IsTypeParameterContext()
}

type TypeParameterContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeParameterContext() *TypeParameterContext {
	var p = new(TypeParameterContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_typeParameter
	return p
}

func (*TypeParameterContext) IsTypeParameterContext() {}

func NewTypeParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeParameterContext {
	var p = new(TypeParameterContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_typeParameter

	return p
}

func (s *TypeParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeParameterContext) ClassName() IClassNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClassNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClassNameContext)
}

func (s *TypeParameterContext) EXTENDS() antlr.TerminalNode {
	return s.GetToken(GroovyParserEXTENDS, 0)
}

func (s *TypeParameterContext) Nls() INlsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INlsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *TypeParameterContext) TypeBound() ITypeBoundContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeBoundContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeBoundContext)
}

func (s *TypeParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeParameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterTypeParameter(s)
	}
}

func (s *TypeParameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitTypeParameter(s)
	}
}

func (p *GroovyParser) TypeParameter() (localctx ITypeParameterContext) {
	localctx = NewTypeParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, GroovyParserRULE_typeParameter)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(407)
		p.ClassName()
	}
	p.SetState(412)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == GroovyParserEXTENDS {
		{
			p.SetState(408)
			p.Match(GroovyParserEXTENDS)
		}
		{
			p.SetState(409)
			p.Nls()
		}
		{
			p.SetState(410)
			p.TypeBound()
		}

	}

	return localctx
}

// ITypeBoundContext is an interface to support dynamic dispatch.
type ITypeBoundContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeBoundContext differentiates from other interfaces.
	IsTypeBoundContext()
}

type TypeBoundContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeBoundContext() *TypeBoundContext {
	var p = new(TypeBoundContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_typeBound
	return p
}

func (*TypeBoundContext) IsTypeBoundContext() {}

func NewTypeBoundContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeBoundContext {
	var p = new(TypeBoundContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_typeBound

	return p
}

func (s *TypeBoundContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeBoundContext) AllTypeType() []ITypeTypeContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITypeTypeContext)(nil)).Elem())
	var tst = make([]ITypeTypeContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITypeTypeContext)
		}
	}

	return tst
}

func (s *TypeBoundContext) TypeType(i int) ITypeTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeTypeContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITypeTypeContext)
}

func (s *TypeBoundContext) AllBITAND() []antlr.TerminalNode {
	return s.GetTokens(GroovyParserBITAND)
}

func (s *TypeBoundContext) BITAND(i int) antlr.TerminalNode {
	return s.GetToken(GroovyParserBITAND, i)
}

func (s *TypeBoundContext) AllNls() []INlsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INlsContext)(nil)).Elem())
	var tst = make([]INlsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INlsContext)
		}
	}

	return tst
}

func (s *TypeBoundContext) Nls(i int) INlsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INlsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *TypeBoundContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeBoundContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeBoundContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterTypeBound(s)
	}
}

func (s *TypeBoundContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitTypeBound(s)
	}
}

func (p *GroovyParser) TypeBound() (localctx ITypeBoundContext) {
	localctx = NewTypeBoundContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, GroovyParserRULE_typeBound)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(414)
		p.TypeType()
	}
	p.SetState(421)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == GroovyParserBITAND {
		{
			p.SetState(415)
			p.Match(GroovyParserBITAND)
		}
		{
			p.SetState(416)
			p.Nls()
		}
		{
			p.SetState(417)
			p.TypeType()
		}

		p.SetState(423)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ITypeListContext is an interface to support dynamic dispatch.
type ITypeListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeListContext differentiates from other interfaces.
	IsTypeListContext()
}

type TypeListContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeListContext() *TypeListContext {
	var p = new(TypeListContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_typeList
	return p
}

func (*TypeListContext) IsTypeListContext() {}

func NewTypeListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeListContext {
	var p = new(TypeListContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_typeList

	return p
}

func (s *TypeListContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeListContext) AllTypeType() []ITypeTypeContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITypeTypeContext)(nil)).Elem())
	var tst = make([]ITypeTypeContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITypeTypeContext)
		}
	}

	return tst
}

func (s *TypeListContext) TypeType(i int) ITypeTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeTypeContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITypeTypeContext)
}

func (s *TypeListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(GroovyParserCOMMA)
}

func (s *TypeListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(GroovyParserCOMMA, i)
}

func (s *TypeListContext) AllNls() []INlsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INlsContext)(nil)).Elem())
	var tst = make([]INlsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INlsContext)
		}
	}

	return tst
}

func (s *TypeListContext) Nls(i int) INlsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INlsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *TypeListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterTypeList(s)
	}
}

func (s *TypeListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitTypeList(s)
	}
}

func (p *GroovyParser) TypeList() (localctx ITypeListContext) {
	localctx = NewTypeListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, GroovyParserRULE_typeList)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(424)
		p.TypeType()
	}
	p.SetState(431)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 20, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(425)
				p.Match(GroovyParserCOMMA)
			}
			{
				p.SetState(426)
				p.Nls()
			}
			{
				p.SetState(427)
				p.TypeType()
			}

		}
		p.SetState(433)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 20, p.GetParserRuleContext())
	}

	return localctx
}

// IClassDeclarationContext is an interface to support dynamic dispatch.
type IClassDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetScs returns the scs rule contexts.
	GetScs() ITypeListContext

	// GetSc returns the sc rule contexts.
	GetSc() ITypeTypeContext

	// GetIs returns the is rule contexts.
	GetIs() ITypeListContext

	// SetScs sets the scs rule contexts.
	SetScs(ITypeListContext)

	// SetSc sets the sc rule contexts.
	SetSc(ITypeTypeContext)

	// SetIs sets the is rule contexts.
	SetIs(ITypeListContext)

	// GetT returns the t attribute.
	GetT() int

	// SetT sets the t attribute.
	SetT(int)

	// IsClassDeclarationContext differentiates from other interfaces.
	IsClassDeclarationContext()
}

type ClassDeclarationContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
	t      int
	scs    ITypeListContext
	sc     ITypeTypeContext
	is     ITypeListContext
}

func NewEmptyClassDeclarationContext() *ClassDeclarationContext {
	var p = new(ClassDeclarationContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_classDeclaration
	return p
}

func (*ClassDeclarationContext) IsClassDeclarationContext() {}

func NewClassDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassDeclarationContext {
	var p = new(ClassDeclarationContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_classDeclaration

	return p
}

func (s *ClassDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassDeclarationContext) GetScs() ITypeListContext { return s.scs }

func (s *ClassDeclarationContext) GetSc() ITypeTypeContext { return s.sc }

func (s *ClassDeclarationContext) GetIs() ITypeListContext { return s.is }

func (s *ClassDeclarationContext) SetScs(v ITypeListContext) { s.scs = v }

func (s *ClassDeclarationContext) SetSc(v ITypeTypeContext) { s.sc = v }

func (s *ClassDeclarationContext) SetIs(v ITypeListContext) { s.is = v }

func (s *ClassDeclarationContext) GetT() int { return s.t }

func (s *ClassDeclarationContext) SetT(v int) { s.t = v }

func (s *ClassDeclarationContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ClassDeclarationContext) AllNls() []INlsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INlsContext)(nil)).Elem())
	var tst = make([]INlsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INlsContext)
		}
	}

	return tst
}

func (s *ClassDeclarationContext) Nls(i int) INlsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INlsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *ClassDeclarationContext) ClassBody() IClassBodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClassBodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClassBodyContext)
}

func (s *ClassDeclarationContext) CLASS() antlr.TerminalNode {
	return s.GetToken(GroovyParserCLASS, 0)
}

func (s *ClassDeclarationContext) INTERFACE() antlr.TerminalNode {
	return s.GetToken(GroovyParserINTERFACE, 0)
}

func (s *ClassDeclarationContext) ENUM() antlr.TerminalNode {
	return s.GetToken(GroovyParserENUM, 0)
}

func (s *ClassDeclarationContext) AT() antlr.TerminalNode {
	return s.GetToken(GroovyParserAT, 0)
}

func (s *ClassDeclarationContext) TRAIT() antlr.TerminalNode {
	return s.GetToken(GroovyParserTRAIT, 0)
}

func (s *ClassDeclarationContext) TypeParameters() ITypeParametersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeParametersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeParametersContext)
}

func (s *ClassDeclarationContext) EXTENDS() antlr.TerminalNode {
	return s.GetToken(GroovyParserEXTENDS, 0)
}

func (s *ClassDeclarationContext) IMPLEMENTS() antlr.TerminalNode {
	return s.GetToken(GroovyParserIMPLEMENTS, 0)
}

func (s *ClassDeclarationContext) AllTypeList() []ITypeListContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITypeListContext)(nil)).Elem())
	var tst = make([]ITypeListContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITypeListContext)
		}
	}

	return tst
}

func (s *ClassDeclarationContext) TypeList(i int) ITypeListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeListContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITypeListContext)
}

func (s *ClassDeclarationContext) TypeType() ITypeTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeTypeContext)
}

func (s *ClassDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterClassDeclaration(s)
	}
}

func (s *ClassDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitClassDeclaration(s)
	}
}

func (p *GroovyParser) ClassDeclaration() (localctx IClassDeclarationContext) {
	localctx = NewClassDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, GroovyParserRULE_classDeclaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(445)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case GroovyParserCLASS:
		{
			p.SetState(434)
			p.Match(GroovyParserCLASS)
		}
		localctx.(*ClassDeclarationContext).SetT(0)

	case GroovyParserINTERFACE:
		{
			p.SetState(436)
			p.Match(GroovyParserINTERFACE)
		}
		localctx.(*ClassDeclarationContext).SetT(1)

	case GroovyParserENUM:
		{
			p.SetState(438)
			p.Match(GroovyParserENUM)
		}
		localctx.(*ClassDeclarationContext).SetT(2)

	case GroovyParserAT:
		{
			p.SetState(440)
			p.Match(GroovyParserAT)
		}
		{
			p.SetState(441)
			p.Match(GroovyParserINTERFACE)
		}
		localctx.(*ClassDeclarationContext).SetT(3)

	case GroovyParserTRAIT:
		{
			p.SetState(443)
			p.Match(GroovyParserTRAIT)
		}
		localctx.(*ClassDeclarationContext).SetT(4)

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	{
		p.SetState(447)
		p.Identifier()
	}
	{
		p.SetState(448)
		p.Nls()
	}
	p.SetState(481)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 28, p.GetParserRuleContext()) {
	case 1:
		p.SetState(449)

		if !(3 != localctx.(*ClassDeclarationContext).t) {
			panic(antlr.NewFailedPredicateException(p, " 3 != $t ", ""))
		}
		p.SetState(451)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 22, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(450)
				p.TypeParameters()
			}

		}
		{
			p.SetState(453)
			p.Nls()
		}
		p.SetState(467)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 25, p.GetParserRuleContext()) {
		case 1:
			p.SetState(454)

			if !(2 != localctx.(*ClassDeclarationContext).t) {
				panic(antlr.NewFailedPredicateException(p, " 2 != $t ", ""))
			}
			p.SetState(464)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 24, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(455)
					p.Match(GroovyParserEXTENDS)
				}
				{
					p.SetState(456)
					p.Nls()
				}
				p.SetState(460)
				p.GetErrorHandler().Sync(p)
				switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 23, p.GetParserRuleContext()) {
				case 1:
					p.SetState(457)

					if !(1 == localctx.(*ClassDeclarationContext).t) {
						panic(antlr.NewFailedPredicateException(p, "1 == $t", ""))
					}
					{
						p.SetState(458)

						var _x = p.TypeList()

						localctx.(*ClassDeclarationContext).scs = _x
					}

				case 2:
					{
						p.SetState(459)

						var _x = p.TypeType()

						localctx.(*ClassDeclarationContext).sc = _x
					}

				}
				{
					p.SetState(462)
					p.Nls()
				}

			}

		case 2:

		}
		p.SetState(478)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 27, p.GetParserRuleContext()) {
		case 1:
			p.SetState(469)

			if !(1 != localctx.(*ClassDeclarationContext).t) {
				panic(antlr.NewFailedPredicateException(p, "1 != $t", ""))
			}
			p.SetState(475)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == GroovyParserIMPLEMENTS {
				{
					p.SetState(470)
					p.Match(GroovyParserIMPLEMENTS)
				}
				{
					p.SetState(471)
					p.Nls()
				}
				{
					p.SetState(472)

					var _x = p.TypeList()

					localctx.(*ClassDeclarationContext).is = _x
				}
				{
					p.SetState(473)
					p.Nls()
				}

			}

		case 2:

		}

	case 2:

	}
	{
		p.SetState(483)
		p.ClassBody(localctx.(*ClassDeclarationContext).t)
	}

	return localctx
}

// IClassBodyContext is an interface to support dynamic dispatch.
type IClassBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetT returns the t attribute.
	GetT() int

	// SetT sets the t attribute.
	SetT(int)

	// IsClassBodyContext differentiates from other interfaces.
	IsClassBodyContext()
}

type ClassBodyContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
	t      int
}

func NewEmptyClassBodyContext() *ClassBodyContext {
	var p = new(ClassBodyContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_classBody
	return p
}

func (*ClassBodyContext) IsClassBodyContext() {}

func NewClassBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int, t int) *ClassBodyContext {
	var p = new(ClassBodyContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_classBody

	p.t = t

	return p
}

func (s *ClassBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassBodyContext) GetT() int { return s.t }

func (s *ClassBodyContext) SetT(v int) { s.t = v }

func (s *ClassBodyContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(GroovyParserLBRACE, 0)
}

func (s *ClassBodyContext) Nls() INlsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INlsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *ClassBodyContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(GroovyParserRBRACE, 0)
}

func (s *ClassBodyContext) AllClassBodyDeclaration() []IClassBodyDeclarationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IClassBodyDeclarationContext)(nil)).Elem())
	var tst = make([]IClassBodyDeclarationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IClassBodyDeclarationContext)
		}
	}

	return tst
}

func (s *ClassBodyContext) ClassBodyDeclaration(i int) IClassBodyDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClassBodyDeclarationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IClassBodyDeclarationContext)
}

func (s *ClassBodyContext) AllSep() []ISepContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISepContext)(nil)).Elem())
	var tst = make([]ISepContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISepContext)
		}
	}

	return tst
}

func (s *ClassBodyContext) Sep(i int) ISepContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISepContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISepContext)
}

func (s *ClassBodyContext) EnumConstants() IEnumConstantsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnumConstantsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEnumConstantsContext)
}

func (s *ClassBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassBodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterClassBody(s)
	}
}

func (s *ClassBodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitClassBody(s)
	}
}

func (p *GroovyParser) ClassBody(t int) (localctx IClassBodyContext) {
	localctx = NewClassBodyContext(p, p.GetParserRuleContext(), p.GetState(), t)
	p.EnterRule(localctx, 40, GroovyParserRULE_classBody)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(485)
		p.Match(GroovyParserLBRACE)
	}
	{
		p.SetState(486)
		p.Nls()
	}
	p.SetState(495)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 31, p.GetParserRuleContext()) {
	case 1:
		p.SetState(487)

		if !(2 == localctx.(*ClassBodyContext).t) {
			panic(antlr.NewFailedPredicateException(p, " 2 == $t ", ""))
		}
		p.SetState(489)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 29, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(488)
				p.EnumConstants()
			}

		}
		p.SetState(492)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 30, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(491)
				p.Sep()
			}

		}

	case 2:

	}
	p.SetState(498)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 32, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(497)
			p.ClassBodyDeclaration(localctx.(*ClassBodyContext).t)
		}

	}
	p.SetState(505)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 33, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(500)
				p.Sep()
			}
			{
				p.SetState(501)
				p.ClassBodyDeclaration(localctx.(*ClassBodyContext).t)
			}

		}
		p.SetState(507)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 33, p.GetParserRuleContext())
	}
	p.SetState(509)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == GroovyParserSEMI || _la == GroovyParserNL {
		{
			p.SetState(508)
			p.Sep()
		}

	}
	{
		p.SetState(511)
		p.Match(GroovyParserRBRACE)
	}

	return localctx
}

// IEnumConstantsContext is an interface to support dynamic dispatch.
type IEnumConstantsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnumConstantsContext differentiates from other interfaces.
	IsEnumConstantsContext()
}

type EnumConstantsContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumConstantsContext() *EnumConstantsContext {
	var p = new(EnumConstantsContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_enumConstants
	return p
}

func (*EnumConstantsContext) IsEnumConstantsContext() {}

func NewEnumConstantsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumConstantsContext {
	var p = new(EnumConstantsContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_enumConstants

	return p
}

func (s *EnumConstantsContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumConstantsContext) AllEnumConstant() []IEnumConstantContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IEnumConstantContext)(nil)).Elem())
	var tst = make([]IEnumConstantContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IEnumConstantContext)
		}
	}

	return tst
}

func (s *EnumConstantsContext) EnumConstant(i int) IEnumConstantContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnumConstantContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IEnumConstantContext)
}

func (s *EnumConstantsContext) AllNls() []INlsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INlsContext)(nil)).Elem())
	var tst = make([]INlsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INlsContext)
		}
	}

	return tst
}

func (s *EnumConstantsContext) Nls(i int) INlsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INlsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *EnumConstantsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(GroovyParserCOMMA)
}

func (s *EnumConstantsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(GroovyParserCOMMA, i)
}

func (s *EnumConstantsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumConstantsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumConstantsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterEnumConstants(s)
	}
}

func (s *EnumConstantsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitEnumConstants(s)
	}
}

func (p *GroovyParser) EnumConstants() (localctx IEnumConstantsContext) {
	localctx = NewEnumConstantsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, GroovyParserRULE_enumConstants)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(513)
		p.EnumConstant()
	}
	p.SetState(521)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 35, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(514)
				p.Nls()
			}
			{
				p.SetState(515)
				p.Match(GroovyParserCOMMA)
			}
			{
				p.SetState(516)
				p.Nls()
			}
			{
				p.SetState(517)
				p.EnumConstant()
			}

		}
		p.SetState(523)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 35, p.GetParserRuleContext())
	}
	p.SetState(527)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 36, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(524)
			p.Nls()
		}
		{
			p.SetState(525)
			p.Match(GroovyParserCOMMA)
		}

	}

	return localctx
}

// IEnumConstantContext is an interface to support dynamic dispatch.
type IEnumConstantContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnumConstantContext differentiates from other interfaces.
	IsEnumConstantContext()
}

type EnumConstantContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumConstantContext() *EnumConstantContext {
	var p = new(EnumConstantContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_enumConstant
	return p
}

func (*EnumConstantContext) IsEnumConstantContext() {}

func NewEnumConstantContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumConstantContext {
	var p = new(EnumConstantContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_enumConstant

	return p
}

func (s *EnumConstantContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumConstantContext) AnnotationsOpt() IAnnotationsOptContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotationsOptContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAnnotationsOptContext)
}

func (s *EnumConstantContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *EnumConstantContext) Arguments() IArgumentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArgumentsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArgumentsContext)
}

func (s *EnumConstantContext) AnonymousInnerClassDeclaration() IAnonymousInnerClassDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnonymousInnerClassDeclarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAnonymousInnerClassDeclarationContext)
}

func (s *EnumConstantContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumConstantContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumConstantContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterEnumConstant(s)
	}
}

func (s *EnumConstantContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitEnumConstant(s)
	}
}

func (p *GroovyParser) EnumConstant() (localctx IEnumConstantContext) {
	localctx = NewEnumConstantContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, GroovyParserRULE_enumConstant)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(529)
		p.AnnotationsOpt()
	}
	{
		p.SetState(530)
		p.Identifier()
	}
	p.SetState(532)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 37, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(531)
			p.Arguments()
		}

	}
	p.SetState(535)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 38, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(534)
			p.AnonymousInnerClassDeclaration(1)
		}

	}

	return localctx
}

// IClassBodyDeclarationContext is an interface to support dynamic dispatch.
type IClassBodyDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetT returns the t attribute.
	GetT() int

	// SetT sets the t attribute.
	SetT(int)

	// IsClassBodyDeclarationContext differentiates from other interfaces.
	IsClassBodyDeclarationContext()
}

type ClassBodyDeclarationContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
	t      int
}

func NewEmptyClassBodyDeclarationContext() *ClassBodyDeclarationContext {
	var p = new(ClassBodyDeclarationContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_classBodyDeclaration
	return p
}

func (*ClassBodyDeclarationContext) IsClassBodyDeclarationContext() {}

func NewClassBodyDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int, t int) *ClassBodyDeclarationContext {
	var p = new(ClassBodyDeclarationContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_classBodyDeclaration

	p.t = t

	return p
}

func (s *ClassBodyDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassBodyDeclarationContext) GetT() int { return s.t }

func (s *ClassBodyDeclarationContext) SetT(v int) { s.t = v }

func (s *ClassBodyDeclarationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(GroovyParserSEMI, 0)
}

func (s *ClassBodyDeclarationContext) Block() IBlockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *ClassBodyDeclarationContext) STATIC() antlr.TerminalNode {
	return s.GetToken(GroovyParserSTATIC, 0)
}

func (s *ClassBodyDeclarationContext) Nls() INlsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INlsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *ClassBodyDeclarationContext) MemberDeclaration() IMemberDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMemberDeclarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMemberDeclarationContext)
}

func (s *ClassBodyDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassBodyDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassBodyDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterClassBodyDeclaration(s)
	}
}

func (s *ClassBodyDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitClassBodyDeclaration(s)
	}
}

func (p *GroovyParser) ClassBodyDeclaration(t int) (localctx IClassBodyDeclarationContext) {
	localctx = NewClassBodyDeclarationContext(p, p.GetParserRuleContext(), p.GetState(), t)
	p.EnterRule(localctx, 46, GroovyParserRULE_classBodyDeclaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(544)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 40, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(537)
			p.Match(GroovyParserSEMI)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(540)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == GroovyParserSTATIC {
			{
				p.SetState(538)
				p.Match(GroovyParserSTATIC)
			}
			{
				p.SetState(539)
				p.Nls()
			}

		}
		{
			p.SetState(542)
			p.Block()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(543)
			p.MemberDeclaration(localctx.(*ClassBodyDeclarationContext).t)
		}

	}

	return localctx
}

// IMemberDeclarationContext is an interface to support dynamic dispatch.
type IMemberDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetT returns the t attribute.
	GetT() int

	// SetT sets the t attribute.
	SetT(int)

	// IsMemberDeclarationContext differentiates from other interfaces.
	IsMemberDeclarationContext()
}

type MemberDeclarationContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
	t      int
}

func NewEmptyMemberDeclarationContext() *MemberDeclarationContext {
	var p = new(MemberDeclarationContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_memberDeclaration
	return p
}

func (*MemberDeclarationContext) IsMemberDeclarationContext() {}

func NewMemberDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int, t int) *MemberDeclarationContext {
	var p = new(MemberDeclarationContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_memberDeclaration

	p.t = t

	return p
}

func (s *MemberDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *MemberDeclarationContext) GetT() int { return s.t }

func (s *MemberDeclarationContext) SetT(v int) { s.t = v }

func (s *MemberDeclarationContext) MethodDeclaration() IMethodDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMethodDeclarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMethodDeclarationContext)
}

func (s *MemberDeclarationContext) FieldDeclaration() IFieldDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFieldDeclarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFieldDeclarationContext)
}

func (s *MemberDeclarationContext) ModifiersOpt() IModifiersOptContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModifiersOptContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModifiersOptContext)
}

func (s *MemberDeclarationContext) ClassDeclaration() IClassDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClassDeclarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClassDeclarationContext)
}

func (s *MemberDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MemberDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MemberDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterMemberDeclaration(s)
	}
}

func (s *MemberDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitMemberDeclaration(s)
	}
}

func (p *GroovyParser) MemberDeclaration(t int) (localctx IMemberDeclarationContext) {
	localctx = NewMemberDeclarationContext(p, p.GetParserRuleContext(), p.GetState(), t)
	p.EnterRule(localctx, 48, GroovyParserRULE_memberDeclaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(551)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 41, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(546)
			p.MethodDeclaration(0, localctx.(*MemberDeclarationContext).t)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(547)
			p.FieldDeclaration()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(548)
			p.ModifiersOpt()
		}
		{
			p.SetState(549)
			p.ClassDeclaration()
		}

	}

	return localctx
}

// IMethodDeclarationContext is an interface to support dynamic dispatch.
type IMethodDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetT returns the t attribute.
	GetT() int

	// GetCt returns the ct attribute.
	GetCt() int

	// SetT sets the t attribute.
	SetT(int)

	// SetCt sets the ct attribute.
	SetCt(int)

	// IsMethodDeclarationContext differentiates from other interfaces.
	IsMethodDeclarationContext()
}

type MethodDeclarationContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
	t      int
	ct     int
}

func NewEmptyMethodDeclarationContext() *MethodDeclarationContext {
	var p = new(MethodDeclarationContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_methodDeclaration
	return p
}

func (*MethodDeclarationContext) IsMethodDeclarationContext() {}

func NewMethodDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int, t int, ct int) *MethodDeclarationContext {
	var p = new(MethodDeclarationContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_methodDeclaration

	p.t = t
	p.ct = ct

	return p
}

func (s *MethodDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *MethodDeclarationContext) GetT() int { return s.t }

func (s *MethodDeclarationContext) GetCt() int { return s.ct }

func (s *MethodDeclarationContext) SetT(v int) { s.t = v }

func (s *MethodDeclarationContext) SetCt(v int) { s.ct = v }

func (s *MethodDeclarationContext) ReturnType() IReturnTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReturnTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReturnTypeContext)
}

func (s *MethodDeclarationContext) MethodName() IMethodNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMethodNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMethodNameContext)
}

func (s *MethodDeclarationContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(GroovyParserLPAREN, 0)
}

func (s *MethodDeclarationContext) Rparen() IRparenContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRparenContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRparenContext)
}

func (s *MethodDeclarationContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(GroovyParserDEFAULT, 0)
}

func (s *MethodDeclarationContext) AllNls() []INlsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INlsContext)(nil)).Elem())
	var tst = make([]INlsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INlsContext)
		}
	}

	return tst
}

func (s *MethodDeclarationContext) Nls(i int) INlsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INlsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *MethodDeclarationContext) ElementValue() IElementValueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IElementValueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IElementValueContext)
}

func (s *MethodDeclarationContext) ModifiersOpt() IModifiersOptContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModifiersOptContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModifiersOptContext)
}

func (s *MethodDeclarationContext) FormalParameters() IFormalParametersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFormalParametersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFormalParametersContext)
}

func (s *MethodDeclarationContext) TypeParameters() ITypeParametersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeParametersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeParametersContext)
}

func (s *MethodDeclarationContext) THROWS() antlr.TerminalNode {
	return s.GetToken(GroovyParserTHROWS, 0)
}

func (s *MethodDeclarationContext) QualifiedClassNameList() IQualifiedClassNameListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedClassNameListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedClassNameListContext)
}

func (s *MethodDeclarationContext) MethodBody() IMethodBodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMethodBodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMethodBodyContext)
}

func (s *MethodDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MethodDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MethodDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterMethodDeclaration(s)
	}
}

func (s *MethodDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitMethodDeclaration(s)
	}
}

func (p *GroovyParser) MethodDeclaration(t int, ct int) (localctx IMethodDeclarationContext) {
	localctx = NewMethodDeclarationContext(p, p.GetParserRuleContext(), p.GetState(), t, ct)
	p.EnterRule(localctx, 50, GroovyParserRULE_methodDeclaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(584)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 47, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(553)

		if !(3 == localctx.(*MethodDeclarationContext).ct) {
			panic(antlr.NewFailedPredicateException(p, " 3 == $ct ", ""))
		}
		{
			p.SetState(554)
			p.ReturnType(localctx.(*MethodDeclarationContext).ct)
		}
		{
			p.SetState(555)
			p.MethodName()
		}
		{
			p.SetState(556)
			p.Match(GroovyParserLPAREN)
		}
		{
			p.SetState(557)
			p.Rparen()
		}
		p.SetState(562)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 42, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(558)
				p.Match(GroovyParserDEFAULT)
			}
			{
				p.SetState(559)
				p.Nls()
			}
			{
				p.SetState(560)
				p.ElementValue()
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(564)
			p.ModifiersOpt()
		}
		p.SetState(566)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 43, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(565)
				p.TypeParameters()
			}

		}
		p.SetState(569)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 44, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(568)
				p.ReturnType(localctx.(*MethodDeclarationContext).ct)
			}

		}
		{
			p.SetState(571)
			p.MethodName()
		}
		{
			p.SetState(572)
			p.FormalParameters()
		}
		p.SetState(578)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 45, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(573)
				p.Nls()
			}
			{
				p.SetState(574)
				p.Match(GroovyParserTHROWS)
			}
			{
				p.SetState(575)
				p.Nls()
			}
			{
				p.SetState(576)
				p.QualifiedClassNameList()
			}

		}
		{
			p.SetState(580)
			p.Nls()
		}
		p.SetState(582)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == GroovyParserLBRACE {
			{
				p.SetState(581)
				p.MethodBody()
			}

		}

	}

	return localctx
}

// IMethodNameContext is an interface to support dynamic dispatch.
type IMethodNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMethodNameContext differentiates from other interfaces.
	IsMethodNameContext()
}

type MethodNameContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyMethodNameContext() *MethodNameContext {
	var p = new(MethodNameContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_methodName
	return p
}

func (*MethodNameContext) IsMethodNameContext() {}

func NewMethodNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MethodNameContext {
	var p = new(MethodNameContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_methodName

	return p
}

func (s *MethodNameContext) GetParser() antlr.Parser { return s.parser }

func (s *MethodNameContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *MethodNameContext) StringLiteral() IStringLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStringLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *MethodNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MethodNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MethodNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterMethodName(s)
	}
}

func (s *MethodNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitMethodName(s)
	}
}

func (p *GroovyParser) MethodName() (localctx IMethodNameContext) {
	localctx = NewMethodNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, GroovyParserRULE_methodName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(588)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 48, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(586)
			p.Identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(587)
			p.StringLiteral()
		}

	}

	return localctx
}

// IReturnTypeContext is an interface to support dynamic dispatch.
type IReturnTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetCt returns the ct attribute.
	GetCt() int

	// SetCt sets the ct attribute.
	SetCt(int)

	// IsReturnTypeContext differentiates from other interfaces.
	IsReturnTypeContext()
}

type ReturnTypeContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
	ct     int
}

func NewEmptyReturnTypeContext() *ReturnTypeContext {
	var p = new(ReturnTypeContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_returnType
	return p
}

func (*ReturnTypeContext) IsReturnTypeContext() {}

func NewReturnTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int, ct int) *ReturnTypeContext {
	var p = new(ReturnTypeContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_returnType

	p.ct = ct

	return p
}

func (s *ReturnTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ReturnTypeContext) GetCt() int { return s.ct }

func (s *ReturnTypeContext) SetCt(v int) { s.ct = v }

func (s *ReturnTypeContext) StandardType() IStandardTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStandardTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStandardTypeContext)
}

func (s *ReturnTypeContext) VOID() antlr.TerminalNode {
	return s.GetToken(GroovyParserVOID, 0)
}

func (s *ReturnTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReturnTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReturnTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterReturnType(s)
	}
}

func (s *ReturnTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitReturnType(s)
	}
}

func (p *GroovyParser) ReturnType(ct int) (localctx IReturnTypeContext) {
	localctx = NewReturnTypeContext(p, p.GetParserRuleContext(), p.GetState(), ct)
	p.EnterRule(localctx, 54, GroovyParserRULE_returnType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(593)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 49, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(590)
			p.StandardType()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(591)

		if !(3 != localctx.(*ReturnTypeContext).ct) {
			panic(antlr.NewFailedPredicateException(p, " 3 != $ct ", ""))
		}
		{
			p.SetState(592)
			p.Match(GroovyParserVOID)
		}

	}

	return localctx
}

// IFieldDeclarationContext is an interface to support dynamic dispatch.
type IFieldDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFieldDeclarationContext differentiates from other interfaces.
	IsFieldDeclarationContext()
}

type FieldDeclarationContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyFieldDeclarationContext() *FieldDeclarationContext {
	var p = new(FieldDeclarationContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_fieldDeclaration
	return p
}

func (*FieldDeclarationContext) IsFieldDeclarationContext() {}

func NewFieldDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FieldDeclarationContext {
	var p = new(FieldDeclarationContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_fieldDeclaration

	return p
}

func (s *FieldDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *FieldDeclarationContext) VariableDeclaration() IVariableDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableDeclarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariableDeclarationContext)
}

func (s *FieldDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FieldDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FieldDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterFieldDeclaration(s)
	}
}

func (s *FieldDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitFieldDeclaration(s)
	}
}

func (p *GroovyParser) FieldDeclaration() (localctx IFieldDeclarationContext) {
	localctx = NewFieldDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, GroovyParserRULE_fieldDeclaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(595)
		p.VariableDeclaration(1)
	}

	return localctx
}

// IVariableDeclaratorsContext is an interface to support dynamic dispatch.
type IVariableDeclaratorsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVariableDeclaratorsContext differentiates from other interfaces.
	IsVariableDeclaratorsContext()
}

type VariableDeclaratorsContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableDeclaratorsContext() *VariableDeclaratorsContext {
	var p = new(VariableDeclaratorsContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_variableDeclarators
	return p
}

func (*VariableDeclaratorsContext) IsVariableDeclaratorsContext() {}

func NewVariableDeclaratorsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableDeclaratorsContext {
	var p = new(VariableDeclaratorsContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_variableDeclarators

	return p
}

func (s *VariableDeclaratorsContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableDeclaratorsContext) AllVariableDeclarator() []IVariableDeclaratorContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IVariableDeclaratorContext)(nil)).Elem())
	var tst = make([]IVariableDeclaratorContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IVariableDeclaratorContext)
		}
	}

	return tst
}

func (s *VariableDeclaratorsContext) VariableDeclarator(i int) IVariableDeclaratorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableDeclaratorContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IVariableDeclaratorContext)
}

func (s *VariableDeclaratorsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(GroovyParserCOMMA)
}

func (s *VariableDeclaratorsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(GroovyParserCOMMA, i)
}

func (s *VariableDeclaratorsContext) AllNls() []INlsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INlsContext)(nil)).Elem())
	var tst = make([]INlsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INlsContext)
		}
	}

	return tst
}

func (s *VariableDeclaratorsContext) Nls(i int) INlsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INlsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *VariableDeclaratorsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableDeclaratorsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableDeclaratorsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterVariableDeclarators(s)
	}
}

func (s *VariableDeclaratorsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitVariableDeclarators(s)
	}
}

func (p *GroovyParser) VariableDeclarators() (localctx IVariableDeclaratorsContext) {
	localctx = NewVariableDeclaratorsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, GroovyParserRULE_variableDeclarators)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(597)
		p.VariableDeclarator()
	}
	p.SetState(604)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == GroovyParserCOMMA {
		{
			p.SetState(598)
			p.Match(GroovyParserCOMMA)
		}
		{
			p.SetState(599)
			p.Nls()
		}
		{
			p.SetState(600)
			p.VariableDeclarator()
		}

		p.SetState(606)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IVariableDeclaratorContext is an interface to support dynamic dispatch.
type IVariableDeclaratorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVariableDeclaratorContext differentiates from other interfaces.
	IsVariableDeclaratorContext()
}

type VariableDeclaratorContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableDeclaratorContext() *VariableDeclaratorContext {
	var p = new(VariableDeclaratorContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_variableDeclarator
	return p
}

func (*VariableDeclaratorContext) IsVariableDeclaratorContext() {}

func NewVariableDeclaratorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableDeclaratorContext {
	var p = new(VariableDeclaratorContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_variableDeclarator

	return p
}

func (s *VariableDeclaratorContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableDeclaratorContext) VariableDeclaratorId() IVariableDeclaratorIdContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableDeclaratorIdContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariableDeclaratorIdContext)
}

func (s *VariableDeclaratorContext) AllNls() []INlsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INlsContext)(nil)).Elem())
	var tst = make([]INlsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INlsContext)
		}
	}

	return tst
}

func (s *VariableDeclaratorContext) Nls(i int) INlsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INlsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *VariableDeclaratorContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(GroovyParserASSIGN, 0)
}

func (s *VariableDeclaratorContext) VariableInitializer() IVariableInitializerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableInitializerContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariableInitializerContext)
}

func (s *VariableDeclaratorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableDeclaratorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableDeclaratorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterVariableDeclarator(s)
	}
}

func (s *VariableDeclaratorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitVariableDeclarator(s)
	}
}

func (p *GroovyParser) VariableDeclarator() (localctx IVariableDeclaratorContext) {
	localctx = NewVariableDeclaratorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, GroovyParserRULE_variableDeclarator)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(607)
		p.VariableDeclaratorId()
	}
	p.SetState(613)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 51, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(608)
			p.Nls()
		}
		{
			p.SetState(609)
			p.Match(GroovyParserASSIGN)
		}
		{
			p.SetState(610)
			p.Nls()
		}
		{
			p.SetState(611)
			p.VariableInitializer()
		}

	}

	return localctx
}

// IVariableDeclaratorIdContext is an interface to support dynamic dispatch.
type IVariableDeclaratorIdContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVariableDeclaratorIdContext differentiates from other interfaces.
	IsVariableDeclaratorIdContext()
}

type VariableDeclaratorIdContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableDeclaratorIdContext() *VariableDeclaratorIdContext {
	var p = new(VariableDeclaratorIdContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_variableDeclaratorId
	return p
}

func (*VariableDeclaratorIdContext) IsVariableDeclaratorIdContext() {}

func NewVariableDeclaratorIdContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableDeclaratorIdContext {
	var p = new(VariableDeclaratorIdContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_variableDeclaratorId

	return p
}

func (s *VariableDeclaratorIdContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableDeclaratorIdContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *VariableDeclaratorIdContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableDeclaratorIdContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableDeclaratorIdContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterVariableDeclaratorId(s)
	}
}

func (s *VariableDeclaratorIdContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitVariableDeclaratorId(s)
	}
}

func (p *GroovyParser) VariableDeclaratorId() (localctx IVariableDeclaratorIdContext) {
	localctx = NewVariableDeclaratorIdContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, GroovyParserRULE_variableDeclaratorId)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(615)
		p.Identifier()
	}

	return localctx
}

// IVariableInitializerContext is an interface to support dynamic dispatch.
type IVariableInitializerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVariableInitializerContext differentiates from other interfaces.
	IsVariableInitializerContext()
}

type VariableInitializerContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableInitializerContext() *VariableInitializerContext {
	var p = new(VariableInitializerContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_variableInitializer
	return p
}

func (*VariableInitializerContext) IsVariableInitializerContext() {}

func NewVariableInitializerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableInitializerContext {
	var p = new(VariableInitializerContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_variableInitializer

	return p
}

func (s *VariableInitializerContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableInitializerContext) EnhancedStatementExpression() IEnhancedStatementExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnhancedStatementExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEnhancedStatementExpressionContext)
}

func (s *VariableInitializerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableInitializerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableInitializerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterVariableInitializer(s)
	}
}

func (s *VariableInitializerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitVariableInitializer(s)
	}
}

func (p *GroovyParser) VariableInitializer() (localctx IVariableInitializerContext) {
	localctx = NewVariableInitializerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, GroovyParserRULE_variableInitializer)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(617)
		p.EnhancedStatementExpression()
	}

	return localctx
}

// IVariableInitializersContext is an interface to support dynamic dispatch.
type IVariableInitializersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVariableInitializersContext differentiates from other interfaces.
	IsVariableInitializersContext()
}

type VariableInitializersContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableInitializersContext() *VariableInitializersContext {
	var p = new(VariableInitializersContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_variableInitializers
	return p
}

func (*VariableInitializersContext) IsVariableInitializersContext() {}

func NewVariableInitializersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableInitializersContext {
	var p = new(VariableInitializersContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_variableInitializers

	return p
}

func (s *VariableInitializersContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableInitializersContext) AllVariableInitializer() []IVariableInitializerContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IVariableInitializerContext)(nil)).Elem())
	var tst = make([]IVariableInitializerContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IVariableInitializerContext)
		}
	}

	return tst
}

func (s *VariableInitializersContext) VariableInitializer(i int) IVariableInitializerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableInitializerContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IVariableInitializerContext)
}

func (s *VariableInitializersContext) AllNls() []INlsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INlsContext)(nil)).Elem())
	var tst = make([]INlsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INlsContext)
		}
	}

	return tst
}

func (s *VariableInitializersContext) Nls(i int) INlsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INlsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *VariableInitializersContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(GroovyParserCOMMA)
}

func (s *VariableInitializersContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(GroovyParserCOMMA, i)
}

func (s *VariableInitializersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableInitializersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableInitializersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterVariableInitializers(s)
	}
}

func (s *VariableInitializersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitVariableInitializers(s)
	}
}

func (p *GroovyParser) VariableInitializers() (localctx IVariableInitializersContext) {
	localctx = NewVariableInitializersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, GroovyParserRULE_variableInitializers)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(619)
		p.VariableInitializer()
	}
	{
		p.SetState(620)
		p.Nls()
	}
	p.SetState(628)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 52, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(621)
				p.Match(GroovyParserCOMMA)
			}
			{
				p.SetState(622)
				p.Nls()
			}
			{
				p.SetState(623)
				p.VariableInitializer()
			}
			{
				p.SetState(624)
				p.Nls()
			}

		}
		p.SetState(630)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 52, p.GetParserRuleContext())
	}
	{
		p.SetState(631)
		p.Nls()
	}
	p.SetState(633)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == GroovyParserCOMMA {
		{
			p.SetState(632)
			p.Match(GroovyParserCOMMA)
		}

	}

	return localctx
}

// IDimsContext is an interface to support dynamic dispatch.
type IDimsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDimsContext differentiates from other interfaces.
	IsDimsContext()
}

type DimsContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyDimsContext() *DimsContext {
	var p = new(DimsContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_dims
	return p
}

func (*DimsContext) IsDimsContext() {}

func NewDimsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DimsContext {
	var p = new(DimsContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_dims

	return p
}

func (s *DimsContext) GetParser() antlr.Parser { return s.parser }

func (s *DimsContext) AllAnnotationsOpt() []IAnnotationsOptContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAnnotationsOptContext)(nil)).Elem())
	var tst = make([]IAnnotationsOptContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAnnotationsOptContext)
		}
	}

	return tst
}

func (s *DimsContext) AnnotationsOpt(i int) IAnnotationsOptContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotationsOptContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAnnotationsOptContext)
}

func (s *DimsContext) AllLBRACK() []antlr.TerminalNode {
	return s.GetTokens(GroovyParserLBRACK)
}

func (s *DimsContext) LBRACK(i int) antlr.TerminalNode {
	return s.GetToken(GroovyParserLBRACK, i)
}

func (s *DimsContext) AllRBRACK() []antlr.TerminalNode {
	return s.GetTokens(GroovyParserRBRACK)
}

func (s *DimsContext) RBRACK(i int) antlr.TerminalNode {
	return s.GetToken(GroovyParserRBRACK, i)
}

func (s *DimsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DimsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DimsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterDims(s)
	}
}

func (s *DimsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitDims(s)
	}
}

func (p *GroovyParser) Dims() (localctx IDimsContext) {
	localctx = NewDimsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, GroovyParserRULE_dims)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(639)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(635)
				p.AnnotationsOpt()
			}
			{
				p.SetState(636)
				p.Match(GroovyParserLBRACK)
			}
			{
				p.SetState(637)
				p.Match(GroovyParserRBRACK)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(641)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 54, p.GetParserRuleContext())
	}

	return localctx
}

// IDimsOptContext is an interface to support dynamic dispatch.
type IDimsOptContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDimsOptContext differentiates from other interfaces.
	IsDimsOptContext()
}

type DimsOptContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyDimsOptContext() *DimsOptContext {
	var p = new(DimsOptContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_dimsOpt
	return p
}

func (*DimsOptContext) IsDimsOptContext() {}

func NewDimsOptContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DimsOptContext {
	var p = new(DimsOptContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_dimsOpt

	return p
}

func (s *DimsOptContext) GetParser() antlr.Parser { return s.parser }

func (s *DimsOptContext) Dims() IDimsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDimsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDimsContext)
}

func (s *DimsOptContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DimsOptContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DimsOptContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterDimsOpt(s)
	}
}

func (s *DimsOptContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitDimsOpt(s)
	}
}

func (p *GroovyParser) DimsOpt() (localctx IDimsOptContext) {
	localctx = NewDimsOptContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, GroovyParserRULE_dimsOpt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(644)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 55, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(643)
			p.Dims()
		}

	}

	return localctx
}

// IStandardTypeContext is an interface to support dynamic dispatch.
type IStandardTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStandardTypeContext differentiates from other interfaces.
	IsStandardTypeContext()
}

type StandardTypeContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyStandardTypeContext() *StandardTypeContext {
	var p = new(StandardTypeContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_standardType
	return p
}

func (*StandardTypeContext) IsStandardTypeContext() {}

func NewStandardTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StandardTypeContext {
	var p = new(StandardTypeContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_standardType

	return p
}

func (s *StandardTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *StandardTypeContext) AnnotationsOpt() IAnnotationsOptContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotationsOptContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAnnotationsOptContext)
}

func (s *StandardTypeContext) DimsOpt() IDimsOptContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDimsOptContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDimsOptContext)
}

func (s *StandardTypeContext) PrimitiveType() IPrimitiveTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrimitiveTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPrimitiveTypeContext)
}

func (s *StandardTypeContext) StandardClassOrInterfaceType() IStandardClassOrInterfaceTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStandardClassOrInterfaceTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStandardClassOrInterfaceTypeContext)
}

func (s *StandardTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StandardTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StandardTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterStandardType(s)
	}
}

func (s *StandardTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitStandardType(s)
	}
}

func (p *GroovyParser) StandardType() (localctx IStandardTypeContext) {
	localctx = NewStandardTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, GroovyParserRULE_standardType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(646)
		p.AnnotationsOpt()
	}
	p.SetState(649)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 56, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(647)
			p.PrimitiveType()
		}

	case 2:
		{
			p.SetState(648)
			p.StandardClassOrInterfaceType()
		}

	}
	{
		p.SetState(651)
		p.DimsOpt()
	}

	return localctx
}

// ITypeTypeContext is an interface to support dynamic dispatch.
type ITypeTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeTypeContext differentiates from other interfaces.
	IsTypeTypeContext()
}

type TypeTypeContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeTypeContext() *TypeTypeContext {
	var p = new(TypeTypeContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_typeType
	return p
}

func (*TypeTypeContext) IsTypeTypeContext() {}

func NewTypeTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeTypeContext {
	var p = new(TypeTypeContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_typeType

	return p
}

func (s *TypeTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeTypeContext) AnnotationsOpt() IAnnotationsOptContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotationsOptContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAnnotationsOptContext)
}

func (s *TypeTypeContext) DimsOpt() IDimsOptContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDimsOptContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDimsOptContext)
}

func (s *TypeTypeContext) GeneralClassOrInterfaceType() IGeneralClassOrInterfaceTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGeneralClassOrInterfaceTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGeneralClassOrInterfaceTypeContext)
}

func (s *TypeTypeContext) PrimitiveType() IPrimitiveTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrimitiveTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPrimitiveTypeContext)
}

func (s *TypeTypeContext) VOID() antlr.TerminalNode {
	return s.GetToken(GroovyParserVOID, 0)
}

func (s *TypeTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterTypeType(s)
	}
}

func (s *TypeTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitTypeType(s)
	}
}

func (p *GroovyParser) TypeType() (localctx ITypeTypeContext) {
	localctx = NewTypeTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, GroovyParserRULE_typeType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(653)
		p.AnnotationsOpt()
	}
	p.SetState(659)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 58, p.GetParserRuleContext()) {
	case 1:
		p.SetState(656)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case GroovyParserBuiltInPrimitiveType:
			{
				p.SetState(654)
				p.PrimitiveType()
			}

		case GroovyParserVOID:
			{
				p.SetState(655)
				p.Match(GroovyParserVOID)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	case 2:
		{
			p.SetState(658)
			p.GeneralClassOrInterfaceType()
		}

	}
	{
		p.SetState(661)
		p.DimsOpt()
	}

	return localctx
}

// IClassOrInterfaceTypeContext is an interface to support dynamic dispatch.
type IClassOrInterfaceTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClassOrInterfaceTypeContext differentiates from other interfaces.
	IsClassOrInterfaceTypeContext()
}

type ClassOrInterfaceTypeContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassOrInterfaceTypeContext() *ClassOrInterfaceTypeContext {
	var p = new(ClassOrInterfaceTypeContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_classOrInterfaceType
	return p
}

func (*ClassOrInterfaceTypeContext) IsClassOrInterfaceTypeContext() {}

func NewClassOrInterfaceTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassOrInterfaceTypeContext {
	var p = new(ClassOrInterfaceTypeContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_classOrInterfaceType

	return p
}

func (s *ClassOrInterfaceTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassOrInterfaceTypeContext) QualifiedClassName() IQualifiedClassNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedClassNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedClassNameContext)
}

func (s *ClassOrInterfaceTypeContext) QualifiedStandardClassName() IQualifiedStandardClassNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedStandardClassNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedStandardClassNameContext)
}

func (s *ClassOrInterfaceTypeContext) TypeArguments() ITypeArgumentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeArgumentsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeArgumentsContext)
}

func (s *ClassOrInterfaceTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassOrInterfaceTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassOrInterfaceTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterClassOrInterfaceType(s)
	}
}

func (s *ClassOrInterfaceTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitClassOrInterfaceType(s)
	}
}

func (p *GroovyParser) ClassOrInterfaceType() (localctx IClassOrInterfaceTypeContext) {
	localctx = NewClassOrInterfaceTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, GroovyParserRULE_classOrInterfaceType)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(665)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 59, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(663)
			p.QualifiedClassName()
		}

	case 2:
		{
			p.SetState(664)
			p.QualifiedStandardClassName()
		}

	}
	p.SetState(668)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == GroovyParserLT {
		{
			p.SetState(667)
			p.TypeArguments()
		}

	}

	return localctx
}

// IGeneralClassOrInterfaceTypeContext is an interface to support dynamic dispatch.
type IGeneralClassOrInterfaceTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGeneralClassOrInterfaceTypeContext differentiates from other interfaces.
	IsGeneralClassOrInterfaceTypeContext()
}

type GeneralClassOrInterfaceTypeContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyGeneralClassOrInterfaceTypeContext() *GeneralClassOrInterfaceTypeContext {
	var p = new(GeneralClassOrInterfaceTypeContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_generalClassOrInterfaceType
	return p
}

func (*GeneralClassOrInterfaceTypeContext) IsGeneralClassOrInterfaceTypeContext() {}

func NewGeneralClassOrInterfaceTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GeneralClassOrInterfaceTypeContext {
	var p = new(GeneralClassOrInterfaceTypeContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_generalClassOrInterfaceType

	return p
}

func (s *GeneralClassOrInterfaceTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *GeneralClassOrInterfaceTypeContext) QualifiedClassName() IQualifiedClassNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedClassNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedClassNameContext)
}

func (s *GeneralClassOrInterfaceTypeContext) TypeArguments() ITypeArgumentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeArgumentsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeArgumentsContext)
}

func (s *GeneralClassOrInterfaceTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GeneralClassOrInterfaceTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GeneralClassOrInterfaceTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterGeneralClassOrInterfaceType(s)
	}
}

func (s *GeneralClassOrInterfaceTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitGeneralClassOrInterfaceType(s)
	}
}

func (p *GroovyParser) GeneralClassOrInterfaceType() (localctx IGeneralClassOrInterfaceTypeContext) {
	localctx = NewGeneralClassOrInterfaceTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, GroovyParserRULE_generalClassOrInterfaceType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(670)
		p.QualifiedClassName()
	}
	p.SetState(672)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 61, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(671)
			p.TypeArguments()
		}

	}

	return localctx
}

// IStandardClassOrInterfaceTypeContext is an interface to support dynamic dispatch.
type IStandardClassOrInterfaceTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStandardClassOrInterfaceTypeContext differentiates from other interfaces.
	IsStandardClassOrInterfaceTypeContext()
}

type StandardClassOrInterfaceTypeContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyStandardClassOrInterfaceTypeContext() *StandardClassOrInterfaceTypeContext {
	var p = new(StandardClassOrInterfaceTypeContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_standardClassOrInterfaceType
	return p
}

func (*StandardClassOrInterfaceTypeContext) IsStandardClassOrInterfaceTypeContext() {}

func NewStandardClassOrInterfaceTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StandardClassOrInterfaceTypeContext {
	var p = new(StandardClassOrInterfaceTypeContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_standardClassOrInterfaceType

	return p
}

func (s *StandardClassOrInterfaceTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *StandardClassOrInterfaceTypeContext) QualifiedStandardClassName() IQualifiedStandardClassNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedStandardClassNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedStandardClassNameContext)
}

func (s *StandardClassOrInterfaceTypeContext) TypeArguments() ITypeArgumentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeArgumentsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeArgumentsContext)
}

func (s *StandardClassOrInterfaceTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StandardClassOrInterfaceTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StandardClassOrInterfaceTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterStandardClassOrInterfaceType(s)
	}
}

func (s *StandardClassOrInterfaceTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitStandardClassOrInterfaceType(s)
	}
}

func (p *GroovyParser) StandardClassOrInterfaceType() (localctx IStandardClassOrInterfaceTypeContext) {
	localctx = NewStandardClassOrInterfaceTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, GroovyParserRULE_standardClassOrInterfaceType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(674)
		p.QualifiedStandardClassName()
	}
	p.SetState(676)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 62, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(675)
			p.TypeArguments()
		}

	}

	return localctx
}

// IPrimitiveTypeContext is an interface to support dynamic dispatch.
type IPrimitiveTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPrimitiveTypeContext differentiates from other interfaces.
	IsPrimitiveTypeContext()
}

type PrimitiveTypeContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrimitiveTypeContext() *PrimitiveTypeContext {
	var p = new(PrimitiveTypeContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_primitiveType
	return p
}

func (*PrimitiveTypeContext) IsPrimitiveTypeContext() {}

func NewPrimitiveTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrimitiveTypeContext {
	var p = new(PrimitiveTypeContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_primitiveType

	return p
}

func (s *PrimitiveTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *PrimitiveTypeContext) BuiltInPrimitiveType() antlr.TerminalNode {
	return s.GetToken(GroovyParserBuiltInPrimitiveType, 0)
}

func (s *PrimitiveTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimitiveTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrimitiveTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterPrimitiveType(s)
	}
}

func (s *PrimitiveTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitPrimitiveType(s)
	}
}

func (p *GroovyParser) PrimitiveType() (localctx IPrimitiveTypeContext) {
	localctx = NewPrimitiveTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, GroovyParserRULE_primitiveType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(678)
		p.Match(GroovyParserBuiltInPrimitiveType)
	}

	return localctx
}

// ITypeArgumentsContext is an interface to support dynamic dispatch.
type ITypeArgumentsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeArgumentsContext differentiates from other interfaces.
	IsTypeArgumentsContext()
}

type TypeArgumentsContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeArgumentsContext() *TypeArgumentsContext {
	var p = new(TypeArgumentsContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_typeArguments
	return p
}

func (*TypeArgumentsContext) IsTypeArgumentsContext() {}

func NewTypeArgumentsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeArgumentsContext {
	var p = new(TypeArgumentsContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_typeArguments

	return p
}

func (s *TypeArgumentsContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeArgumentsContext) LT() antlr.TerminalNode {
	return s.GetToken(GroovyParserLT, 0)
}

func (s *TypeArgumentsContext) AllNls() []INlsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INlsContext)(nil)).Elem())
	var tst = make([]INlsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INlsContext)
		}
	}

	return tst
}

func (s *TypeArgumentsContext) Nls(i int) INlsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INlsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *TypeArgumentsContext) AllTypeArgument() []ITypeArgumentContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITypeArgumentContext)(nil)).Elem())
	var tst = make([]ITypeArgumentContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITypeArgumentContext)
		}
	}

	return tst
}

func (s *TypeArgumentsContext) TypeArgument(i int) ITypeArgumentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeArgumentContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITypeArgumentContext)
}

func (s *TypeArgumentsContext) GT() antlr.TerminalNode {
	return s.GetToken(GroovyParserGT, 0)
}

func (s *TypeArgumentsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(GroovyParserCOMMA)
}

func (s *TypeArgumentsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(GroovyParserCOMMA, i)
}

func (s *TypeArgumentsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeArgumentsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeArgumentsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterTypeArguments(s)
	}
}

func (s *TypeArgumentsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitTypeArguments(s)
	}
}

func (p *GroovyParser) TypeArguments() (localctx ITypeArgumentsContext) {
	localctx = NewTypeArgumentsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, GroovyParserRULE_typeArguments)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(680)
		p.Match(GroovyParserLT)
	}
	{
		p.SetState(681)
		p.Nls()
	}
	{
		p.SetState(682)
		p.TypeArgument()
	}
	p.SetState(689)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == GroovyParserCOMMA {
		{
			p.SetState(683)
			p.Match(GroovyParserCOMMA)
		}
		{
			p.SetState(684)
			p.Nls()
		}
		{
			p.SetState(685)
			p.TypeArgument()
		}

		p.SetState(691)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(692)
		p.Nls()
	}
	{
		p.SetState(693)
		p.Match(GroovyParserGT)
	}

	return localctx
}

// ITypeArgumentContext is an interface to support dynamic dispatch.
type ITypeArgumentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeArgumentContext differentiates from other interfaces.
	IsTypeArgumentContext()
}

type TypeArgumentContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeArgumentContext() *TypeArgumentContext {
	var p = new(TypeArgumentContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_typeArgument
	return p
}

func (*TypeArgumentContext) IsTypeArgumentContext() {}

func NewTypeArgumentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeArgumentContext {
	var p = new(TypeArgumentContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_typeArgument

	return p
}

func (s *TypeArgumentContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeArgumentContext) TypeType() ITypeTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeTypeContext)
}

func (s *TypeArgumentContext) AnnotationsOpt() IAnnotationsOptContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotationsOptContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAnnotationsOptContext)
}

func (s *TypeArgumentContext) QUESTION() antlr.TerminalNode {
	return s.GetToken(GroovyParserQUESTION, 0)
}

func (s *TypeArgumentContext) Nls() INlsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INlsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *TypeArgumentContext) EXTENDS() antlr.TerminalNode {
	return s.GetToken(GroovyParserEXTENDS, 0)
}

func (s *TypeArgumentContext) SUPER() antlr.TerminalNode {
	return s.GetToken(GroovyParserSUPER, 0)
}

func (s *TypeArgumentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeArgumentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeArgumentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterTypeArgument(s)
	}
}

func (s *TypeArgumentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitTypeArgument(s)
	}
}

func (p *GroovyParser) TypeArgument() (localctx ITypeArgumentContext) {
	localctx = NewTypeArgumentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, GroovyParserRULE_typeArgument)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(704)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 65, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(695)
			p.TypeType()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(696)
			p.AnnotationsOpt()
		}
		{
			p.SetState(697)
			p.Match(GroovyParserQUESTION)
		}
		p.SetState(702)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == GroovyParserEXTENDS || _la == GroovyParserSUPER {
			{
				p.SetState(698)
				_la = p.GetTokenStream().LA(1)

				if !(_la == GroovyParserEXTENDS || _la == GroovyParserSUPER) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(699)
				p.Nls()
			}
			{
				p.SetState(700)
				p.TypeType()
			}

		}

	}

	return localctx
}

// IAnnotatedQualifiedClassNameContext is an interface to support dynamic dispatch.
type IAnnotatedQualifiedClassNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAnnotatedQualifiedClassNameContext differentiates from other interfaces.
	IsAnnotatedQualifiedClassNameContext()
}

type AnnotatedQualifiedClassNameContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnnotatedQualifiedClassNameContext() *AnnotatedQualifiedClassNameContext {
	var p = new(AnnotatedQualifiedClassNameContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_annotatedQualifiedClassName
	return p
}

func (*AnnotatedQualifiedClassNameContext) IsAnnotatedQualifiedClassNameContext() {}

func NewAnnotatedQualifiedClassNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnnotatedQualifiedClassNameContext {
	var p = new(AnnotatedQualifiedClassNameContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_annotatedQualifiedClassName

	return p
}

func (s *AnnotatedQualifiedClassNameContext) GetParser() antlr.Parser { return s.parser }

func (s *AnnotatedQualifiedClassNameContext) AnnotationsOpt() IAnnotationsOptContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotationsOptContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAnnotationsOptContext)
}

func (s *AnnotatedQualifiedClassNameContext) QualifiedClassName() IQualifiedClassNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedClassNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedClassNameContext)
}

func (s *AnnotatedQualifiedClassNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnnotatedQualifiedClassNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AnnotatedQualifiedClassNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterAnnotatedQualifiedClassName(s)
	}
}

func (s *AnnotatedQualifiedClassNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitAnnotatedQualifiedClassName(s)
	}
}

func (p *GroovyParser) AnnotatedQualifiedClassName() (localctx IAnnotatedQualifiedClassNameContext) {
	localctx = NewAnnotatedQualifiedClassNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, GroovyParserRULE_annotatedQualifiedClassName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(706)
		p.AnnotationsOpt()
	}
	{
		p.SetState(707)
		p.QualifiedClassName()
	}

	return localctx
}

// IQualifiedClassNameListContext is an interface to support dynamic dispatch.
type IQualifiedClassNameListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsQualifiedClassNameListContext differentiates from other interfaces.
	IsQualifiedClassNameListContext()
}

type QualifiedClassNameListContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyQualifiedClassNameListContext() *QualifiedClassNameListContext {
	var p = new(QualifiedClassNameListContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_qualifiedClassNameList
	return p
}

func (*QualifiedClassNameListContext) IsQualifiedClassNameListContext() {}

func NewQualifiedClassNameListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QualifiedClassNameListContext {
	var p = new(QualifiedClassNameListContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_qualifiedClassNameList

	return p
}

func (s *QualifiedClassNameListContext) GetParser() antlr.Parser { return s.parser }

func (s *QualifiedClassNameListContext) AllAnnotatedQualifiedClassName() []IAnnotatedQualifiedClassNameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAnnotatedQualifiedClassNameContext)(nil)).Elem())
	var tst = make([]IAnnotatedQualifiedClassNameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAnnotatedQualifiedClassNameContext)
		}
	}

	return tst
}

func (s *QualifiedClassNameListContext) AnnotatedQualifiedClassName(i int) IAnnotatedQualifiedClassNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotatedQualifiedClassNameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAnnotatedQualifiedClassNameContext)
}

func (s *QualifiedClassNameListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(GroovyParserCOMMA)
}

func (s *QualifiedClassNameListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(GroovyParserCOMMA, i)
}

func (s *QualifiedClassNameListContext) AllNls() []INlsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INlsContext)(nil)).Elem())
	var tst = make([]INlsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INlsContext)
		}
	}

	return tst
}

func (s *QualifiedClassNameListContext) Nls(i int) INlsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INlsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *QualifiedClassNameListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QualifiedClassNameListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QualifiedClassNameListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterQualifiedClassNameList(s)
	}
}

func (s *QualifiedClassNameListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitQualifiedClassNameList(s)
	}
}

func (p *GroovyParser) QualifiedClassNameList() (localctx IQualifiedClassNameListContext) {
	localctx = NewQualifiedClassNameListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, GroovyParserRULE_qualifiedClassNameList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(709)
		p.AnnotatedQualifiedClassName()
	}
	p.SetState(716)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == GroovyParserCOMMA {
		{
			p.SetState(710)
			p.Match(GroovyParserCOMMA)
		}
		{
			p.SetState(711)
			p.Nls()
		}
		{
			p.SetState(712)
			p.AnnotatedQualifiedClassName()
		}

		p.SetState(718)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IFormalParametersContext is an interface to support dynamic dispatch.
type IFormalParametersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFormalParametersContext differentiates from other interfaces.
	IsFormalParametersContext()
}

type FormalParametersContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyFormalParametersContext() *FormalParametersContext {
	var p = new(FormalParametersContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_formalParameters
	return p
}

func (*FormalParametersContext) IsFormalParametersContext() {}

func NewFormalParametersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FormalParametersContext {
	var p = new(FormalParametersContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_formalParameters

	return p
}

func (s *FormalParametersContext) GetParser() antlr.Parser { return s.parser }

func (s *FormalParametersContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(GroovyParserLPAREN, 0)
}

func (s *FormalParametersContext) Rparen() IRparenContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRparenContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRparenContext)
}

func (s *FormalParametersContext) FormalParameterList() IFormalParameterListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFormalParameterListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFormalParameterListContext)
}

func (s *FormalParametersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FormalParametersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FormalParametersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterFormalParameters(s)
	}
}

func (s *FormalParametersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitFormalParameters(s)
	}
}

func (p *GroovyParser) FormalParameters() (localctx IFormalParametersContext) {
	localctx = NewFormalParametersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, GroovyParserRULE_formalParameters)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(719)
		p.Match(GroovyParserLPAREN)
	}
	p.SetState(721)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 67, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(720)
			p.FormalParameterList()
		}

	}
	{
		p.SetState(723)
		p.Rparen()
	}

	return localctx
}

// IFormalParameterListContext is an interface to support dynamic dispatch.
type IFormalParameterListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFormalParameterListContext differentiates from other interfaces.
	IsFormalParameterListContext()
}

type FormalParameterListContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyFormalParameterListContext() *FormalParameterListContext {
	var p = new(FormalParameterListContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_formalParameterList
	return p
}

func (*FormalParameterListContext) IsFormalParameterListContext() {}

func NewFormalParameterListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FormalParameterListContext {
	var p = new(FormalParameterListContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_formalParameterList

	return p
}

func (s *FormalParameterListContext) GetParser() antlr.Parser { return s.parser }

func (s *FormalParameterListContext) AllFormalParameter() []IFormalParameterContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFormalParameterContext)(nil)).Elem())
	var tst = make([]IFormalParameterContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFormalParameterContext)
		}
	}

	return tst
}

func (s *FormalParameterListContext) FormalParameter(i int) IFormalParameterContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFormalParameterContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFormalParameterContext)
}

func (s *FormalParameterListContext) ThisFormalParameter() IThisFormalParameterContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IThisFormalParameterContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IThisFormalParameterContext)
}

func (s *FormalParameterListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(GroovyParserCOMMA)
}

func (s *FormalParameterListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(GroovyParserCOMMA, i)
}

func (s *FormalParameterListContext) AllNls() []INlsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INlsContext)(nil)).Elem())
	var tst = make([]INlsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INlsContext)
		}
	}

	return tst
}

func (s *FormalParameterListContext) Nls(i int) INlsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INlsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *FormalParameterListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FormalParameterListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FormalParameterListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterFormalParameterList(s)
	}
}

func (s *FormalParameterListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitFormalParameterList(s)
	}
}

func (p *GroovyParser) FormalParameterList() (localctx IFormalParameterListContext) {
	localctx = NewFormalParameterListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, GroovyParserRULE_formalParameterList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(727)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 68, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(725)
			p.FormalParameter()
		}

	case 2:
		{
			p.SetState(726)
			p.ThisFormalParameter()
		}

	}
	p.SetState(735)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == GroovyParserCOMMA {
		{
			p.SetState(729)
			p.Match(GroovyParserCOMMA)
		}
		{
			p.SetState(730)
			p.Nls()
		}
		{
			p.SetState(731)
			p.FormalParameter()
		}

		p.SetState(737)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IThisFormalParameterContext is an interface to support dynamic dispatch.
type IThisFormalParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsThisFormalParameterContext differentiates from other interfaces.
	IsThisFormalParameterContext()
}

type ThisFormalParameterContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyThisFormalParameterContext() *ThisFormalParameterContext {
	var p = new(ThisFormalParameterContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_thisFormalParameter
	return p
}

func (*ThisFormalParameterContext) IsThisFormalParameterContext() {}

func NewThisFormalParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ThisFormalParameterContext {
	var p = new(ThisFormalParameterContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_thisFormalParameter

	return p
}

func (s *ThisFormalParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *ThisFormalParameterContext) TypeType() ITypeTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeTypeContext)
}

func (s *ThisFormalParameterContext) THIS() antlr.TerminalNode {
	return s.GetToken(GroovyParserTHIS, 0)
}

func (s *ThisFormalParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ThisFormalParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ThisFormalParameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterThisFormalParameter(s)
	}
}

func (s *ThisFormalParameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitThisFormalParameter(s)
	}
}

func (p *GroovyParser) ThisFormalParameter() (localctx IThisFormalParameterContext) {
	localctx = NewThisFormalParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, GroovyParserRULE_thisFormalParameter)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(738)
		p.TypeType()
	}
	{
		p.SetState(739)
		p.Match(GroovyParserTHIS)
	}

	return localctx
}

// IFormalParameterContext is an interface to support dynamic dispatch.
type IFormalParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFormalParameterContext differentiates from other interfaces.
	IsFormalParameterContext()
}

type FormalParameterContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyFormalParameterContext() *FormalParameterContext {
	var p = new(FormalParameterContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_formalParameter
	return p
}

func (*FormalParameterContext) IsFormalParameterContext() {}

func NewFormalParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FormalParameterContext {
	var p = new(FormalParameterContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_formalParameter

	return p
}

func (s *FormalParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *FormalParameterContext) VariableModifiersOpt() IVariableModifiersOptContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableModifiersOptContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariableModifiersOptContext)
}

func (s *FormalParameterContext) VariableDeclaratorId() IVariableDeclaratorIdContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableDeclaratorIdContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariableDeclaratorIdContext)
}

func (s *FormalParameterContext) TypeType() ITypeTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeTypeContext)
}

func (s *FormalParameterContext) ELLIPSIS() antlr.TerminalNode {
	return s.GetToken(GroovyParserELLIPSIS, 0)
}

func (s *FormalParameterContext) AllNls() []INlsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INlsContext)(nil)).Elem())
	var tst = make([]INlsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INlsContext)
		}
	}

	return tst
}

func (s *FormalParameterContext) Nls(i int) INlsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INlsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *FormalParameterContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(GroovyParserASSIGN, 0)
}

func (s *FormalParameterContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *FormalParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FormalParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FormalParameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterFormalParameter(s)
	}
}

func (s *FormalParameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitFormalParameter(s)
	}
}

func (p *GroovyParser) FormalParameter() (localctx IFormalParameterContext) {
	localctx = NewFormalParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, GroovyParserRULE_formalParameter)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(741)
		p.VariableModifiersOpt()
	}
	p.SetState(743)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 70, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(742)
			p.TypeType()
		}

	}
	p.SetState(746)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 71, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(745)
			p.Match(GroovyParserELLIPSIS)
		}

	}
	{
		p.SetState(748)
		p.VariableDeclaratorId()
	}
	p.SetState(754)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 72, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(749)
			p.Nls()
		}
		{
			p.SetState(750)
			p.Match(GroovyParserASSIGN)
		}
		{
			p.SetState(751)
			p.Nls()
		}
		{
			p.SetState(752)
			p.expression(0)
		}

	}

	return localctx
}

// IMethodBodyContext is an interface to support dynamic dispatch.
type IMethodBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMethodBodyContext differentiates from other interfaces.
	IsMethodBodyContext()
}

type MethodBodyContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyMethodBodyContext() *MethodBodyContext {
	var p = new(MethodBodyContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_methodBody
	return p
}

func (*MethodBodyContext) IsMethodBodyContext() {}

func NewMethodBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MethodBodyContext {
	var p = new(MethodBodyContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_methodBody

	return p
}

func (s *MethodBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *MethodBodyContext) Block() IBlockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *MethodBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MethodBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MethodBodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterMethodBody(s)
	}
}

func (s *MethodBodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitMethodBody(s)
	}
}

func (p *GroovyParser) MethodBody() (localctx IMethodBodyContext) {
	localctx = NewMethodBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, GroovyParserRULE_methodBody)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(756)
		p.Block()
	}

	return localctx
}

// IQualifiedNameContext is an interface to support dynamic dispatch.
type IQualifiedNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsQualifiedNameContext differentiates from other interfaces.
	IsQualifiedNameContext()
}

type QualifiedNameContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyQualifiedNameContext() *QualifiedNameContext {
	var p = new(QualifiedNameContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_qualifiedName
	return p
}

func (*QualifiedNameContext) IsQualifiedNameContext() {}

func NewQualifiedNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QualifiedNameContext {
	var p = new(QualifiedNameContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_qualifiedName

	return p
}

func (s *QualifiedNameContext) GetParser() antlr.Parser { return s.parser }

func (s *QualifiedNameContext) AllQualifiedNameElement() []IQualifiedNameElementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IQualifiedNameElementContext)(nil)).Elem())
	var tst = make([]IQualifiedNameElementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IQualifiedNameElementContext)
		}
	}

	return tst
}

func (s *QualifiedNameContext) QualifiedNameElement(i int) IQualifiedNameElementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedNameElementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameElementContext)
}

func (s *QualifiedNameContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(GroovyParserDOT)
}

func (s *QualifiedNameContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(GroovyParserDOT, i)
}

func (s *QualifiedNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QualifiedNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QualifiedNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterQualifiedName(s)
	}
}

func (s *QualifiedNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitQualifiedName(s)
	}
}

func (p *GroovyParser) QualifiedName() (localctx IQualifiedNameContext) {
	localctx = NewQualifiedNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, GroovyParserRULE_qualifiedName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(758)
		p.QualifiedNameElement()
	}
	p.SetState(763)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 73, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(759)
				p.Match(GroovyParserDOT)
			}
			{
				p.SetState(760)
				p.QualifiedNameElement()
			}

		}
		p.SetState(765)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 73, p.GetParserRuleContext())
	}

	return localctx
}

// IQualifiedNameElementContext is an interface to support dynamic dispatch.
type IQualifiedNameElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsQualifiedNameElementContext differentiates from other interfaces.
	IsQualifiedNameElementContext()
}

type QualifiedNameElementContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyQualifiedNameElementContext() *QualifiedNameElementContext {
	var p = new(QualifiedNameElementContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_qualifiedNameElement
	return p
}

func (*QualifiedNameElementContext) IsQualifiedNameElementContext() {}

func NewQualifiedNameElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QualifiedNameElementContext {
	var p = new(QualifiedNameElementContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_qualifiedNameElement

	return p
}

func (s *QualifiedNameElementContext) GetParser() antlr.Parser { return s.parser }

func (s *QualifiedNameElementContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *QualifiedNameElementContext) DEF() antlr.TerminalNode {
	return s.GetToken(GroovyParserDEF, 0)
}

func (s *QualifiedNameElementContext) IN() antlr.TerminalNode {
	return s.GetToken(GroovyParserIN, 0)
}

func (s *QualifiedNameElementContext) AS() antlr.TerminalNode {
	return s.GetToken(GroovyParserAS, 0)
}

func (s *QualifiedNameElementContext) TRAIT() antlr.TerminalNode {
	return s.GetToken(GroovyParserTRAIT, 0)
}

func (s *QualifiedNameElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QualifiedNameElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QualifiedNameElementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterQualifiedNameElement(s)
	}
}

func (s *QualifiedNameElementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitQualifiedNameElement(s)
	}
}

func (p *GroovyParser) QualifiedNameElement() (localctx IQualifiedNameElementContext) {
	localctx = NewQualifiedNameElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, GroovyParserRULE_qualifiedNameElement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(771)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 74, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(766)
			p.Identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(767)
			p.Match(GroovyParserDEF)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(768)
			p.Match(GroovyParserIN)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(769)
			p.Match(GroovyParserAS)
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(770)
			p.Match(GroovyParserTRAIT)
		}

	}

	return localctx
}

// IQualifiedNameElementsContext is an interface to support dynamic dispatch.
type IQualifiedNameElementsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsQualifiedNameElementsContext differentiates from other interfaces.
	IsQualifiedNameElementsContext()
}

type QualifiedNameElementsContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyQualifiedNameElementsContext() *QualifiedNameElementsContext {
	var p = new(QualifiedNameElementsContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_qualifiedNameElements
	return p
}

func (*QualifiedNameElementsContext) IsQualifiedNameElementsContext() {}

func NewQualifiedNameElementsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QualifiedNameElementsContext {
	var p = new(QualifiedNameElementsContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_qualifiedNameElements

	return p
}

func (s *QualifiedNameElementsContext) GetParser() antlr.Parser { return s.parser }

func (s *QualifiedNameElementsContext) AllQualifiedNameElement() []IQualifiedNameElementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IQualifiedNameElementContext)(nil)).Elem())
	var tst = make([]IQualifiedNameElementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IQualifiedNameElementContext)
		}
	}

	return tst
}

func (s *QualifiedNameElementsContext) QualifiedNameElement(i int) IQualifiedNameElementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedNameElementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameElementContext)
}

func (s *QualifiedNameElementsContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(GroovyParserDOT)
}

func (s *QualifiedNameElementsContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(GroovyParserDOT, i)
}

func (s *QualifiedNameElementsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QualifiedNameElementsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QualifiedNameElementsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterQualifiedNameElements(s)
	}
}

func (s *QualifiedNameElementsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitQualifiedNameElements(s)
	}
}

func (p *GroovyParser) QualifiedNameElements() (localctx IQualifiedNameElementsContext) {
	localctx = NewQualifiedNameElementsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, GroovyParserRULE_qualifiedNameElements)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(778)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 75, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(773)
				p.QualifiedNameElement()
			}
			{
				p.SetState(774)
				p.Match(GroovyParserDOT)
			}

		}
		p.SetState(780)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 75, p.GetParserRuleContext())
	}

	return localctx
}

// IQualifiedClassNameContext is an interface to support dynamic dispatch.
type IQualifiedClassNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsQualifiedClassNameContext differentiates from other interfaces.
	IsQualifiedClassNameContext()
}

type QualifiedClassNameContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyQualifiedClassNameContext() *QualifiedClassNameContext {
	var p = new(QualifiedClassNameContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_qualifiedClassName
	return p
}

func (*QualifiedClassNameContext) IsQualifiedClassNameContext() {}

func NewQualifiedClassNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QualifiedClassNameContext {
	var p = new(QualifiedClassNameContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_qualifiedClassName

	return p
}

func (s *QualifiedClassNameContext) GetParser() antlr.Parser { return s.parser }

func (s *QualifiedClassNameContext) QualifiedNameElements() IQualifiedNameElementsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedNameElementsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameElementsContext)
}

func (s *QualifiedClassNameContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *QualifiedClassNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QualifiedClassNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QualifiedClassNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterQualifiedClassName(s)
	}
}

func (s *QualifiedClassNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitQualifiedClassName(s)
	}
}

func (p *GroovyParser) QualifiedClassName() (localctx IQualifiedClassNameContext) {
	localctx = NewQualifiedClassNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, GroovyParserRULE_qualifiedClassName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(781)
		p.QualifiedNameElements()
	}
	{
		p.SetState(782)
		p.Identifier()
	}

	return localctx
}

// IQualifiedStandardClassNameContext is an interface to support dynamic dispatch.
type IQualifiedStandardClassNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsQualifiedStandardClassNameContext differentiates from other interfaces.
	IsQualifiedStandardClassNameContext()
}

type QualifiedStandardClassNameContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyQualifiedStandardClassNameContext() *QualifiedStandardClassNameContext {
	var p = new(QualifiedStandardClassNameContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_qualifiedStandardClassName
	return p
}

func (*QualifiedStandardClassNameContext) IsQualifiedStandardClassNameContext() {}

func NewQualifiedStandardClassNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QualifiedStandardClassNameContext {
	var p = new(QualifiedStandardClassNameContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_qualifiedStandardClassName

	return p
}

func (s *QualifiedStandardClassNameContext) GetParser() antlr.Parser { return s.parser }

func (s *QualifiedStandardClassNameContext) QualifiedNameElements() IQualifiedNameElementsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedNameElementsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameElementsContext)
}

func (s *QualifiedStandardClassNameContext) AllClassName() []IClassNameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IClassNameContext)(nil)).Elem())
	var tst = make([]IClassNameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IClassNameContext)
		}
	}

	return tst
}

func (s *QualifiedStandardClassNameContext) ClassName(i int) IClassNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClassNameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IClassNameContext)
}

func (s *QualifiedStandardClassNameContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(GroovyParserDOT)
}

func (s *QualifiedStandardClassNameContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(GroovyParserDOT, i)
}

func (s *QualifiedStandardClassNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QualifiedStandardClassNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QualifiedStandardClassNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterQualifiedStandardClassName(s)
	}
}

func (s *QualifiedStandardClassNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitQualifiedStandardClassName(s)
	}
}

func (p *GroovyParser) QualifiedStandardClassName() (localctx IQualifiedStandardClassNameContext) {
	localctx = NewQualifiedStandardClassNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, GroovyParserRULE_qualifiedStandardClassName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(784)
		p.QualifiedNameElements()
	}
	{
		p.SetState(785)
		p.ClassName()
	}
	p.SetState(790)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 76, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(786)
				p.Match(GroovyParserDOT)
			}
			{
				p.SetState(787)
				p.ClassName()
			}

		}
		p.SetState(792)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 76, p.GetParserRuleContext())
	}

	return localctx
}

// ILiteralContext is an interface to support dynamic dispatch.
type ILiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLiteralContext differentiates from other interfaces.
	IsLiteralContext()
}

type LiteralContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyLiteralContext() *LiteralContext {
	var p = new(LiteralContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_literal
	return p
}

func (*LiteralContext) IsLiteralContext() {}

func NewLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LiteralContext {
	var p = new(LiteralContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_literal

	return p
}

func (s *LiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *LiteralContext) CopyFrom(ctx *LiteralContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *LiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type StringLiteralAltContext struct {
	*LiteralContext
}

func NewStringLiteralAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StringLiteralAltContext {
	var p = new(StringLiteralAltContext)

	p.LiteralContext = NewEmptyLiteralContext()
	p.parser = parser
	p.CopyFrom(ctx.(*LiteralContext))

	return p
}

func (s *StringLiteralAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringLiteralAltContext) StringLiteral() IStringLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStringLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *StringLiteralAltContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterStringLiteralAlt(s)
	}
}

func (s *StringLiteralAltContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitStringLiteralAlt(s)
	}
}

type IntegerLiteralAltContext struct {
	*LiteralContext
}

func NewIntegerLiteralAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IntegerLiteralAltContext {
	var p = new(IntegerLiteralAltContext)

	p.LiteralContext = NewEmptyLiteralContext()
	p.parser = parser
	p.CopyFrom(ctx.(*LiteralContext))

	return p
}

func (s *IntegerLiteralAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntegerLiteralAltContext) IntegerLiteral() antlr.TerminalNode {
	return s.GetToken(GroovyParserIntegerLiteral, 0)
}

func (s *IntegerLiteralAltContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterIntegerLiteralAlt(s)
	}
}

func (s *IntegerLiteralAltContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitIntegerLiteralAlt(s)
	}
}

type FloatingPointLiteralAltContext struct {
	*LiteralContext
}

func NewFloatingPointLiteralAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *FloatingPointLiteralAltContext {
	var p = new(FloatingPointLiteralAltContext)

	p.LiteralContext = NewEmptyLiteralContext()
	p.parser = parser
	p.CopyFrom(ctx.(*LiteralContext))

	return p
}

func (s *FloatingPointLiteralAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FloatingPointLiteralAltContext) FloatingPointLiteral() antlr.TerminalNode {
	return s.GetToken(GroovyParserFloatingPointLiteral, 0)
}

func (s *FloatingPointLiteralAltContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterFloatingPointLiteralAlt(s)
	}
}

func (s *FloatingPointLiteralAltContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitFloatingPointLiteralAlt(s)
	}
}

type NullLiteralAltContext struct {
	*LiteralContext
}

func NewNullLiteralAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NullLiteralAltContext {
	var p = new(NullLiteralAltContext)

	p.LiteralContext = NewEmptyLiteralContext()
	p.parser = parser
	p.CopyFrom(ctx.(*LiteralContext))

	return p
}

func (s *NullLiteralAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NullLiteralAltContext) NullLiteral() antlr.TerminalNode {
	return s.GetToken(GroovyParserNullLiteral, 0)
}

func (s *NullLiteralAltContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterNullLiteralAlt(s)
	}
}

func (s *NullLiteralAltContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitNullLiteralAlt(s)
	}
}

type BooleanLiteralAltContext struct {
	*LiteralContext
}

func NewBooleanLiteralAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BooleanLiteralAltContext {
	var p = new(BooleanLiteralAltContext)

	p.LiteralContext = NewEmptyLiteralContext()
	p.parser = parser
	p.CopyFrom(ctx.(*LiteralContext))

	return p
}

func (s *BooleanLiteralAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BooleanLiteralAltContext) BooleanLiteral() antlr.TerminalNode {
	return s.GetToken(GroovyParserBooleanLiteral, 0)
}

func (s *BooleanLiteralAltContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterBooleanLiteralAlt(s)
	}
}

func (s *BooleanLiteralAltContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitBooleanLiteralAlt(s)
	}
}

func (p *GroovyParser) Literal() (localctx ILiteralContext) {
	localctx = NewLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, GroovyParserRULE_literal)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(798)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case GroovyParserIntegerLiteral:
		localctx = NewIntegerLiteralAltContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(793)
			p.Match(GroovyParserIntegerLiteral)
		}

	case GroovyParserFloatingPointLiteral:
		localctx = NewFloatingPointLiteralAltContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(794)
			p.Match(GroovyParserFloatingPointLiteral)
		}

	case GroovyParserStringLiteral:
		localctx = NewStringLiteralAltContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(795)
			p.StringLiteral()
		}

	case GroovyParserBooleanLiteral:
		localctx = NewBooleanLiteralAltContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(796)
			p.Match(GroovyParserBooleanLiteral)
		}

	case GroovyParserNullLiteral:
		localctx = NewNullLiteralAltContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(797)
			p.Match(GroovyParserNullLiteral)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IGstringContext is an interface to support dynamic dispatch.
type IGstringContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGstringContext differentiates from other interfaces.
	IsGstringContext()
}

type GstringContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyGstringContext() *GstringContext {
	var p = new(GstringContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_gstring
	return p
}

func (*GstringContext) IsGstringContext() {}

func NewGstringContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GstringContext {
	var p = new(GstringContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_gstring

	return p
}

func (s *GstringContext) GetParser() antlr.Parser { return s.parser }

func (s *GstringContext) GStringBegin() antlr.TerminalNode {
	return s.GetToken(GroovyParserGStringBegin, 0)
}

func (s *GstringContext) AllGstringValue() []IGstringValueContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IGstringValueContext)(nil)).Elem())
	var tst = make([]IGstringValueContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IGstringValueContext)
		}
	}

	return tst
}

func (s *GstringContext) GstringValue(i int) IGstringValueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGstringValueContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IGstringValueContext)
}

func (s *GstringContext) GStringEnd() antlr.TerminalNode {
	return s.GetToken(GroovyParserGStringEnd, 0)
}

func (s *GstringContext) AllGStringPart() []antlr.TerminalNode {
	return s.GetTokens(GroovyParserGStringPart)
}

func (s *GstringContext) GStringPart(i int) antlr.TerminalNode {
	return s.GetToken(GroovyParserGStringPart, i)
}

func (s *GstringContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GstringContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GstringContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterGstring(s)
	}
}

func (s *GstringContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitGstring(s)
	}
}

func (p *GroovyParser) Gstring() (localctx IGstringContext) {
	localctx = NewGstringContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, GroovyParserRULE_gstring)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(800)
		p.Match(GroovyParserGStringBegin)
	}
	{
		p.SetState(801)
		p.GstringValue()
	}
	p.SetState(806)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == GroovyParserGStringPart {
		{
			p.SetState(802)
			p.Match(GroovyParserGStringPart)
		}
		{
			p.SetState(803)
			p.GstringValue()
		}

		p.SetState(808)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(809)
		p.Match(GroovyParserGStringEnd)
	}

	return localctx
}

// IGstringValueContext is an interface to support dynamic dispatch.
type IGstringValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGstringValueContext differentiates from other interfaces.
	IsGstringValueContext()
}

type GstringValueContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyGstringValueContext() *GstringValueContext {
	var p = new(GstringValueContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_gstringValue
	return p
}

func (*GstringValueContext) IsGstringValueContext() {}

func NewGstringValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GstringValueContext {
	var p = new(GstringValueContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_gstringValue

	return p
}

func (s *GstringValueContext) GetParser() antlr.Parser { return s.parser }

func (s *GstringValueContext) GstringPath() IGstringPathContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGstringPathContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGstringPathContext)
}

func (s *GstringValueContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(GroovyParserLBRACE, 0)
}

func (s *GstringValueContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(GroovyParserRBRACE, 0)
}

func (s *GstringValueContext) StatementExpression() IStatementExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatementExpressionContext)
}

func (s *GstringValueContext) Closure() IClosureContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClosureContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClosureContext)
}

func (s *GstringValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GstringValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GstringValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterGstringValue(s)
	}
}

func (s *GstringValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitGstringValue(s)
	}
}

func (p *GroovyParser) GstringValue() (localctx IGstringValueContext) {
	localctx = NewGstringValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, GroovyParserRULE_gstringValue)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(818)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 80, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(811)
			p.GstringPath()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(812)
			p.Match(GroovyParserLBRACE)
		}
		p.SetState(814)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 79, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(813)
				p.StatementExpression()
			}

		}
		{
			p.SetState(816)
			p.Match(GroovyParserRBRACE)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(817)
			p.Closure()
		}

	}

	return localctx
}

// IGstringPathContext is an interface to support dynamic dispatch.
type IGstringPathContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGstringPathContext differentiates from other interfaces.
	IsGstringPathContext()
}

type GstringPathContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyGstringPathContext() *GstringPathContext {
	var p = new(GstringPathContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_gstringPath
	return p
}

func (*GstringPathContext) IsGstringPathContext() {}

func NewGstringPathContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GstringPathContext {
	var p = new(GstringPathContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_gstringPath

	return p
}

func (s *GstringPathContext) GetParser() antlr.Parser { return s.parser }

func (s *GstringPathContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *GstringPathContext) AllGStringPathPart() []antlr.TerminalNode {
	return s.GetTokens(GroovyParserGStringPathPart)
}

func (s *GstringPathContext) GStringPathPart(i int) antlr.TerminalNode {
	return s.GetToken(GroovyParserGStringPathPart, i)
}

func (s *GstringPathContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GstringPathContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GstringPathContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterGstringPath(s)
	}
}

func (s *GstringPathContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitGstringPath(s)
	}
}

func (p *GroovyParser) GstringPath() (localctx IGstringPathContext) {
	localctx = NewGstringPathContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, GroovyParserRULE_gstringPath)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(820)
		p.Identifier()
	}
	p.SetState(824)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == GroovyParserGStringPathPart {
		{
			p.SetState(821)
			p.Match(GroovyParserGStringPathPart)
		}

		p.SetState(826)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ILambdaExpressionContext is an interface to support dynamic dispatch.
type ILambdaExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLambdaExpressionContext differentiates from other interfaces.
	IsLambdaExpressionContext()
}

type LambdaExpressionContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyLambdaExpressionContext() *LambdaExpressionContext {
	var p = new(LambdaExpressionContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_lambdaExpression
	return p
}

func (*LambdaExpressionContext) IsLambdaExpressionContext() {}

func NewLambdaExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LambdaExpressionContext {
	var p = new(LambdaExpressionContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_lambdaExpression

	return p
}

func (s *LambdaExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *LambdaExpressionContext) LambdaParameters() ILambdaParametersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILambdaParametersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILambdaParametersContext)
}

func (s *LambdaExpressionContext) AllNls() []INlsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INlsContext)(nil)).Elem())
	var tst = make([]INlsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INlsContext)
		}
	}

	return tst
}

func (s *LambdaExpressionContext) Nls(i int) INlsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INlsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *LambdaExpressionContext) ARROW() antlr.TerminalNode {
	return s.GetToken(GroovyParserARROW, 0)
}

func (s *LambdaExpressionContext) LambdaBody() ILambdaBodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILambdaBodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILambdaBodyContext)
}

func (s *LambdaExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LambdaExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LambdaExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterLambdaExpression(s)
	}
}

func (s *LambdaExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitLambdaExpression(s)
	}
}

func (p *GroovyParser) LambdaExpression() (localctx ILambdaExpressionContext) {
	localctx = NewLambdaExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, GroovyParserRULE_lambdaExpression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(827)
		p.LambdaParameters()
	}
	{
		p.SetState(828)
		p.Nls()
	}
	{
		p.SetState(829)
		p.Match(GroovyParserARROW)
	}
	{
		p.SetState(830)
		p.Nls()
	}
	{
		p.SetState(831)
		p.LambdaBody()
	}

	return localctx
}

// IStandardLambdaExpressionContext is an interface to support dynamic dispatch.
type IStandardLambdaExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStandardLambdaExpressionContext differentiates from other interfaces.
	IsStandardLambdaExpressionContext()
}

type StandardLambdaExpressionContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyStandardLambdaExpressionContext() *StandardLambdaExpressionContext {
	var p = new(StandardLambdaExpressionContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_standardLambdaExpression
	return p
}

func (*StandardLambdaExpressionContext) IsStandardLambdaExpressionContext() {}

func NewStandardLambdaExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StandardLambdaExpressionContext {
	var p = new(StandardLambdaExpressionContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_standardLambdaExpression

	return p
}

func (s *StandardLambdaExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *StandardLambdaExpressionContext) StandardLambdaParameters() IStandardLambdaParametersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStandardLambdaParametersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStandardLambdaParametersContext)
}

func (s *StandardLambdaExpressionContext) AllNls() []INlsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INlsContext)(nil)).Elem())
	var tst = make([]INlsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INlsContext)
		}
	}

	return tst
}

func (s *StandardLambdaExpressionContext) Nls(i int) INlsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INlsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *StandardLambdaExpressionContext) ARROW() antlr.TerminalNode {
	return s.GetToken(GroovyParserARROW, 0)
}

func (s *StandardLambdaExpressionContext) LambdaBody() ILambdaBodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILambdaBodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILambdaBodyContext)
}

func (s *StandardLambdaExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StandardLambdaExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StandardLambdaExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterStandardLambdaExpression(s)
	}
}

func (s *StandardLambdaExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitStandardLambdaExpression(s)
	}
}

func (p *GroovyParser) StandardLambdaExpression() (localctx IStandardLambdaExpressionContext) {
	localctx = NewStandardLambdaExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, GroovyParserRULE_standardLambdaExpression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(833)
		p.StandardLambdaParameters()
	}
	{
		p.SetState(834)
		p.Nls()
	}
	{
		p.SetState(835)
		p.Match(GroovyParserARROW)
	}
	{
		p.SetState(836)
		p.Nls()
	}
	{
		p.SetState(837)
		p.LambdaBody()
	}

	return localctx
}

// ILambdaParametersContext is an interface to support dynamic dispatch.
type ILambdaParametersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLambdaParametersContext differentiates from other interfaces.
	IsLambdaParametersContext()
}

type LambdaParametersContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyLambdaParametersContext() *LambdaParametersContext {
	var p = new(LambdaParametersContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_lambdaParameters
	return p
}

func (*LambdaParametersContext) IsLambdaParametersContext() {}

func NewLambdaParametersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LambdaParametersContext {
	var p = new(LambdaParametersContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_lambdaParameters

	return p
}

func (s *LambdaParametersContext) GetParser() antlr.Parser { return s.parser }

func (s *LambdaParametersContext) FormalParameters() IFormalParametersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFormalParametersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFormalParametersContext)
}

func (s *LambdaParametersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LambdaParametersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LambdaParametersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterLambdaParameters(s)
	}
}

func (s *LambdaParametersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitLambdaParameters(s)
	}
}

func (p *GroovyParser) LambdaParameters() (localctx ILambdaParametersContext) {
	localctx = NewLambdaParametersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, GroovyParserRULE_lambdaParameters)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(839)
		p.FormalParameters()
	}

	return localctx
}

// IStandardLambdaParametersContext is an interface to support dynamic dispatch.
type IStandardLambdaParametersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStandardLambdaParametersContext differentiates from other interfaces.
	IsStandardLambdaParametersContext()
}

type StandardLambdaParametersContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyStandardLambdaParametersContext() *StandardLambdaParametersContext {
	var p = new(StandardLambdaParametersContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_standardLambdaParameters
	return p
}

func (*StandardLambdaParametersContext) IsStandardLambdaParametersContext() {}

func NewStandardLambdaParametersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StandardLambdaParametersContext {
	var p = new(StandardLambdaParametersContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_standardLambdaParameters

	return p
}

func (s *StandardLambdaParametersContext) GetParser() antlr.Parser { return s.parser }

func (s *StandardLambdaParametersContext) FormalParameters() IFormalParametersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFormalParametersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFormalParametersContext)
}

func (s *StandardLambdaParametersContext) VariableDeclaratorId() IVariableDeclaratorIdContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableDeclaratorIdContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariableDeclaratorIdContext)
}

func (s *StandardLambdaParametersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StandardLambdaParametersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StandardLambdaParametersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterStandardLambdaParameters(s)
	}
}

func (s *StandardLambdaParametersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitStandardLambdaParameters(s)
	}
}

func (p *GroovyParser) StandardLambdaParameters() (localctx IStandardLambdaParametersContext) {
	localctx = NewStandardLambdaParametersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, GroovyParserRULE_standardLambdaParameters)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(843)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 82, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(841)
			p.FormalParameters()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(842)
			p.VariableDeclaratorId()
		}

	}

	return localctx
}

// ILambdaBodyContext is an interface to support dynamic dispatch.
type ILambdaBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLambdaBodyContext differentiates from other interfaces.
	IsLambdaBodyContext()
}

type LambdaBodyContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyLambdaBodyContext() *LambdaBodyContext {
	var p = new(LambdaBodyContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_lambdaBody
	return p
}

func (*LambdaBodyContext) IsLambdaBodyContext() {}

func NewLambdaBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LambdaBodyContext {
	var p = new(LambdaBodyContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_lambdaBody

	return p
}

func (s *LambdaBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *LambdaBodyContext) Block() IBlockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *LambdaBodyContext) StatementExpression() IStatementExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatementExpressionContext)
}

func (s *LambdaBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LambdaBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LambdaBodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterLambdaBody(s)
	}
}

func (s *LambdaBodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitLambdaBody(s)
	}
}

func (p *GroovyParser) LambdaBody() (localctx ILambdaBodyContext) {
	localctx = NewLambdaBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, GroovyParserRULE_lambdaBody)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(847)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 83, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(845)
			p.Block()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(846)
			p.StatementExpression()
		}

	}

	return localctx
}

// IClosureContext is an interface to support dynamic dispatch.
type IClosureContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClosureContext differentiates from other interfaces.
	IsClosureContext()
}

type ClosureContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyClosureContext() *ClosureContext {
	var p = new(ClosureContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_closure
	return p
}

func (*ClosureContext) IsClosureContext() {}

func NewClosureContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClosureContext {
	var p = new(ClosureContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_closure

	return p
}

func (s *ClosureContext) GetParser() antlr.Parser { return s.parser }

func (s *ClosureContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(GroovyParserLBRACE, 0)
}

func (s *ClosureContext) AllNls() []INlsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INlsContext)(nil)).Elem())
	var tst = make([]INlsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INlsContext)
		}
	}

	return tst
}

func (s *ClosureContext) Nls(i int) INlsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INlsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *ClosureContext) BlockStatementsOpt() IBlockStatementsOptContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlockStatementsOptContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlockStatementsOptContext)
}

func (s *ClosureContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(GroovyParserRBRACE, 0)
}

func (s *ClosureContext) ARROW() antlr.TerminalNode {
	return s.GetToken(GroovyParserARROW, 0)
}

func (s *ClosureContext) FormalParameterList() IFormalParameterListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFormalParameterListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFormalParameterListContext)
}

func (s *ClosureContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClosureContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClosureContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterClosure(s)
	}
}

func (s *ClosureContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitClosure(s)
	}
}

func (p *GroovyParser) Closure() (localctx IClosureContext) {
	localctx = NewClosureContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 130, GroovyParserRULE_closure)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(849)
		p.Match(GroovyParserLBRACE)
	}
	{
		p.SetState(850)
		p.Nls()
	}
	p.SetState(858)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 85, p.GetParserRuleContext()) == 1 {
		p.SetState(852)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 84, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(851)
				p.FormalParameterList()
			}

		}
		{
			p.SetState(854)
			p.Nls()
		}
		{
			p.SetState(855)
			p.Match(GroovyParserARROW)
		}
		{
			p.SetState(856)
			p.Nls()
		}

	}
	{
		p.SetState(860)
		p.BlockStatementsOpt()
	}
	{
		p.SetState(861)
		p.Match(GroovyParserRBRACE)
	}

	return localctx
}

// IClosureOrLambdaExpressionContext is an interface to support dynamic dispatch.
type IClosureOrLambdaExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClosureOrLambdaExpressionContext differentiates from other interfaces.
	IsClosureOrLambdaExpressionContext()
}

type ClosureOrLambdaExpressionContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyClosureOrLambdaExpressionContext() *ClosureOrLambdaExpressionContext {
	var p = new(ClosureOrLambdaExpressionContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_closureOrLambdaExpression
	return p
}

func (*ClosureOrLambdaExpressionContext) IsClosureOrLambdaExpressionContext() {}

func NewClosureOrLambdaExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClosureOrLambdaExpressionContext {
	var p = new(ClosureOrLambdaExpressionContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_closureOrLambdaExpression

	return p
}

func (s *ClosureOrLambdaExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ClosureOrLambdaExpressionContext) Closure() IClosureContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClosureContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClosureContext)
}

func (s *ClosureOrLambdaExpressionContext) LambdaExpression() ILambdaExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILambdaExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILambdaExpressionContext)
}

func (s *ClosureOrLambdaExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClosureOrLambdaExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClosureOrLambdaExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterClosureOrLambdaExpression(s)
	}
}

func (s *ClosureOrLambdaExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitClosureOrLambdaExpression(s)
	}
}

func (p *GroovyParser) ClosureOrLambdaExpression() (localctx IClosureOrLambdaExpressionContext) {
	localctx = NewClosureOrLambdaExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, GroovyParserRULE_closureOrLambdaExpression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(865)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case GroovyParserLBRACE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(863)
			p.Closure()
		}

	case GroovyParserLPAREN:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(864)
			p.LambdaExpression()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IBlockStatementsOptContext is an interface to support dynamic dispatch.
type IBlockStatementsOptContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBlockStatementsOptContext differentiates from other interfaces.
	IsBlockStatementsOptContext()
}

type BlockStatementsOptContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyBlockStatementsOptContext() *BlockStatementsOptContext {
	var p = new(BlockStatementsOptContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_blockStatementsOpt
	return p
}

func (*BlockStatementsOptContext) IsBlockStatementsOptContext() {}

func NewBlockStatementsOptContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BlockStatementsOptContext {
	var p = new(BlockStatementsOptContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_blockStatementsOpt

	return p
}

func (s *BlockStatementsOptContext) GetParser() antlr.Parser { return s.parser }

func (s *BlockStatementsOptContext) BlockStatements() IBlockStatementsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlockStatementsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlockStatementsContext)
}

func (s *BlockStatementsOptContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BlockStatementsOptContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BlockStatementsOptContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterBlockStatementsOpt(s)
	}
}

func (s *BlockStatementsOptContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitBlockStatementsOpt(s)
	}
}

func (p *GroovyParser) BlockStatementsOpt() (localctx IBlockStatementsOptContext) {
	localctx = NewBlockStatementsOptContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 134, GroovyParserRULE_blockStatementsOpt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(868)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 87, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(867)
			p.BlockStatements()
		}

	}

	return localctx
}

// IBlockStatementsContext is an interface to support dynamic dispatch.
type IBlockStatementsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBlockStatementsContext differentiates from other interfaces.
	IsBlockStatementsContext()
}

type BlockStatementsContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyBlockStatementsContext() *BlockStatementsContext {
	var p = new(BlockStatementsContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_blockStatements
	return p
}

func (*BlockStatementsContext) IsBlockStatementsContext() {}

func NewBlockStatementsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BlockStatementsContext {
	var p = new(BlockStatementsContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_blockStatements

	return p
}

func (s *BlockStatementsContext) GetParser() antlr.Parser { return s.parser }

func (s *BlockStatementsContext) AllBlockStatement() []IBlockStatementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IBlockStatementContext)(nil)).Elem())
	var tst = make([]IBlockStatementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IBlockStatementContext)
		}
	}

	return tst
}

func (s *BlockStatementsContext) BlockStatement(i int) IBlockStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlockStatementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IBlockStatementContext)
}

func (s *BlockStatementsContext) AllSep() []ISepContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISepContext)(nil)).Elem())
	var tst = make([]ISepContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISepContext)
		}
	}

	return tst
}

func (s *BlockStatementsContext) Sep(i int) ISepContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISepContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISepContext)
}

func (s *BlockStatementsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BlockStatementsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BlockStatementsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterBlockStatements(s)
	}
}

func (s *BlockStatementsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitBlockStatements(s)
	}
}

func (p *GroovyParser) BlockStatements() (localctx IBlockStatementsContext) {
	localctx = NewBlockStatementsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, GroovyParserRULE_blockStatements)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(870)
		p.BlockStatement()
	}
	p.SetState(876)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 88, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(871)
				p.Sep()
			}
			{
				p.SetState(872)
				p.BlockStatement()
			}

		}
		p.SetState(878)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 88, p.GetParserRuleContext())
	}
	p.SetState(880)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 89, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(879)
			p.Sep()
		}

	}

	return localctx
}

// IAnnotationsOptContext is an interface to support dynamic dispatch.
type IAnnotationsOptContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAnnotationsOptContext differentiates from other interfaces.
	IsAnnotationsOptContext()
}

type AnnotationsOptContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnnotationsOptContext() *AnnotationsOptContext {
	var p = new(AnnotationsOptContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_annotationsOpt
	return p
}

func (*AnnotationsOptContext) IsAnnotationsOptContext() {}

func NewAnnotationsOptContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnnotationsOptContext {
	var p = new(AnnotationsOptContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_annotationsOpt

	return p
}

func (s *AnnotationsOptContext) GetParser() antlr.Parser { return s.parser }

func (s *AnnotationsOptContext) AllAnnotation() []IAnnotationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAnnotationContext)(nil)).Elem())
	var tst = make([]IAnnotationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAnnotationContext)
		}
	}

	return tst
}

func (s *AnnotationsOptContext) Annotation(i int) IAnnotationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *AnnotationsOptContext) AllNls() []INlsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INlsContext)(nil)).Elem())
	var tst = make([]INlsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INlsContext)
		}
	}

	return tst
}

func (s *AnnotationsOptContext) Nls(i int) INlsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INlsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *AnnotationsOptContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnnotationsOptContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AnnotationsOptContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterAnnotationsOpt(s)
	}
}

func (s *AnnotationsOptContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitAnnotationsOpt(s)
	}
}

func (p *GroovyParser) AnnotationsOpt() (localctx IAnnotationsOptContext) {
	localctx = NewAnnotationsOptContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 138, GroovyParserRULE_annotationsOpt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(887)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 90, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(882)
				p.Annotation()
			}
			{
				p.SetState(883)
				p.Nls()
			}

		}
		p.SetState(889)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 90, p.GetParserRuleContext())
	}

	return localctx
}

// IAnnotationContext is an interface to support dynamic dispatch.
type IAnnotationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAnnotationContext differentiates from other interfaces.
	IsAnnotationContext()
}

type AnnotationContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnnotationContext() *AnnotationContext {
	var p = new(AnnotationContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_annotation
	return p
}

func (*AnnotationContext) IsAnnotationContext() {}

func NewAnnotationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnnotationContext {
	var p = new(AnnotationContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_annotation

	return p
}

func (s *AnnotationContext) GetParser() antlr.Parser { return s.parser }

func (s *AnnotationContext) AT() antlr.TerminalNode {
	return s.GetToken(GroovyParserAT, 0)
}

func (s *AnnotationContext) AnnotationName() IAnnotationNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotationNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAnnotationNameContext)
}

func (s *AnnotationContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(GroovyParserLPAREN, 0)
}

func (s *AnnotationContext) Rparen() IRparenContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRparenContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRparenContext)
}

func (s *AnnotationContext) ElementValues() IElementValuesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IElementValuesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IElementValuesContext)
}

func (s *AnnotationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnnotationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AnnotationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterAnnotation(s)
	}
}

func (s *AnnotationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitAnnotation(s)
	}
}

func (p *GroovyParser) Annotation() (localctx IAnnotationContext) {
	localctx = NewAnnotationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 140, GroovyParserRULE_annotation)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(890)
		p.Match(GroovyParserAT)
	}
	{
		p.SetState(891)
		p.AnnotationName()
	}
	p.SetState(897)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 92, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(892)
			p.Match(GroovyParserLPAREN)
		}
		p.SetState(894)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 91, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(893)
				p.ElementValues()
			}

		}
		{
			p.SetState(896)
			p.Rparen()
		}

	}

	return localctx
}

// IElementValuesContext is an interface to support dynamic dispatch.
type IElementValuesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsElementValuesContext differentiates from other interfaces.
	IsElementValuesContext()
}

type ElementValuesContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyElementValuesContext() *ElementValuesContext {
	var p = new(ElementValuesContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_elementValues
	return p
}

func (*ElementValuesContext) IsElementValuesContext() {}

func NewElementValuesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ElementValuesContext {
	var p = new(ElementValuesContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_elementValues

	return p
}

func (s *ElementValuesContext) GetParser() antlr.Parser { return s.parser }

func (s *ElementValuesContext) ElementValuePairs() IElementValuePairsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IElementValuePairsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IElementValuePairsContext)
}

func (s *ElementValuesContext) ElementValue() IElementValueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IElementValueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IElementValueContext)
}

func (s *ElementValuesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ElementValuesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ElementValuesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterElementValues(s)
	}
}

func (s *ElementValuesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitElementValues(s)
	}
}

func (p *GroovyParser) ElementValues() (localctx IElementValuesContext) {
	localctx = NewElementValuesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 142, GroovyParserRULE_elementValues)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(901)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 93, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(899)
			p.ElementValuePairs()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(900)
			p.ElementValue()
		}

	}

	return localctx
}

// IAnnotationNameContext is an interface to support dynamic dispatch.
type IAnnotationNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAnnotationNameContext differentiates from other interfaces.
	IsAnnotationNameContext()
}

type AnnotationNameContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnnotationNameContext() *AnnotationNameContext {
	var p = new(AnnotationNameContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_annotationName
	return p
}

func (*AnnotationNameContext) IsAnnotationNameContext() {}

func NewAnnotationNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnnotationNameContext {
	var p = new(AnnotationNameContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_annotationName

	return p
}

func (s *AnnotationNameContext) GetParser() antlr.Parser { return s.parser }

func (s *AnnotationNameContext) QualifiedClassName() IQualifiedClassNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedClassNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedClassNameContext)
}

func (s *AnnotationNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnnotationNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AnnotationNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterAnnotationName(s)
	}
}

func (s *AnnotationNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitAnnotationName(s)
	}
}

func (p *GroovyParser) AnnotationName() (localctx IAnnotationNameContext) {
	localctx = NewAnnotationNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 144, GroovyParserRULE_annotationName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(903)
		p.QualifiedClassName()
	}

	return localctx
}

// IElementValuePairsContext is an interface to support dynamic dispatch.
type IElementValuePairsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsElementValuePairsContext differentiates from other interfaces.
	IsElementValuePairsContext()
}

type ElementValuePairsContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyElementValuePairsContext() *ElementValuePairsContext {
	var p = new(ElementValuePairsContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_elementValuePairs
	return p
}

func (*ElementValuePairsContext) IsElementValuePairsContext() {}

func NewElementValuePairsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ElementValuePairsContext {
	var p = new(ElementValuePairsContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_elementValuePairs

	return p
}

func (s *ElementValuePairsContext) GetParser() antlr.Parser { return s.parser }

func (s *ElementValuePairsContext) AllElementValuePair() []IElementValuePairContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IElementValuePairContext)(nil)).Elem())
	var tst = make([]IElementValuePairContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IElementValuePairContext)
		}
	}

	return tst
}

func (s *ElementValuePairsContext) ElementValuePair(i int) IElementValuePairContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IElementValuePairContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IElementValuePairContext)
}

func (s *ElementValuePairsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(GroovyParserCOMMA)
}

func (s *ElementValuePairsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(GroovyParserCOMMA, i)
}

func (s *ElementValuePairsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ElementValuePairsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ElementValuePairsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterElementValuePairs(s)
	}
}

func (s *ElementValuePairsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitElementValuePairs(s)
	}
}

func (p *GroovyParser) ElementValuePairs() (localctx IElementValuePairsContext) {
	localctx = NewElementValuePairsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 146, GroovyParserRULE_elementValuePairs)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(905)
		p.ElementValuePair()
	}
	p.SetState(910)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 94, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(906)
				p.Match(GroovyParserCOMMA)
			}
			{
				p.SetState(907)
				p.ElementValuePair()
			}

		}
		p.SetState(912)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 94, p.GetParserRuleContext())
	}

	return localctx
}

// IElementValuePairContext is an interface to support dynamic dispatch.
type IElementValuePairContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsElementValuePairContext differentiates from other interfaces.
	IsElementValuePairContext()
}

type ElementValuePairContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyElementValuePairContext() *ElementValuePairContext {
	var p = new(ElementValuePairContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_elementValuePair
	return p
}

func (*ElementValuePairContext) IsElementValuePairContext() {}

func NewElementValuePairContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ElementValuePairContext {
	var p = new(ElementValuePairContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_elementValuePair

	return p
}

func (s *ElementValuePairContext) GetParser() antlr.Parser { return s.parser }

func (s *ElementValuePairContext) ElementValuePairName() IElementValuePairNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IElementValuePairNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IElementValuePairNameContext)
}

func (s *ElementValuePairContext) AllNls() []INlsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INlsContext)(nil)).Elem())
	var tst = make([]INlsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INlsContext)
		}
	}

	return tst
}

func (s *ElementValuePairContext) Nls(i int) INlsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INlsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *ElementValuePairContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(GroovyParserASSIGN, 0)
}

func (s *ElementValuePairContext) ElementValue() IElementValueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IElementValueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IElementValueContext)
}

func (s *ElementValuePairContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ElementValuePairContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ElementValuePairContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterElementValuePair(s)
	}
}

func (s *ElementValuePairContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitElementValuePair(s)
	}
}

func (p *GroovyParser) ElementValuePair() (localctx IElementValuePairContext) {
	localctx = NewElementValuePairContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 148, GroovyParserRULE_elementValuePair)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(913)
		p.ElementValuePairName()
	}
	{
		p.SetState(914)
		p.Nls()
	}
	{
		p.SetState(915)
		p.Match(GroovyParserASSIGN)
	}
	{
		p.SetState(916)
		p.Nls()
	}
	{
		p.SetState(917)
		p.ElementValue()
	}

	return localctx
}

// IElementValuePairNameContext is an interface to support dynamic dispatch.
type IElementValuePairNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsElementValuePairNameContext differentiates from other interfaces.
	IsElementValuePairNameContext()
}

type ElementValuePairNameContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyElementValuePairNameContext() *ElementValuePairNameContext {
	var p = new(ElementValuePairNameContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_elementValuePairName
	return p
}

func (*ElementValuePairNameContext) IsElementValuePairNameContext() {}

func NewElementValuePairNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ElementValuePairNameContext {
	var p = new(ElementValuePairNameContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_elementValuePairName

	return p
}

func (s *ElementValuePairNameContext) GetParser() antlr.Parser { return s.parser }

func (s *ElementValuePairNameContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ElementValuePairNameContext) Keywords() IKeywordsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IKeywordsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IKeywordsContext)
}

func (s *ElementValuePairNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ElementValuePairNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ElementValuePairNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterElementValuePairName(s)
	}
}

func (s *ElementValuePairNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitElementValuePairName(s)
	}
}

func (p *GroovyParser) ElementValuePairName() (localctx IElementValuePairNameContext) {
	localctx = NewElementValuePairNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 150, GroovyParserRULE_elementValuePairName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(921)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 95, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(919)
			p.Identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(920)
			p.Keywords()
		}

	}

	return localctx
}

// IElementValueContext is an interface to support dynamic dispatch.
type IElementValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsElementValueContext differentiates from other interfaces.
	IsElementValueContext()
}

type ElementValueContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyElementValueContext() *ElementValueContext {
	var p = new(ElementValueContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_elementValue
	return p
}

func (*ElementValueContext) IsElementValueContext() {}

func NewElementValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ElementValueContext {
	var p = new(ElementValueContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_elementValue

	return p
}

func (s *ElementValueContext) GetParser() antlr.Parser { return s.parser }

func (s *ElementValueContext) ElementValueArrayInitializer() IElementValueArrayInitializerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IElementValueArrayInitializerContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IElementValueArrayInitializerContext)
}

func (s *ElementValueContext) Annotation() IAnnotationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *ElementValueContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ElementValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ElementValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ElementValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterElementValue(s)
	}
}

func (s *ElementValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitElementValue(s)
	}
}

func (p *GroovyParser) ElementValue() (localctx IElementValueContext) {
	localctx = NewElementValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 152, GroovyParserRULE_elementValue)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(926)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 96, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(923)
			p.ElementValueArrayInitializer()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(924)
			p.Annotation()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(925)
			p.expression(0)
		}

	}

	return localctx
}

// IElementValueArrayInitializerContext is an interface to support dynamic dispatch.
type IElementValueArrayInitializerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsElementValueArrayInitializerContext differentiates from other interfaces.
	IsElementValueArrayInitializerContext()
}

type ElementValueArrayInitializerContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyElementValueArrayInitializerContext() *ElementValueArrayInitializerContext {
	var p = new(ElementValueArrayInitializerContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_elementValueArrayInitializer
	return p
}

func (*ElementValueArrayInitializerContext) IsElementValueArrayInitializerContext() {}

func NewElementValueArrayInitializerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ElementValueArrayInitializerContext {
	var p = new(ElementValueArrayInitializerContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_elementValueArrayInitializer

	return p
}

func (s *ElementValueArrayInitializerContext) GetParser() antlr.Parser { return s.parser }

func (s *ElementValueArrayInitializerContext) LBRACK() antlr.TerminalNode {
	return s.GetToken(GroovyParserLBRACK, 0)
}

func (s *ElementValueArrayInitializerContext) RBRACK() antlr.TerminalNode {
	return s.GetToken(GroovyParserRBRACK, 0)
}

func (s *ElementValueArrayInitializerContext) AllElementValue() []IElementValueContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IElementValueContext)(nil)).Elem())
	var tst = make([]IElementValueContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IElementValueContext)
		}
	}

	return tst
}

func (s *ElementValueArrayInitializerContext) ElementValue(i int) IElementValueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IElementValueContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IElementValueContext)
}

func (s *ElementValueArrayInitializerContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(GroovyParserCOMMA)
}

func (s *ElementValueArrayInitializerContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(GroovyParserCOMMA, i)
}

func (s *ElementValueArrayInitializerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ElementValueArrayInitializerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ElementValueArrayInitializerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterElementValueArrayInitializer(s)
	}
}

func (s *ElementValueArrayInitializerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitElementValueArrayInitializer(s)
	}
}

func (p *GroovyParser) ElementValueArrayInitializer() (localctx IElementValueArrayInitializerContext) {
	localctx = NewElementValueArrayInitializerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 154, GroovyParserRULE_elementValueArrayInitializer)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(928)
		p.Match(GroovyParserLBRACK)
	}
	p.SetState(937)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 98, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(929)
			p.ElementValue()
		}
		p.SetState(934)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 97, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(930)
					p.Match(GroovyParserCOMMA)
				}
				{
					p.SetState(931)
					p.ElementValue()
				}

			}
			p.SetState(936)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 97, p.GetParserRuleContext())
		}

	}
	p.SetState(940)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == GroovyParserCOMMA {
		{
			p.SetState(939)
			p.Match(GroovyParserCOMMA)
		}

	}
	{
		p.SetState(942)
		p.Match(GroovyParserRBRACK)
	}

	return localctx
}

// IBlockContext is an interface to support dynamic dispatch.
type IBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBlockContext differentiates from other interfaces.
	IsBlockContext()
}

type BlockContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyBlockContext() *BlockContext {
	var p = new(BlockContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_block
	return p
}

func (*BlockContext) IsBlockContext() {}

func NewBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BlockContext {
	var p = new(BlockContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_block

	return p
}

func (s *BlockContext) GetParser() antlr.Parser { return s.parser }

func (s *BlockContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(GroovyParserLBRACE, 0)
}

func (s *BlockContext) BlockStatementsOpt() IBlockStatementsOptContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlockStatementsOptContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlockStatementsOptContext)
}

func (s *BlockContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(GroovyParserRBRACE, 0)
}

func (s *BlockContext) Nls() INlsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INlsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *BlockContext) AllSep() []ISepContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISepContext)(nil)).Elem())
	var tst = make([]ISepContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISepContext)
		}
	}

	return tst
}

func (s *BlockContext) Sep(i int) ISepContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISepContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISepContext)
}

func (s *BlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterBlock(s)
	}
}

func (s *BlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitBlock(s)
	}
}

func (p *GroovyParser) Block() (localctx IBlockContext) {
	localctx = NewBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 156, GroovyParserRULE_block)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(944)
		p.Match(GroovyParserLBRACE)
	}
	p.SetState(952)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 101, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(945)
			p.Nls()
		}

	case 2:
		p.SetState(949)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 100, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(946)
					p.Sep()
				}

			}
			p.SetState(951)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 100, p.GetParserRuleContext())
		}

	}
	{
		p.SetState(954)
		p.BlockStatementsOpt()
	}
	{
		p.SetState(955)
		p.Match(GroovyParserRBRACE)
	}

	return localctx
}

// IBlockStatementContext is an interface to support dynamic dispatch.
type IBlockStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBlockStatementContext differentiates from other interfaces.
	IsBlockStatementContext()
}

type BlockStatementContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyBlockStatementContext() *BlockStatementContext {
	var p = new(BlockStatementContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_blockStatement
	return p
}

func (*BlockStatementContext) IsBlockStatementContext() {}

func NewBlockStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BlockStatementContext {
	var p = new(BlockStatementContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_blockStatement

	return p
}

func (s *BlockStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *BlockStatementContext) LocalVariableDeclaration() ILocalVariableDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILocalVariableDeclarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILocalVariableDeclarationContext)
}

func (s *BlockStatementContext) Statement() IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *BlockStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BlockStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BlockStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterBlockStatement(s)
	}
}

func (s *BlockStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitBlockStatement(s)
	}
}

func (p *GroovyParser) BlockStatement() (localctx IBlockStatementContext) {
	localctx = NewBlockStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 158, GroovyParserRULE_blockStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(959)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 102, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(957)
			p.LocalVariableDeclaration()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(958)
			p.Statement()
		}

	}

	return localctx
}

// ILocalVariableDeclarationContext is an interface to support dynamic dispatch.
type ILocalVariableDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLocalVariableDeclarationContext differentiates from other interfaces.
	IsLocalVariableDeclarationContext()
}

type LocalVariableDeclarationContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyLocalVariableDeclarationContext() *LocalVariableDeclarationContext {
	var p = new(LocalVariableDeclarationContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_localVariableDeclaration
	return p
}

func (*LocalVariableDeclarationContext) IsLocalVariableDeclarationContext() {}

func NewLocalVariableDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LocalVariableDeclarationContext {
	var p = new(LocalVariableDeclarationContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_localVariableDeclaration

	return p
}

func (s *LocalVariableDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *LocalVariableDeclarationContext) VariableDeclaration() IVariableDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableDeclarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariableDeclarationContext)
}

func (s *LocalVariableDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LocalVariableDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LocalVariableDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterLocalVariableDeclaration(s)
	}
}

func (s *LocalVariableDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitLocalVariableDeclaration(s)
	}
}

func (p *GroovyParser) LocalVariableDeclaration() (localctx ILocalVariableDeclarationContext) {
	localctx = NewLocalVariableDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 160, GroovyParserRULE_localVariableDeclaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(961)

	if !(!SemanticPredicates.isInvalidLocalVariableDeclaration(_input)) {
		panic(antlr.NewFailedPredicateException(p, " !SemanticPredicates.isInvalidLocalVariableDeclaration(_input) ", ""))
	}
	{
		p.SetState(962)
		p.VariableDeclaration(0)
	}

	return localctx
}

// IClassifiedModifiersContext is an interface to support dynamic dispatch.
type IClassifiedModifiersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetT returns the t attribute.
	GetT() int

	// SetT sets the t attribute.
	SetT(int)

	// IsClassifiedModifiersContext differentiates from other interfaces.
	IsClassifiedModifiersContext()
}

type ClassifiedModifiersContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
	t      int
}

func NewEmptyClassifiedModifiersContext() *ClassifiedModifiersContext {
	var p = new(ClassifiedModifiersContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_classifiedModifiers
	return p
}

func (*ClassifiedModifiersContext) IsClassifiedModifiersContext() {}

func NewClassifiedModifiersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int, t int) *ClassifiedModifiersContext {
	var p = new(ClassifiedModifiersContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_classifiedModifiers

	p.t = t

	return p
}

func (s *ClassifiedModifiersContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassifiedModifiersContext) GetT() int { return s.t }

func (s *ClassifiedModifiersContext) SetT(v int) { s.t = v }

func (s *ClassifiedModifiersContext) VariableModifiers() IVariableModifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableModifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariableModifiersContext)
}

func (s *ClassifiedModifiersContext) Modifiers() IModifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModifiersContext)
}

func (s *ClassifiedModifiersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassifiedModifiersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassifiedModifiersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterClassifiedModifiers(s)
	}
}

func (s *ClassifiedModifiersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitClassifiedModifiers(s)
	}
}

func (p *GroovyParser) ClassifiedModifiers(t int) (localctx IClassifiedModifiersContext) {
	localctx = NewClassifiedModifiersContext(p, p.GetParserRuleContext(), p.GetState(), t)
	p.EnterRule(localctx, 162, GroovyParserRULE_classifiedModifiers)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(968)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 103, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(964)

		if !(0 == localctx.(*ClassifiedModifiersContext).t) {
			panic(antlr.NewFailedPredicateException(p, " 0 == $t ", ""))
		}
		{
			p.SetState(965)
			p.VariableModifiers()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(966)

		if !(1 == localctx.(*ClassifiedModifiersContext).t) {
			panic(antlr.NewFailedPredicateException(p, " 1 == $t ", ""))
		}
		{
			p.SetState(967)
			p.Modifiers()
		}

	}

	return localctx
}

// IVariableDeclarationContext is an interface to support dynamic dispatch.
type IVariableDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetT returns the t attribute.
	GetT() int

	// SetT sets the t attribute.
	SetT(int)

	// IsVariableDeclarationContext differentiates from other interfaces.
	IsVariableDeclarationContext()
}

type VariableDeclarationContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
	t      int
}

func NewEmptyVariableDeclarationContext() *VariableDeclarationContext {
	var p = new(VariableDeclarationContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_variableDeclaration
	return p
}

func (*VariableDeclarationContext) IsVariableDeclarationContext() {}

func NewVariableDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int, t int) *VariableDeclarationContext {
	var p = new(VariableDeclarationContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_variableDeclaration

	p.t = t

	return p
}

func (s *VariableDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableDeclarationContext) GetT() int { return s.t }

func (s *VariableDeclarationContext) SetT(v int) { s.t = v }

func (s *VariableDeclarationContext) ClassifiedModifiers() IClassifiedModifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClassifiedModifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClassifiedModifiersContext)
}

func (s *VariableDeclarationContext) VariableDeclarators() IVariableDeclaratorsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableDeclaratorsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariableDeclaratorsContext)
}

func (s *VariableDeclarationContext) TypeNamePairs() ITypeNamePairsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeNamePairsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeNamePairsContext)
}

func (s *VariableDeclarationContext) AllNls() []INlsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INlsContext)(nil)).Elem())
	var tst = make([]INlsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INlsContext)
		}
	}

	return tst
}

func (s *VariableDeclarationContext) Nls(i int) INlsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INlsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *VariableDeclarationContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(GroovyParserASSIGN, 0)
}

func (s *VariableDeclarationContext) VariableInitializer() IVariableInitializerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableInitializerContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariableInitializerContext)
}

func (s *VariableDeclarationContext) TypeType() ITypeTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeTypeContext)
}

func (s *VariableDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterVariableDeclaration(s)
	}
}

func (s *VariableDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitVariableDeclaration(s)
	}
}

func (p *GroovyParser) VariableDeclaration(t int) (localctx IVariableDeclarationContext) {
	localctx = NewVariableDeclarationContext(p, p.GetParserRuleContext(), p.GetState(), t)
	p.EnterRule(localctx, 164, GroovyParserRULE_variableDeclaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(989)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 107, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(970)
			p.ClassifiedModifiers(localctx.(*VariableDeclarationContext).t)
		}
		p.SetState(981)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 105, p.GetParserRuleContext()) {
		case 1:
			p.SetState(972)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 104, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(971)
					p.TypeType()
				}

			}
			{
				p.SetState(974)
				p.VariableDeclarators()
			}

		case 2:
			{
				p.SetState(975)
				p.TypeNamePairs()
			}
			{
				p.SetState(976)
				p.Nls()
			}
			{
				p.SetState(977)
				p.Match(GroovyParserASSIGN)
			}
			{
				p.SetState(978)
				p.Nls()
			}
			{
				p.SetState(979)
				p.VariableInitializer()
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(984)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 106, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(983)
				p.ClassifiedModifiers(localctx.(*VariableDeclarationContext).t)
			}

		}
		{
			p.SetState(986)
			p.TypeType()
		}
		{
			p.SetState(987)
			p.VariableDeclarators()
		}

	}

	return localctx
}

// ITypeNamePairsContext is an interface to support dynamic dispatch.
type ITypeNamePairsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeNamePairsContext differentiates from other interfaces.
	IsTypeNamePairsContext()
}

type TypeNamePairsContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeNamePairsContext() *TypeNamePairsContext {
	var p = new(TypeNamePairsContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_typeNamePairs
	return p
}

func (*TypeNamePairsContext) IsTypeNamePairsContext() {}

func NewTypeNamePairsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeNamePairsContext {
	var p = new(TypeNamePairsContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_typeNamePairs

	return p
}

func (s *TypeNamePairsContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeNamePairsContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(GroovyParserLPAREN, 0)
}

func (s *TypeNamePairsContext) AllTypeNamePair() []ITypeNamePairContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITypeNamePairContext)(nil)).Elem())
	var tst = make([]ITypeNamePairContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITypeNamePairContext)
		}
	}

	return tst
}

func (s *TypeNamePairsContext) TypeNamePair(i int) ITypeNamePairContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeNamePairContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITypeNamePairContext)
}

func (s *TypeNamePairsContext) Rparen() IRparenContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRparenContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRparenContext)
}

func (s *TypeNamePairsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(GroovyParserCOMMA)
}

func (s *TypeNamePairsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(GroovyParserCOMMA, i)
}

func (s *TypeNamePairsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeNamePairsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeNamePairsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterTypeNamePairs(s)
	}
}

func (s *TypeNamePairsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitTypeNamePairs(s)
	}
}

func (p *GroovyParser) TypeNamePairs() (localctx ITypeNamePairsContext) {
	localctx = NewTypeNamePairsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 166, GroovyParserRULE_typeNamePairs)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(991)
		p.Match(GroovyParserLPAREN)
	}
	{
		p.SetState(992)
		p.TypeNamePair()
	}
	p.SetState(997)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == GroovyParserCOMMA {
		{
			p.SetState(993)
			p.Match(GroovyParserCOMMA)
		}
		{
			p.SetState(994)
			p.TypeNamePair()
		}

		p.SetState(999)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1000)
		p.Rparen()
	}

	return localctx
}

// ITypeNamePairContext is an interface to support dynamic dispatch.
type ITypeNamePairContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeNamePairContext differentiates from other interfaces.
	IsTypeNamePairContext()
}

type TypeNamePairContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeNamePairContext() *TypeNamePairContext {
	var p = new(TypeNamePairContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_typeNamePair
	return p
}

func (*TypeNamePairContext) IsTypeNamePairContext() {}

func NewTypeNamePairContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeNamePairContext {
	var p = new(TypeNamePairContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_typeNamePair

	return p
}

func (s *TypeNamePairContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeNamePairContext) VariableDeclaratorId() IVariableDeclaratorIdContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableDeclaratorIdContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariableDeclaratorIdContext)
}

func (s *TypeNamePairContext) TypeType() ITypeTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeTypeContext)
}

func (s *TypeNamePairContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeNamePairContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeNamePairContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterTypeNamePair(s)
	}
}

func (s *TypeNamePairContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitTypeNamePair(s)
	}
}

func (p *GroovyParser) TypeNamePair() (localctx ITypeNamePairContext) {
	localctx = NewTypeNamePairContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 168, GroovyParserRULE_typeNamePair)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1003)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 109, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1002)
			p.TypeType()
		}

	}
	{
		p.SetState(1005)
		p.VariableDeclaratorId()
	}

	return localctx
}

// IVariableNamesContext is an interface to support dynamic dispatch.
type IVariableNamesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVariableNamesContext differentiates from other interfaces.
	IsVariableNamesContext()
}

type VariableNamesContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableNamesContext() *VariableNamesContext {
	var p = new(VariableNamesContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_variableNames
	return p
}

func (*VariableNamesContext) IsVariableNamesContext() {}

func NewVariableNamesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableNamesContext {
	var p = new(VariableNamesContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_variableNames

	return p
}

func (s *VariableNamesContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableNamesContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(GroovyParserLPAREN, 0)
}

func (s *VariableNamesContext) AllVariableDeclaratorId() []IVariableDeclaratorIdContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IVariableDeclaratorIdContext)(nil)).Elem())
	var tst = make([]IVariableDeclaratorIdContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IVariableDeclaratorIdContext)
		}
	}

	return tst
}

func (s *VariableNamesContext) VariableDeclaratorId(i int) IVariableDeclaratorIdContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableDeclaratorIdContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IVariableDeclaratorIdContext)
}

func (s *VariableNamesContext) Rparen() IRparenContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRparenContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRparenContext)
}

func (s *VariableNamesContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(GroovyParserCOMMA)
}

func (s *VariableNamesContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(GroovyParserCOMMA, i)
}

func (s *VariableNamesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableNamesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableNamesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterVariableNames(s)
	}
}

func (s *VariableNamesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitVariableNames(s)
	}
}

func (p *GroovyParser) VariableNames() (localctx IVariableNamesContext) {
	localctx = NewVariableNamesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 170, GroovyParserRULE_variableNames)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1007)
		p.Match(GroovyParserLPAREN)
	}
	{
		p.SetState(1008)
		p.VariableDeclaratorId()
	}
	p.SetState(1011)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == GroovyParserCOMMA {
		{
			p.SetState(1009)
			p.Match(GroovyParserCOMMA)
		}
		{
			p.SetState(1010)
			p.VariableDeclaratorId()
		}

		p.SetState(1013)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1015)
		p.Rparen()
	}

	return localctx
}

// IConditionalStatementContext is an interface to support dynamic dispatch.
type IConditionalStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConditionalStatementContext differentiates from other interfaces.
	IsConditionalStatementContext()
}

type ConditionalStatementContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyConditionalStatementContext() *ConditionalStatementContext {
	var p = new(ConditionalStatementContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_conditionalStatement
	return p
}

func (*ConditionalStatementContext) IsConditionalStatementContext() {}

func NewConditionalStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConditionalStatementContext {
	var p = new(ConditionalStatementContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_conditionalStatement

	return p
}

func (s *ConditionalStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ConditionalStatementContext) IfElseStatement() IIfElseStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIfElseStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIfElseStatementContext)
}

func (s *ConditionalStatementContext) SwitchStatement() ISwitchStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISwitchStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISwitchStatementContext)
}

func (s *ConditionalStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConditionalStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConditionalStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterConditionalStatement(s)
	}
}

func (s *ConditionalStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitConditionalStatement(s)
	}
}

func (p *GroovyParser) ConditionalStatement() (localctx IConditionalStatementContext) {
	localctx = NewConditionalStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 172, GroovyParserRULE_conditionalStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1019)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case GroovyParserIF:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1017)
			p.IfElseStatement()
		}

	case GroovyParserSWITCH:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1018)
			p.SwitchStatement()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IIfElseStatementContext is an interface to support dynamic dispatch.
type IIfElseStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetTb returns the tb rule contexts.
	GetTb() IStatementContext

	// GetFb returns the fb rule contexts.
	GetFb() IStatementContext

	// SetTb sets the tb rule contexts.
	SetTb(IStatementContext)

	// SetFb sets the fb rule contexts.
	SetFb(IStatementContext)

	// IsIfElseStatementContext differentiates from other interfaces.
	IsIfElseStatementContext()
}

type IfElseStatementContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
	tb     IStatementContext
	fb     IStatementContext
}

func NewEmptyIfElseStatementContext() *IfElseStatementContext {
	var p = new(IfElseStatementContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_ifElseStatement
	return p
}

func (*IfElseStatementContext) IsIfElseStatementContext() {}

func NewIfElseStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IfElseStatementContext {
	var p = new(IfElseStatementContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_ifElseStatement

	return p
}

func (s *IfElseStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *IfElseStatementContext) GetTb() IStatementContext { return s.tb }

func (s *IfElseStatementContext) GetFb() IStatementContext { return s.fb }

func (s *IfElseStatementContext) SetTb(v IStatementContext) { s.tb = v }

func (s *IfElseStatementContext) SetFb(v IStatementContext) { s.fb = v }

func (s *IfElseStatementContext) IF() antlr.TerminalNode {
	return s.GetToken(GroovyParserIF, 0)
}

func (s *IfElseStatementContext) ExpressionInPar() IExpressionInParContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionInParContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionInParContext)
}

func (s *IfElseStatementContext) AllNls() []INlsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INlsContext)(nil)).Elem())
	var tst = make([]INlsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INlsContext)
		}
	}

	return tst
}

func (s *IfElseStatementContext) Nls(i int) INlsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INlsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *IfElseStatementContext) AllStatement() []IStatementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStatementContext)(nil)).Elem())
	var tst = make([]IStatementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStatementContext)
		}
	}

	return tst
}

func (s *IfElseStatementContext) Statement(i int) IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *IfElseStatementContext) ELSE() antlr.TerminalNode {
	return s.GetToken(GroovyParserELSE, 0)
}

func (s *IfElseStatementContext) Sep() ISepContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISepContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISepContext)
}

func (s *IfElseStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IfElseStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IfElseStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterIfElseStatement(s)
	}
}

func (s *IfElseStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitIfElseStatement(s)
	}
}

func (p *GroovyParser) IfElseStatement() (localctx IIfElseStatementContext) {
	localctx = NewIfElseStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 174, GroovyParserRULE_ifElseStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1021)
		p.Match(GroovyParserIF)
	}
	{
		p.SetState(1022)
		p.ExpressionInPar()
	}
	{
		p.SetState(1023)
		p.Nls()
	}
	{
		p.SetState(1024)

		var _x = p.Statement()

		localctx.(*IfElseStatementContext).tb = _x
	}
	p.SetState(1033)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 113, p.GetParserRuleContext()) == 1 {
		p.SetState(1027)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 112, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(1025)
				p.Nls()
			}

		case 2:
			{
				p.SetState(1026)
				p.Sep()
			}

		}
		{
			p.SetState(1029)
			p.Match(GroovyParserELSE)
		}
		{
			p.SetState(1030)
			p.Nls()
		}
		{
			p.SetState(1031)

			var _x = p.Statement()

			localctx.(*IfElseStatementContext).fb = _x
		}

	}

	return localctx
}

// ISwitchStatementContext is an interface to support dynamic dispatch.
type ISwitchStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSwitchStatementContext differentiates from other interfaces.
	IsSwitchStatementContext()
}

type SwitchStatementContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptySwitchStatementContext() *SwitchStatementContext {
	var p = new(SwitchStatementContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_switchStatement
	return p
}

func (*SwitchStatementContext) IsSwitchStatementContext() {}

func NewSwitchStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SwitchStatementContext {
	var p = new(SwitchStatementContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_switchStatement

	return p
}

func (s *SwitchStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SwitchStatementContext) SWITCH() antlr.TerminalNode {
	return s.GetToken(GroovyParserSWITCH, 0)
}

func (s *SwitchStatementContext) ExpressionInPar() IExpressionInParContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionInParContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionInParContext)
}

func (s *SwitchStatementContext) AllNls() []INlsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INlsContext)(nil)).Elem())
	var tst = make([]INlsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INlsContext)
		}
	}

	return tst
}

func (s *SwitchStatementContext) Nls(i int) INlsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INlsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *SwitchStatementContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(GroovyParserLBRACE, 0)
}

func (s *SwitchStatementContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(GroovyParserRBRACE, 0)
}

func (s *SwitchStatementContext) AllSwitchBlockStatementGroup() []ISwitchBlockStatementGroupContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISwitchBlockStatementGroupContext)(nil)).Elem())
	var tst = make([]ISwitchBlockStatementGroupContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISwitchBlockStatementGroupContext)
		}
	}

	return tst
}

func (s *SwitchStatementContext) SwitchBlockStatementGroup(i int) ISwitchBlockStatementGroupContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISwitchBlockStatementGroupContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISwitchBlockStatementGroupContext)
}

func (s *SwitchStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SwitchStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SwitchStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterSwitchStatement(s)
	}
}

func (s *SwitchStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitSwitchStatement(s)
	}
}

func (p *GroovyParser) SwitchStatement() (localctx ISwitchStatementContext) {
	localctx = NewSwitchStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 176, GroovyParserRULE_switchStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1035)
		p.Match(GroovyParserSWITCH)
	}
	{
		p.SetState(1036)
		p.ExpressionInPar()
	}
	{
		p.SetState(1037)
		p.Nls()
	}
	{
		p.SetState(1038)
		p.Match(GroovyParserLBRACE)
	}
	{
		p.SetState(1039)
		p.Nls()
	}
	p.SetState(1043)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == GroovyParserCASE || _la == GroovyParserDEFAULT {
		{
			p.SetState(1040)
			p.SwitchBlockStatementGroup()
		}

		p.SetState(1045)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1046)
		p.Nls()
	}
	{
		p.SetState(1047)
		p.Match(GroovyParserRBRACE)
	}

	return localctx
}

// ILoopStatementContext is an interface to support dynamic dispatch.
type ILoopStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLoopStatementContext differentiates from other interfaces.
	IsLoopStatementContext()
}

type LoopStatementContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyLoopStatementContext() *LoopStatementContext {
	var p = new(LoopStatementContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_loopStatement
	return p
}

func (*LoopStatementContext) IsLoopStatementContext() {}

func NewLoopStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LoopStatementContext {
	var p = new(LoopStatementContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_loopStatement

	return p
}

func (s *LoopStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *LoopStatementContext) CopyFrom(ctx *LoopStatementContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *LoopStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LoopStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type DoWhileStmtAltContext struct {
	*LoopStatementContext
}

func NewDoWhileStmtAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DoWhileStmtAltContext {
	var p = new(DoWhileStmtAltContext)

	p.LoopStatementContext = NewEmptyLoopStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*LoopStatementContext))

	return p
}

func (s *DoWhileStmtAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DoWhileStmtAltContext) DO() antlr.TerminalNode {
	return s.GetToken(GroovyParserDO, 0)
}

func (s *DoWhileStmtAltContext) AllNls() []INlsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INlsContext)(nil)).Elem())
	var tst = make([]INlsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INlsContext)
		}
	}

	return tst
}

func (s *DoWhileStmtAltContext) Nls(i int) INlsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INlsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *DoWhileStmtAltContext) Statement() IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *DoWhileStmtAltContext) WHILE() antlr.TerminalNode {
	return s.GetToken(GroovyParserWHILE, 0)
}

func (s *DoWhileStmtAltContext) ExpressionInPar() IExpressionInParContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionInParContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionInParContext)
}

func (s *DoWhileStmtAltContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterDoWhileStmtAlt(s)
	}
}

func (s *DoWhileStmtAltContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitDoWhileStmtAlt(s)
	}
}

type ForStmtAltContext struct {
	*LoopStatementContext
}

func NewForStmtAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ForStmtAltContext {
	var p = new(ForStmtAltContext)

	p.LoopStatementContext = NewEmptyLoopStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*LoopStatementContext))

	return p
}

func (s *ForStmtAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForStmtAltContext) FOR() antlr.TerminalNode {
	return s.GetToken(GroovyParserFOR, 0)
}

func (s *ForStmtAltContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(GroovyParserLPAREN, 0)
}

func (s *ForStmtAltContext) ForControl() IForControlContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IForControlContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IForControlContext)
}

func (s *ForStmtAltContext) Rparen() IRparenContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRparenContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRparenContext)
}

func (s *ForStmtAltContext) Nls() INlsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INlsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *ForStmtAltContext) Statement() IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *ForStmtAltContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterForStmtAlt(s)
	}
}

func (s *ForStmtAltContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitForStmtAlt(s)
	}
}

type WhileStmtAltContext struct {
	*LoopStatementContext
}

func NewWhileStmtAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *WhileStmtAltContext {
	var p = new(WhileStmtAltContext)

	p.LoopStatementContext = NewEmptyLoopStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*LoopStatementContext))

	return p
}

func (s *WhileStmtAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhileStmtAltContext) WHILE() antlr.TerminalNode {
	return s.GetToken(GroovyParserWHILE, 0)
}

func (s *WhileStmtAltContext) ExpressionInPar() IExpressionInParContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionInParContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionInParContext)
}

func (s *WhileStmtAltContext) Nls() INlsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INlsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *WhileStmtAltContext) Statement() IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *WhileStmtAltContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterWhileStmtAlt(s)
	}
}

func (s *WhileStmtAltContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitWhileStmtAlt(s)
	}
}

func (p *GroovyParser) LoopStatement() (localctx ILoopStatementContext) {
	localctx = NewLoopStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 178, GroovyParserRULE_loopStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1068)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case GroovyParserFOR:
		localctx = NewForStmtAltContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1049)
			p.Match(GroovyParserFOR)
		}
		{
			p.SetState(1050)
			p.Match(GroovyParserLPAREN)
		}
		{
			p.SetState(1051)
			p.ForControl()
		}
		{
			p.SetState(1052)
			p.Rparen()
		}
		{
			p.SetState(1053)
			p.Nls()
		}
		{
			p.SetState(1054)
			p.Statement()
		}

	case GroovyParserWHILE:
		localctx = NewWhileStmtAltContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1056)
			p.Match(GroovyParserWHILE)
		}
		{
			p.SetState(1057)
			p.ExpressionInPar()
		}
		{
			p.SetState(1058)
			p.Nls()
		}
		{
			p.SetState(1059)
			p.Statement()
		}

	case GroovyParserDO:
		localctx = NewDoWhileStmtAltContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1061)
			p.Match(GroovyParserDO)
		}
		{
			p.SetState(1062)
			p.Nls()
		}
		{
			p.SetState(1063)
			p.Statement()
		}
		{
			p.SetState(1064)
			p.Nls()
		}
		{
			p.SetState(1065)
			p.Match(GroovyParserWHILE)
		}
		{
			p.SetState(1066)
			p.ExpressionInPar()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IContinueStatementContext is an interface to support dynamic dispatch.
type IContinueStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsContinueStatementContext differentiates from other interfaces.
	IsContinueStatementContext()
}

type ContinueStatementContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyContinueStatementContext() *ContinueStatementContext {
	var p = new(ContinueStatementContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_continueStatement
	return p
}

func (*ContinueStatementContext) IsContinueStatementContext() {}

func NewContinueStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ContinueStatementContext {
	var p = new(ContinueStatementContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_continueStatement

	return p
}

func (s *ContinueStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ContinueStatementContext) CONTINUE() antlr.TerminalNode {
	return s.GetToken(GroovyParserCONTINUE, 0)
}

func (s *ContinueStatementContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ContinueStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ContinueStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ContinueStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterContinueStatement(s)
	}
}

func (s *ContinueStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitContinueStatement(s)
	}
}

func (p *GroovyParser) ContinueStatement() (localctx IContinueStatementContext) {
	localctx = NewContinueStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 180, GroovyParserRULE_continueStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1070)
		p.Match(GroovyParserCONTINUE)
	}
	p.SetState(1072)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 116, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1071)
			p.Identifier()
		}

	}

	return localctx
}

// IBreakStatementContext is an interface to support dynamic dispatch.
type IBreakStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBreakStatementContext differentiates from other interfaces.
	IsBreakStatementContext()
}

type BreakStatementContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyBreakStatementContext() *BreakStatementContext {
	var p = new(BreakStatementContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_breakStatement
	return p
}

func (*BreakStatementContext) IsBreakStatementContext() {}

func NewBreakStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BreakStatementContext {
	var p = new(BreakStatementContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_breakStatement

	return p
}

func (s *BreakStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *BreakStatementContext) BREAK() antlr.TerminalNode {
	return s.GetToken(GroovyParserBREAK, 0)
}

func (s *BreakStatementContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *BreakStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BreakStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BreakStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterBreakStatement(s)
	}
}

func (s *BreakStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitBreakStatement(s)
	}
}

func (p *GroovyParser) BreakStatement() (localctx IBreakStatementContext) {
	localctx = NewBreakStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 182, GroovyParserRULE_breakStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1074)
		p.Match(GroovyParserBREAK)
	}
	p.SetState(1076)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 117, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1075)
			p.Identifier()
		}

	}

	return localctx
}

// ITryCatchStatementContext is an interface to support dynamic dispatch.
type ITryCatchStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTryCatchStatementContext differentiates from other interfaces.
	IsTryCatchStatementContext()
}

type TryCatchStatementContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyTryCatchStatementContext() *TryCatchStatementContext {
	var p = new(TryCatchStatementContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_tryCatchStatement
	return p
}

func (*TryCatchStatementContext) IsTryCatchStatementContext() {}

func NewTryCatchStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TryCatchStatementContext {
	var p = new(TryCatchStatementContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_tryCatchStatement

	return p
}

func (s *TryCatchStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *TryCatchStatementContext) TRY() antlr.TerminalNode {
	return s.GetToken(GroovyParserTRY, 0)
}

func (s *TryCatchStatementContext) AllNls() []INlsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INlsContext)(nil)).Elem())
	var tst = make([]INlsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INlsContext)
		}
	}

	return tst
}

func (s *TryCatchStatementContext) Nls(i int) INlsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INlsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *TryCatchStatementContext) Block() IBlockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *TryCatchStatementContext) Resources() IResourcesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IResourcesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IResourcesContext)
}

func (s *TryCatchStatementContext) AllCatchClause() []ICatchClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICatchClauseContext)(nil)).Elem())
	var tst = make([]ICatchClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICatchClauseContext)
		}
	}

	return tst
}

func (s *TryCatchStatementContext) CatchClause(i int) ICatchClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICatchClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICatchClauseContext)
}

func (s *TryCatchStatementContext) FinallyBlock() IFinallyBlockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFinallyBlockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFinallyBlockContext)
}

func (s *TryCatchStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TryCatchStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TryCatchStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterTryCatchStatement(s)
	}
}

func (s *TryCatchStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitTryCatchStatement(s)
	}
}

func (p *GroovyParser) TryCatchStatement() (localctx ITryCatchStatementContext) {
	localctx = NewTryCatchStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 184, GroovyParserRULE_tryCatchStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1078)
		p.Match(GroovyParserTRY)
	}
	p.SetState(1080)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == GroovyParserLPAREN {
		{
			p.SetState(1079)
			p.Resources()
		}

	}
	{
		p.SetState(1082)
		p.Nls()
	}
	{
		p.SetState(1083)
		p.Block()
	}
	p.SetState(1089)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 119, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1084)
				p.Nls()
			}
			{
				p.SetState(1085)
				p.CatchClause()
			}

		}
		p.SetState(1091)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 119, p.GetParserRuleContext())
	}
	p.SetState(1095)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 120, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1092)
			p.Nls()
		}
		{
			p.SetState(1093)
			p.FinallyBlock()
		}

	}

	return localctx
}

// IAssertStatementContext is an interface to support dynamic dispatch.
type IAssertStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetCe returns the ce rule contexts.
	GetCe() IExpressionContext

	// GetMe returns the me rule contexts.
	GetMe() IExpressionContext

	// SetCe sets the ce rule contexts.
	SetCe(IExpressionContext)

	// SetMe sets the me rule contexts.
	SetMe(IExpressionContext)

	// IsAssertStatementContext differentiates from other interfaces.
	IsAssertStatementContext()
}

type AssertStatementContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
	ce     IExpressionContext
	me     IExpressionContext
}

func NewEmptyAssertStatementContext() *AssertStatementContext {
	var p = new(AssertStatementContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_assertStatement
	return p
}

func (*AssertStatementContext) IsAssertStatementContext() {}

func NewAssertStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssertStatementContext {
	var p = new(AssertStatementContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_assertStatement

	return p
}

func (s *AssertStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AssertStatementContext) GetCe() IExpressionContext { return s.ce }

func (s *AssertStatementContext) GetMe() IExpressionContext { return s.me }

func (s *AssertStatementContext) SetCe(v IExpressionContext) { s.ce = v }

func (s *AssertStatementContext) SetMe(v IExpressionContext) { s.me = v }

func (s *AssertStatementContext) ASSERT() antlr.TerminalNode {
	return s.GetToken(GroovyParserASSERT, 0)
}

func (s *AssertStatementContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *AssertStatementContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *AssertStatementContext) AllNls() []INlsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INlsContext)(nil)).Elem())
	var tst = make([]INlsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INlsContext)
		}
	}

	return tst
}

func (s *AssertStatementContext) Nls(i int) INlsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INlsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *AssertStatementContext) COLON() antlr.TerminalNode {
	return s.GetToken(GroovyParserCOLON, 0)
}

func (s *AssertStatementContext) COMMA() antlr.TerminalNode {
	return s.GetToken(GroovyParserCOMMA, 0)
}

func (s *AssertStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssertStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssertStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterAssertStatement(s)
	}
}

func (s *AssertStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitAssertStatement(s)
	}
}

func (p *GroovyParser) AssertStatement() (localctx IAssertStatementContext) {
	localctx = NewAssertStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 186, GroovyParserRULE_assertStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1097)
		p.Match(GroovyParserASSERT)
	}
	{
		p.SetState(1098)

		var _x = p.expression(0)

		localctx.(*AssertStatementContext).ce = _x
	}
	p.SetState(1104)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 121, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1099)
			p.Nls()
		}
		{
			p.SetState(1100)
			_la = p.GetTokenStream().LA(1)

			if !(_la == GroovyParserCOMMA || _la == GroovyParserCOLON) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1101)
			p.Nls()
		}
		{
			p.SetState(1102)

			var _x = p.expression(0)

			localctx.(*AssertStatementContext).me = _x
		}

	}

	return localctx
}

// IStatementContext is an interface to support dynamic dispatch.
type IStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStatementContext differentiates from other interfaces.
	IsStatementContext()
}

type StatementContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatementContext() *StatementContext {
	var p = new(StatementContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_statement
	return p
}

func (*StatementContext) IsStatementContext() {}

func NewStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatementContext {
	var p = new(StatementContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_statement

	return p
}

func (s *StatementContext) GetParser() antlr.Parser { return s.parser }

func (s *StatementContext) CopyFrom(ctx *StatementContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *StatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ConditionalStmtAltContext struct {
	*StatementContext
}

func NewConditionalStmtAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ConditionalStmtAltContext {
	var p = new(ConditionalStmtAltContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *ConditionalStmtAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConditionalStmtAltContext) ConditionalStatement() IConditionalStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConditionalStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConditionalStatementContext)
}

func (s *ConditionalStmtAltContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterConditionalStmtAlt(s)
	}
}

func (s *ConditionalStmtAltContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitConditionalStmtAlt(s)
	}
}

type EmptyStmtAltContext struct {
	*StatementContext
}

func NewEmptyStmtAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *EmptyStmtAltContext {
	var p = new(EmptyStmtAltContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *EmptyStmtAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EmptyStmtAltContext) SEMI() antlr.TerminalNode {
	return s.GetToken(GroovyParserSEMI, 0)
}

func (s *EmptyStmtAltContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterEmptyStmtAlt(s)
	}
}

func (s *EmptyStmtAltContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitEmptyStmtAlt(s)
	}
}

type BlockStmtAltContext struct {
	*StatementContext
}

func NewBlockStmtAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BlockStmtAltContext {
	var p = new(BlockStmtAltContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *BlockStmtAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BlockStmtAltContext) Block() IBlockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *BlockStmtAltContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterBlockStmtAlt(s)
	}
}

func (s *BlockStmtAltContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitBlockStmtAlt(s)
	}
}

type TryCatchStmtAltContext struct {
	*StatementContext
}

func NewTryCatchStmtAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TryCatchStmtAltContext {
	var p = new(TryCatchStmtAltContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *TryCatchStmtAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TryCatchStmtAltContext) TryCatchStatement() ITryCatchStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITryCatchStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITryCatchStatementContext)
}

func (s *TryCatchStmtAltContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterTryCatchStmtAlt(s)
	}
}

func (s *TryCatchStmtAltContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitTryCatchStmtAlt(s)
	}
}

type BreakStmtAltContext struct {
	*StatementContext
}

func NewBreakStmtAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BreakStmtAltContext {
	var p = new(BreakStmtAltContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *BreakStmtAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BreakStmtAltContext) BreakStatement() IBreakStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBreakStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBreakStatementContext)
}

func (s *BreakStmtAltContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterBreakStmtAlt(s)
	}
}

func (s *BreakStmtAltContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitBreakStmtAlt(s)
	}
}

type ContinueStmtAltContext struct {
	*StatementContext
}

func NewContinueStmtAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ContinueStmtAltContext {
	var p = new(ContinueStmtAltContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *ContinueStmtAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ContinueStmtAltContext) ContinueStatement() IContinueStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IContinueStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IContinueStatementContext)
}

func (s *ContinueStmtAltContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterContinueStmtAlt(s)
	}
}

func (s *ContinueStmtAltContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitContinueStmtAlt(s)
	}
}

type AssertStmtAltContext struct {
	*StatementContext
}

func NewAssertStmtAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AssertStmtAltContext {
	var p = new(AssertStmtAltContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *AssertStmtAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssertStmtAltContext) AssertStatement() IAssertStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAssertStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAssertStatementContext)
}

func (s *AssertStmtAltContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterAssertStmtAlt(s)
	}
}

func (s *AssertStmtAltContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitAssertStmtAlt(s)
	}
}

type LoopStmtAltContext struct {
	*StatementContext
}

func NewLoopStmtAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LoopStmtAltContext {
	var p = new(LoopStmtAltContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *LoopStmtAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LoopStmtAltContext) LoopStatement() ILoopStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILoopStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILoopStatementContext)
}

func (s *LoopStmtAltContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterLoopStmtAlt(s)
	}
}

func (s *LoopStmtAltContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitLoopStmtAlt(s)
	}
}

type SynchronizedStmtAltContext struct {
	*StatementContext
}

func NewSynchronizedStmtAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SynchronizedStmtAltContext {
	var p = new(SynchronizedStmtAltContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *SynchronizedStmtAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SynchronizedStmtAltContext) SYNCHRONIZED() antlr.TerminalNode {
	return s.GetToken(GroovyParserSYNCHRONIZED, 0)
}

func (s *SynchronizedStmtAltContext) ExpressionInPar() IExpressionInParContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionInParContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionInParContext)
}

func (s *SynchronizedStmtAltContext) Nls() INlsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INlsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *SynchronizedStmtAltContext) Block() IBlockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *SynchronizedStmtAltContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterSynchronizedStmtAlt(s)
	}
}

func (s *SynchronizedStmtAltContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitSynchronizedStmtAlt(s)
	}
}

type ExpressionStmtAltContext struct {
	*StatementContext
}

func NewExpressionStmtAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExpressionStmtAltContext {
	var p = new(ExpressionStmtAltContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *ExpressionStmtAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionStmtAltContext) StatementExpression() IStatementExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatementExpressionContext)
}

func (s *ExpressionStmtAltContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterExpressionStmtAlt(s)
	}
}

func (s *ExpressionStmtAltContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitExpressionStmtAlt(s)
	}
}

type MethodDeclarationStmtAltContext struct {
	*StatementContext
}

func NewMethodDeclarationStmtAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *MethodDeclarationStmtAltContext {
	var p = new(MethodDeclarationStmtAltContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *MethodDeclarationStmtAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MethodDeclarationStmtAltContext) MethodDeclaration() IMethodDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMethodDeclarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMethodDeclarationContext)
}

func (s *MethodDeclarationStmtAltContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterMethodDeclarationStmtAlt(s)
	}
}

func (s *MethodDeclarationStmtAltContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitMethodDeclarationStmtAlt(s)
	}
}

type LocalVariableDeclarationStmtAltContext struct {
	*StatementContext
}

func NewLocalVariableDeclarationStmtAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LocalVariableDeclarationStmtAltContext {
	var p = new(LocalVariableDeclarationStmtAltContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *LocalVariableDeclarationStmtAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LocalVariableDeclarationStmtAltContext) LocalVariableDeclaration() ILocalVariableDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILocalVariableDeclarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILocalVariableDeclarationContext)
}

func (s *LocalVariableDeclarationStmtAltContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterLocalVariableDeclarationStmtAlt(s)
	}
}

func (s *LocalVariableDeclarationStmtAltContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitLocalVariableDeclarationStmtAlt(s)
	}
}

type ReturnStmtAltContext struct {
	*StatementContext
}

func NewReturnStmtAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ReturnStmtAltContext {
	var p = new(ReturnStmtAltContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *ReturnStmtAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReturnStmtAltContext) RETURN() antlr.TerminalNode {
	return s.GetToken(GroovyParserRETURN, 0)
}

func (s *ReturnStmtAltContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ReturnStmtAltContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterReturnStmtAlt(s)
	}
}

func (s *ReturnStmtAltContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitReturnStmtAlt(s)
	}
}

type ThrowStmtAltContext struct {
	*StatementContext
}

func NewThrowStmtAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ThrowStmtAltContext {
	var p = new(ThrowStmtAltContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *ThrowStmtAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ThrowStmtAltContext) THROW() antlr.TerminalNode {
	return s.GetToken(GroovyParserTHROW, 0)
}

func (s *ThrowStmtAltContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ThrowStmtAltContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterThrowStmtAlt(s)
	}
}

func (s *ThrowStmtAltContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitThrowStmtAlt(s)
	}
}

type LabeledStmtAltContext struct {
	*StatementContext
}

func NewLabeledStmtAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabeledStmtAltContext {
	var p = new(LabeledStmtAltContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *LabeledStmtAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabeledStmtAltContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *LabeledStmtAltContext) COLON() antlr.TerminalNode {
	return s.GetToken(GroovyParserCOLON, 0)
}

func (s *LabeledStmtAltContext) Nls() INlsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INlsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *LabeledStmtAltContext) Statement() IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *LabeledStmtAltContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterLabeledStmtAlt(s)
	}
}

func (s *LabeledStmtAltContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitLabeledStmtAlt(s)
	}
}

func (p *GroovyParser) Statement() (localctx IStatementContext) {
	localctx = NewStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 188, GroovyParserRULE_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1134)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 123, p.GetParserRuleContext()) {
	case 1:
		localctx = NewBlockStmtAltContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1106)
			p.Block()
		}

	case 2:
		localctx = NewConditionalStmtAltContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1107)
			p.ConditionalStatement()
		}

	case 3:
		localctx = NewLoopStmtAltContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1108)
			p.LoopStatement()
		}

	case 4:
		localctx = NewTryCatchStmtAltContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1109)
			p.TryCatchStatement()
		}

	case 5:
		localctx = NewSynchronizedStmtAltContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1110)
			p.Match(GroovyParserSYNCHRONIZED)
		}
		{
			p.SetState(1111)
			p.ExpressionInPar()
		}
		{
			p.SetState(1112)
			p.Nls()
		}
		{
			p.SetState(1113)
			p.Block()
		}

	case 6:
		localctx = NewReturnStmtAltContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1115)
			p.Match(GroovyParserRETURN)
		}
		p.SetState(1117)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 122, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1116)
				p.expression(0)
			}

		}

	case 7:
		localctx = NewThrowStmtAltContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1119)
			p.Match(GroovyParserTHROW)
		}
		{
			p.SetState(1120)
			p.expression(0)
		}

	case 8:
		localctx = NewBreakStmtAltContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1121)
			p.BreakStatement()
		}

	case 9:
		localctx = NewContinueStmtAltContext(p, localctx)
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1122)
			p.ContinueStatement()
		}

	case 10:
		localctx = NewLabeledStmtAltContext(p, localctx)
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1123)
			p.Identifier()
		}
		{
			p.SetState(1124)
			p.Match(GroovyParserCOLON)
		}
		{
			p.SetState(1125)
			p.Nls()
		}
		{
			p.SetState(1126)
			p.Statement()
		}

	case 11:
		localctx = NewAssertStmtAltContext(p, localctx)
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(1128)
			p.AssertStatement()
		}

	case 12:
		localctx = NewLocalVariableDeclarationStmtAltContext(p, localctx)
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(1129)
			p.LocalVariableDeclaration()
		}

	case 13:
		localctx = NewMethodDeclarationStmtAltContext(p, localctx)
		p.EnterOuterAlt(localctx, 13)
		p.SetState(1130)

		if !(!SemanticPredicates.isInvalidMethodDeclaration(_input)) {
			panic(antlr.NewFailedPredicateException(p, " !SemanticPredicates.isInvalidMethodDeclaration(_input) ", ""))
		}
		{
			p.SetState(1131)
			p.MethodDeclaration(3, 9)
		}

	case 14:
		localctx = NewExpressionStmtAltContext(p, localctx)
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(1132)
			p.StatementExpression()
		}

	case 15:
		localctx = NewEmptyStmtAltContext(p, localctx)
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(1133)
			p.Match(GroovyParserSEMI)
		}

	}

	return localctx
}

// ICatchClauseContext is an interface to support dynamic dispatch.
type ICatchClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCatchClauseContext differentiates from other interfaces.
	IsCatchClauseContext()
}

type CatchClauseContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyCatchClauseContext() *CatchClauseContext {
	var p = new(CatchClauseContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_catchClause
	return p
}

func (*CatchClauseContext) IsCatchClauseContext() {}

func NewCatchClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CatchClauseContext {
	var p = new(CatchClauseContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_catchClause

	return p
}

func (s *CatchClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *CatchClauseContext) CATCH() antlr.TerminalNode {
	return s.GetToken(GroovyParserCATCH, 0)
}

func (s *CatchClauseContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(GroovyParserLPAREN, 0)
}

func (s *CatchClauseContext) VariableModifiersOpt() IVariableModifiersOptContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableModifiersOptContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariableModifiersOptContext)
}

func (s *CatchClauseContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CatchClauseContext) Rparen() IRparenContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRparenContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRparenContext)
}

func (s *CatchClauseContext) Nls() INlsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INlsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *CatchClauseContext) Block() IBlockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *CatchClauseContext) CatchType() ICatchTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICatchTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICatchTypeContext)
}

func (s *CatchClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CatchClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CatchClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterCatchClause(s)
	}
}

func (s *CatchClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitCatchClause(s)
	}
}

func (p *GroovyParser) CatchClause() (localctx ICatchClauseContext) {
	localctx = NewCatchClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 190, GroovyParserRULE_catchClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1136)
		p.Match(GroovyParserCATCH)
	}
	{
		p.SetState(1137)
		p.Match(GroovyParserLPAREN)
	}
	{
		p.SetState(1138)
		p.VariableModifiersOpt()
	}
	p.SetState(1140)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 124, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1139)
			p.CatchType()
		}

	}
	{
		p.SetState(1142)
		p.Identifier()
	}
	{
		p.SetState(1143)
		p.Rparen()
	}
	{
		p.SetState(1144)
		p.Nls()
	}
	{
		p.SetState(1145)
		p.Block()
	}

	return localctx
}

// ICatchTypeContext is an interface to support dynamic dispatch.
type ICatchTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCatchTypeContext differentiates from other interfaces.
	IsCatchTypeContext()
}

type CatchTypeContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyCatchTypeContext() *CatchTypeContext {
	var p = new(CatchTypeContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_catchType
	return p
}

func (*CatchTypeContext) IsCatchTypeContext() {}

func NewCatchTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CatchTypeContext {
	var p = new(CatchTypeContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_catchType

	return p
}

func (s *CatchTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *CatchTypeContext) AllQualifiedClassName() []IQualifiedClassNameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IQualifiedClassNameContext)(nil)).Elem())
	var tst = make([]IQualifiedClassNameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IQualifiedClassNameContext)
		}
	}

	return tst
}

func (s *CatchTypeContext) QualifiedClassName(i int) IQualifiedClassNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedClassNameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IQualifiedClassNameContext)
}

func (s *CatchTypeContext) AllBITOR() []antlr.TerminalNode {
	return s.GetTokens(GroovyParserBITOR)
}

func (s *CatchTypeContext) BITOR(i int) antlr.TerminalNode {
	return s.GetToken(GroovyParserBITOR, i)
}

func (s *CatchTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CatchTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CatchTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterCatchType(s)
	}
}

func (s *CatchTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitCatchType(s)
	}
}

func (p *GroovyParser) CatchType() (localctx ICatchTypeContext) {
	localctx = NewCatchTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 192, GroovyParserRULE_catchType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1147)
		p.QualifiedClassName()
	}
	p.SetState(1152)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 125, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1148)
				p.Match(GroovyParserBITOR)
			}
			{
				p.SetState(1149)
				p.QualifiedClassName()
			}

		}
		p.SetState(1154)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 125, p.GetParserRuleContext())
	}

	return localctx
}

// IFinallyBlockContext is an interface to support dynamic dispatch.
type IFinallyBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFinallyBlockContext differentiates from other interfaces.
	IsFinallyBlockContext()
}

type FinallyBlockContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyFinallyBlockContext() *FinallyBlockContext {
	var p = new(FinallyBlockContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_finallyBlock
	return p
}

func (*FinallyBlockContext) IsFinallyBlockContext() {}

func NewFinallyBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FinallyBlockContext {
	var p = new(FinallyBlockContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_finallyBlock

	return p
}

func (s *FinallyBlockContext) GetParser() antlr.Parser { return s.parser }

func (s *FinallyBlockContext) FINALLY() antlr.TerminalNode {
	return s.GetToken(GroovyParserFINALLY, 0)
}

func (s *FinallyBlockContext) Nls() INlsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INlsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *FinallyBlockContext) Block() IBlockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *FinallyBlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FinallyBlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FinallyBlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterFinallyBlock(s)
	}
}

func (s *FinallyBlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitFinallyBlock(s)
	}
}

func (p *GroovyParser) FinallyBlock() (localctx IFinallyBlockContext) {
	localctx = NewFinallyBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 194, GroovyParserRULE_finallyBlock)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1155)
		p.Match(GroovyParserFINALLY)
	}
	{
		p.SetState(1156)
		p.Nls()
	}
	{
		p.SetState(1157)
		p.Block()
	}

	return localctx
}

// IResourcesContext is an interface to support dynamic dispatch.
type IResourcesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsResourcesContext differentiates from other interfaces.
	IsResourcesContext()
}

type ResourcesContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyResourcesContext() *ResourcesContext {
	var p = new(ResourcesContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_resources
	return p
}

func (*ResourcesContext) IsResourcesContext() {}

func NewResourcesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ResourcesContext {
	var p = new(ResourcesContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_resources

	return p
}

func (s *ResourcesContext) GetParser() antlr.Parser { return s.parser }

func (s *ResourcesContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(GroovyParserLPAREN, 0)
}

func (s *ResourcesContext) Nls() INlsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INlsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *ResourcesContext) ResourceList() IResourceListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IResourceListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IResourceListContext)
}

func (s *ResourcesContext) Rparen() IRparenContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRparenContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRparenContext)
}

func (s *ResourcesContext) Sep() ISepContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISepContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISepContext)
}

func (s *ResourcesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ResourcesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ResourcesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterResources(s)
	}
}

func (s *ResourcesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitResources(s)
	}
}

func (p *GroovyParser) Resources() (localctx IResourcesContext) {
	localctx = NewResourcesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 196, GroovyParserRULE_resources)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1159)
		p.Match(GroovyParserLPAREN)
	}
	{
		p.SetState(1160)
		p.Nls()
	}
	{
		p.SetState(1161)
		p.ResourceList()
	}
	p.SetState(1163)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 126, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1162)
			p.Sep()
		}

	}
	{
		p.SetState(1165)
		p.Rparen()
	}

	return localctx
}

// IResourceListContext is an interface to support dynamic dispatch.
type IResourceListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsResourceListContext differentiates from other interfaces.
	IsResourceListContext()
}

type ResourceListContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyResourceListContext() *ResourceListContext {
	var p = new(ResourceListContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_resourceList
	return p
}

func (*ResourceListContext) IsResourceListContext() {}

func NewResourceListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ResourceListContext {
	var p = new(ResourceListContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_resourceList

	return p
}

func (s *ResourceListContext) GetParser() antlr.Parser { return s.parser }

func (s *ResourceListContext) AllResource() []IResourceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IResourceContext)(nil)).Elem())
	var tst = make([]IResourceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IResourceContext)
		}
	}

	return tst
}

func (s *ResourceListContext) Resource(i int) IResourceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IResourceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IResourceContext)
}

func (s *ResourceListContext) AllSep() []ISepContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISepContext)(nil)).Elem())
	var tst = make([]ISepContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISepContext)
		}
	}

	return tst
}

func (s *ResourceListContext) Sep(i int) ISepContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISepContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISepContext)
}

func (s *ResourceListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ResourceListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ResourceListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterResourceList(s)
	}
}

func (s *ResourceListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitResourceList(s)
	}
}

func (p *GroovyParser) ResourceList() (localctx IResourceListContext) {
	localctx = NewResourceListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 198, GroovyParserRULE_resourceList)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1167)
		p.Resource()
	}
	p.SetState(1173)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 127, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1168)
				p.Sep()
			}
			{
				p.SetState(1169)
				p.Resource()
			}

		}
		p.SetState(1175)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 127, p.GetParserRuleContext())
	}

	return localctx
}

// IResourceContext is an interface to support dynamic dispatch.
type IResourceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsResourceContext differentiates from other interfaces.
	IsResourceContext()
}

type ResourceContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyResourceContext() *ResourceContext {
	var p = new(ResourceContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_resource
	return p
}

func (*ResourceContext) IsResourceContext() {}

func NewResourceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ResourceContext {
	var p = new(ResourceContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_resource

	return p
}

func (s *ResourceContext) GetParser() antlr.Parser { return s.parser }

func (s *ResourceContext) LocalVariableDeclaration() ILocalVariableDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILocalVariableDeclarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILocalVariableDeclarationContext)
}

func (s *ResourceContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ResourceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ResourceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ResourceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterResource(s)
	}
}

func (s *ResourceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitResource(s)
	}
}

func (p *GroovyParser) Resource() (localctx IResourceContext) {
	localctx = NewResourceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 200, GroovyParserRULE_resource)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1178)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 128, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1176)
			p.LocalVariableDeclaration()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1177)
			p.expression(0)
		}

	}

	return localctx
}

// ISwitchBlockStatementGroupContext is an interface to support dynamic dispatch.
type ISwitchBlockStatementGroupContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSwitchBlockStatementGroupContext differentiates from other interfaces.
	IsSwitchBlockStatementGroupContext()
}

type SwitchBlockStatementGroupContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptySwitchBlockStatementGroupContext() *SwitchBlockStatementGroupContext {
	var p = new(SwitchBlockStatementGroupContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_switchBlockStatementGroup
	return p
}

func (*SwitchBlockStatementGroupContext) IsSwitchBlockStatementGroupContext() {}

func NewSwitchBlockStatementGroupContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SwitchBlockStatementGroupContext {
	var p = new(SwitchBlockStatementGroupContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_switchBlockStatementGroup

	return p
}

func (s *SwitchBlockStatementGroupContext) GetParser() antlr.Parser { return s.parser }

func (s *SwitchBlockStatementGroupContext) BlockStatements() IBlockStatementsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlockStatementsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlockStatementsContext)
}

func (s *SwitchBlockStatementGroupContext) AllSwitchLabel() []ISwitchLabelContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISwitchLabelContext)(nil)).Elem())
	var tst = make([]ISwitchLabelContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISwitchLabelContext)
		}
	}

	return tst
}

func (s *SwitchBlockStatementGroupContext) SwitchLabel(i int) ISwitchLabelContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISwitchLabelContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISwitchLabelContext)
}

func (s *SwitchBlockStatementGroupContext) AllNls() []INlsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INlsContext)(nil)).Elem())
	var tst = make([]INlsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INlsContext)
		}
	}

	return tst
}

func (s *SwitchBlockStatementGroupContext) Nls(i int) INlsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INlsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *SwitchBlockStatementGroupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SwitchBlockStatementGroupContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SwitchBlockStatementGroupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterSwitchBlockStatementGroup(s)
	}
}

func (s *SwitchBlockStatementGroupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitSwitchBlockStatementGroup(s)
	}
}

func (p *GroovyParser) SwitchBlockStatementGroup() (localctx ISwitchBlockStatementGroupContext) {
	localctx = NewSwitchBlockStatementGroupContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 202, GroovyParserRULE_switchBlockStatementGroup)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1183)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(1180)
				p.SwitchLabel()
			}
			{
				p.SetState(1181)
				p.Nls()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(1185)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 129, p.GetParserRuleContext())
	}
	{
		p.SetState(1187)
		p.BlockStatements()
	}

	return localctx
}

// ISwitchLabelContext is an interface to support dynamic dispatch.
type ISwitchLabelContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSwitchLabelContext differentiates from other interfaces.
	IsSwitchLabelContext()
}

type SwitchLabelContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptySwitchLabelContext() *SwitchLabelContext {
	var p = new(SwitchLabelContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_switchLabel
	return p
}

func (*SwitchLabelContext) IsSwitchLabelContext() {}

func NewSwitchLabelContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SwitchLabelContext {
	var p = new(SwitchLabelContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_switchLabel

	return p
}

func (s *SwitchLabelContext) GetParser() antlr.Parser { return s.parser }

func (s *SwitchLabelContext) CASE() antlr.TerminalNode {
	return s.GetToken(GroovyParserCASE, 0)
}

func (s *SwitchLabelContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SwitchLabelContext) COLON() antlr.TerminalNode {
	return s.GetToken(GroovyParserCOLON, 0)
}

func (s *SwitchLabelContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(GroovyParserDEFAULT, 0)
}

func (s *SwitchLabelContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SwitchLabelContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SwitchLabelContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterSwitchLabel(s)
	}
}

func (s *SwitchLabelContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitSwitchLabel(s)
	}
}

func (p *GroovyParser) SwitchLabel() (localctx ISwitchLabelContext) {
	localctx = NewSwitchLabelContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 204, GroovyParserRULE_switchLabel)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1195)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case GroovyParserCASE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1189)
			p.Match(GroovyParserCASE)
		}
		{
			p.SetState(1190)
			p.expression(0)
		}
		{
			p.SetState(1191)
			p.Match(GroovyParserCOLON)
		}

	case GroovyParserDEFAULT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1193)
			p.Match(GroovyParserDEFAULT)
		}
		{
			p.SetState(1194)
			p.Match(GroovyParserCOLON)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IForControlContext is an interface to support dynamic dispatch.
type IForControlContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsForControlContext differentiates from other interfaces.
	IsForControlContext()
}

type ForControlContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyForControlContext() *ForControlContext {
	var p = new(ForControlContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_forControl
	return p
}

func (*ForControlContext) IsForControlContext() {}

func NewForControlContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForControlContext {
	var p = new(ForControlContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_forControl

	return p
}

func (s *ForControlContext) GetParser() antlr.Parser { return s.parser }

func (s *ForControlContext) EnhancedForControl() IEnhancedForControlContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnhancedForControlContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEnhancedForControlContext)
}

func (s *ForControlContext) ClassicalForControl() IClassicalForControlContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClassicalForControlContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClassicalForControlContext)
}

func (s *ForControlContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForControlContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ForControlContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterForControl(s)
	}
}

func (s *ForControlContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitForControl(s)
	}
}

func (p *GroovyParser) ForControl() (localctx IForControlContext) {
	localctx = NewForControlContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 206, GroovyParserRULE_forControl)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1199)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 131, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1197)
			p.EnhancedForControl()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1198)
			p.ClassicalForControl()
		}

	}

	return localctx
}

// IEnhancedForControlContext is an interface to support dynamic dispatch.
type IEnhancedForControlContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnhancedForControlContext differentiates from other interfaces.
	IsEnhancedForControlContext()
}

type EnhancedForControlContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnhancedForControlContext() *EnhancedForControlContext {
	var p = new(EnhancedForControlContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_enhancedForControl
	return p
}

func (*EnhancedForControlContext) IsEnhancedForControlContext() {}

func NewEnhancedForControlContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnhancedForControlContext {
	var p = new(EnhancedForControlContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_enhancedForControl

	return p
}

func (s *EnhancedForControlContext) GetParser() antlr.Parser { return s.parser }

func (s *EnhancedForControlContext) VariableModifiersOpt() IVariableModifiersOptContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableModifiersOptContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariableModifiersOptContext)
}

func (s *EnhancedForControlContext) VariableDeclaratorId() IVariableDeclaratorIdContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableDeclaratorIdContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariableDeclaratorIdContext)
}

func (s *EnhancedForControlContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *EnhancedForControlContext) COLON() antlr.TerminalNode {
	return s.GetToken(GroovyParserCOLON, 0)
}

func (s *EnhancedForControlContext) IN() antlr.TerminalNode {
	return s.GetToken(GroovyParserIN, 0)
}

func (s *EnhancedForControlContext) TypeType() ITypeTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeTypeContext)
}

func (s *EnhancedForControlContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnhancedForControlContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnhancedForControlContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterEnhancedForControl(s)
	}
}

func (s *EnhancedForControlContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitEnhancedForControl(s)
	}
}

func (p *GroovyParser) EnhancedForControl() (localctx IEnhancedForControlContext) {
	localctx = NewEnhancedForControlContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 208, GroovyParserRULE_enhancedForControl)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1201)
		p.VariableModifiersOpt()
	}
	p.SetState(1203)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 132, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1202)
			p.TypeType()
		}

	}
	{
		p.SetState(1205)
		p.VariableDeclaratorId()
	}
	{
		p.SetState(1206)
		_la = p.GetTokenStream().LA(1)

		if !(_la == GroovyParserIN || _la == GroovyParserCOLON) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(1207)
		p.expression(0)
	}

	return localctx
}

// IClassicalForControlContext is an interface to support dynamic dispatch.
type IClassicalForControlContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClassicalForControlContext differentiates from other interfaces.
	IsClassicalForControlContext()
}

type ClassicalForControlContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassicalForControlContext() *ClassicalForControlContext {
	var p = new(ClassicalForControlContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_classicalForControl
	return p
}

func (*ClassicalForControlContext) IsClassicalForControlContext() {}

func NewClassicalForControlContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassicalForControlContext {
	var p = new(ClassicalForControlContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_classicalForControl

	return p
}

func (s *ClassicalForControlContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassicalForControlContext) AllSEMI() []antlr.TerminalNode {
	return s.GetTokens(GroovyParserSEMI)
}

func (s *ClassicalForControlContext) SEMI(i int) antlr.TerminalNode {
	return s.GetToken(GroovyParserSEMI, i)
}

func (s *ClassicalForControlContext) ForInit() IForInitContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IForInitContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IForInitContext)
}

func (s *ClassicalForControlContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ClassicalForControlContext) ForUpdate() IForUpdateContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IForUpdateContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IForUpdateContext)
}

func (s *ClassicalForControlContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassicalForControlContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassicalForControlContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterClassicalForControl(s)
	}
}

func (s *ClassicalForControlContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitClassicalForControl(s)
	}
}

func (p *GroovyParser) ClassicalForControl() (localctx IClassicalForControlContext) {
	localctx = NewClassicalForControlContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 210, GroovyParserRULE_classicalForControl)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1210)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 133, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1209)
			p.ForInit()
		}

	}
	{
		p.SetState(1212)
		p.Match(GroovyParserSEMI)
	}
	p.SetState(1214)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 134, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1213)
			p.expression(0)
		}

	}
	{
		p.SetState(1216)
		p.Match(GroovyParserSEMI)
	}
	p.SetState(1218)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 135, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1217)
			p.ForUpdate()
		}

	}

	return localctx
}

// IForInitContext is an interface to support dynamic dispatch.
type IForInitContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsForInitContext differentiates from other interfaces.
	IsForInitContext()
}

type ForInitContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyForInitContext() *ForInitContext {
	var p = new(ForInitContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_forInit
	return p
}

func (*ForInitContext) IsForInitContext() {}

func NewForInitContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForInitContext {
	var p = new(ForInitContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_forInit

	return p
}

func (s *ForInitContext) GetParser() antlr.Parser { return s.parser }

func (s *ForInitContext) LocalVariableDeclaration() ILocalVariableDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILocalVariableDeclarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILocalVariableDeclarationContext)
}

func (s *ForInitContext) ExpressionList() IExpressionListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *ForInitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForInitContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ForInitContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterForInit(s)
	}
}

func (s *ForInitContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitForInit(s)
	}
}

func (p *GroovyParser) ForInit() (localctx IForInitContext) {
	localctx = NewForInitContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 212, GroovyParserRULE_forInit)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1222)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 136, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1220)
			p.LocalVariableDeclaration()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1221)
			p.ExpressionList(false)
		}

	}

	return localctx
}

// IForUpdateContext is an interface to support dynamic dispatch.
type IForUpdateContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsForUpdateContext differentiates from other interfaces.
	IsForUpdateContext()
}

type ForUpdateContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyForUpdateContext() *ForUpdateContext {
	var p = new(ForUpdateContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_forUpdate
	return p
}

func (*ForUpdateContext) IsForUpdateContext() {}

func NewForUpdateContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForUpdateContext {
	var p = new(ForUpdateContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_forUpdate

	return p
}

func (s *ForUpdateContext) GetParser() antlr.Parser { return s.parser }

func (s *ForUpdateContext) ExpressionList() IExpressionListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *ForUpdateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForUpdateContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ForUpdateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterForUpdate(s)
	}
}

func (s *ForUpdateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitForUpdate(s)
	}
}

func (p *GroovyParser) ForUpdate() (localctx IForUpdateContext) {
	localctx = NewForUpdateContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 214, GroovyParserRULE_forUpdate)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1224)
		p.ExpressionList(false)
	}

	return localctx
}

// ICastParExpressionContext is an interface to support dynamic dispatch.
type ICastParExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCastParExpressionContext differentiates from other interfaces.
	IsCastParExpressionContext()
}

type CastParExpressionContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyCastParExpressionContext() *CastParExpressionContext {
	var p = new(CastParExpressionContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_castParExpression
	return p
}

func (*CastParExpressionContext) IsCastParExpressionContext() {}

func NewCastParExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CastParExpressionContext {
	var p = new(CastParExpressionContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_castParExpression

	return p
}

func (s *CastParExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *CastParExpressionContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(GroovyParserLPAREN, 0)
}

func (s *CastParExpressionContext) TypeType() ITypeTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeTypeContext)
}

func (s *CastParExpressionContext) Rparen() IRparenContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRparenContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRparenContext)
}

func (s *CastParExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CastParExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CastParExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterCastParExpression(s)
	}
}

func (s *CastParExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitCastParExpression(s)
	}
}

func (p *GroovyParser) CastParExpression() (localctx ICastParExpressionContext) {
	localctx = NewCastParExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 216, GroovyParserRULE_castParExpression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1226)
		p.Match(GroovyParserLPAREN)
	}
	{
		p.SetState(1227)
		p.TypeType()
	}
	{
		p.SetState(1228)
		p.Rparen()
	}

	return localctx
}

// IParExpressionContext is an interface to support dynamic dispatch.
type IParExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParExpressionContext differentiates from other interfaces.
	IsParExpressionContext()
}

type ParExpressionContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyParExpressionContext() *ParExpressionContext {
	var p = new(ParExpressionContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_parExpression
	return p
}

func (*ParExpressionContext) IsParExpressionContext() {}

func NewParExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParExpressionContext {
	var p = new(ParExpressionContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_parExpression

	return p
}

func (s *ParExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ParExpressionContext) ExpressionInPar() IExpressionInParContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionInParContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionInParContext)
}

func (s *ParExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterParExpression(s)
	}
}

func (s *ParExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitParExpression(s)
	}
}

func (p *GroovyParser) ParExpression() (localctx IParExpressionContext) {
	localctx = NewParExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 218, GroovyParserRULE_parExpression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1230)
		p.ExpressionInPar()
	}

	return localctx
}

// IExpressionInParContext is an interface to support dynamic dispatch.
type IExpressionInParContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpressionInParContext differentiates from other interfaces.
	IsExpressionInParContext()
}

type ExpressionInParContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionInParContext() *ExpressionInParContext {
	var p = new(ExpressionInParContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_expressionInPar
	return p
}

func (*ExpressionInParContext) IsExpressionInParContext() {}

func NewExpressionInParContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionInParContext {
	var p = new(ExpressionInParContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_expressionInPar

	return p
}

func (s *ExpressionInParContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionInParContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(GroovyParserLPAREN, 0)
}

func (s *ExpressionInParContext) EnhancedStatementExpression() IEnhancedStatementExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnhancedStatementExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEnhancedStatementExpressionContext)
}

func (s *ExpressionInParContext) Rparen() IRparenContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRparenContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRparenContext)
}

func (s *ExpressionInParContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionInParContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionInParContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterExpressionInPar(s)
	}
}

func (s *ExpressionInParContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitExpressionInPar(s)
	}
}

func (p *GroovyParser) ExpressionInPar() (localctx IExpressionInParContext) {
	localctx = NewExpressionInParContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 220, GroovyParserRULE_expressionInPar)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1232)
		p.Match(GroovyParserLPAREN)
	}
	{
		p.SetState(1233)
		p.EnhancedStatementExpression()
	}
	{
		p.SetState(1234)
		p.Rparen()
	}

	return localctx
}

// IExpressionListContext is an interface to support dynamic dispatch.
type IExpressionListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetCanSpread returns the canSpread attribute.
	GetCanSpread() boolean

	// SetCanSpread sets the canSpread attribute.
	SetCanSpread(boolean)

	// IsExpressionListContext differentiates from other interfaces.
	IsExpressionListContext()
}

type ExpressionListContext struct {
	*GroovyParserRuleContext
	parser    antlr.Parser
	canSpread boolean
}

func NewEmptyExpressionListContext() *ExpressionListContext {
	var p = new(ExpressionListContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_expressionList
	return p
}

func (*ExpressionListContext) IsExpressionListContext() {}

func NewExpressionListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int, canSpread boolean) *ExpressionListContext {
	var p = new(ExpressionListContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_expressionList

	p.canSpread = canSpread

	return p
}

func (s *ExpressionListContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionListContext) GetCanSpread() boolean { return s.canSpread }

func (s *ExpressionListContext) SetCanSpread(v boolean) { s.canSpread = v }

func (s *ExpressionListContext) AllExpressionListElement() []IExpressionListElementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionListElementContext)(nil)).Elem())
	var tst = make([]IExpressionListElementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionListElementContext)
		}
	}

	return tst
}

func (s *ExpressionListContext) ExpressionListElement(i int) IExpressionListElementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionListElementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionListElementContext)
}

func (s *ExpressionListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(GroovyParserCOMMA)
}

func (s *ExpressionListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(GroovyParserCOMMA, i)
}

func (s *ExpressionListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterExpressionList(s)
	}
}

func (s *ExpressionListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitExpressionList(s)
	}
}

func (p *GroovyParser) ExpressionList(canSpread boolean) (localctx IExpressionListContext) {
	localctx = NewExpressionListContext(p, p.GetParserRuleContext(), p.GetState(), canSpread)
	p.EnterRule(localctx, 222, GroovyParserRULE_expressionList)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1236)
		p.ExpressionListElement(localctx.(*ExpressionListContext).canSpread)
	}
	p.SetState(1241)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 137, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1237)
				p.Match(GroovyParserCOMMA)
			}
			{
				p.SetState(1238)
				p.ExpressionListElement(localctx.(*ExpressionListContext).canSpread)
			}

		}
		p.SetState(1243)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 137, p.GetParserRuleContext())
	}

	return localctx
}

// IExpressionListElementContext is an interface to support dynamic dispatch.
type IExpressionListElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetCanSpread returns the canSpread attribute.
	GetCanSpread() boolean

	// SetCanSpread sets the canSpread attribute.
	SetCanSpread(boolean)

	// IsExpressionListElementContext differentiates from other interfaces.
	IsExpressionListElementContext()
}

type ExpressionListElementContext struct {
	*GroovyParserRuleContext
	parser    antlr.Parser
	canSpread boolean
}

func NewEmptyExpressionListElementContext() *ExpressionListElementContext {
	var p = new(ExpressionListElementContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_expressionListElement
	return p
}

func (*ExpressionListElementContext) IsExpressionListElementContext() {}

func NewExpressionListElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int, canSpread boolean) *ExpressionListElementContext {
	var p = new(ExpressionListElementContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_expressionListElement

	p.canSpread = canSpread

	return p
}

func (s *ExpressionListElementContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionListElementContext) GetCanSpread() boolean { return s.canSpread }

func (s *ExpressionListElementContext) SetCanSpread(v boolean) { s.canSpread = v }

func (s *ExpressionListElementContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ExpressionListElementContext) MUL() antlr.TerminalNode {
	return s.GetToken(GroovyParserMUL, 0)
}

func (s *ExpressionListElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionListElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionListElementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterExpressionListElement(s)
	}
}

func (s *ExpressionListElementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitExpressionListElement(s)
	}
}

func (p *GroovyParser) ExpressionListElement(canSpread boolean) (localctx IExpressionListElementContext) {
	localctx = NewExpressionListElementContext(p, p.GetParserRuleContext(), p.GetState(), canSpread)
	p.EnterRule(localctx, 224, GroovyParserRULE_expressionListElement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1247)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 138, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1244)
			p.Match(GroovyParserMUL)
		}
		require(localctx.(*ExpressionListElementContext).canSpread, "spread operator is not allowed here", -1)

	case 2:

	}
	{
		p.SetState(1249)
		p.expression(0)
	}

	return localctx
}

// IEnhancedStatementExpressionContext is an interface to support dynamic dispatch.
type IEnhancedStatementExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnhancedStatementExpressionContext differentiates from other interfaces.
	IsEnhancedStatementExpressionContext()
}

type EnhancedStatementExpressionContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnhancedStatementExpressionContext() *EnhancedStatementExpressionContext {
	var p = new(EnhancedStatementExpressionContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_enhancedStatementExpression
	return p
}

func (*EnhancedStatementExpressionContext) IsEnhancedStatementExpressionContext() {}

func NewEnhancedStatementExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnhancedStatementExpressionContext {
	var p = new(EnhancedStatementExpressionContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_enhancedStatementExpression

	return p
}

func (s *EnhancedStatementExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *EnhancedStatementExpressionContext) StatementExpression() IStatementExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatementExpressionContext)
}

func (s *EnhancedStatementExpressionContext) StandardLambdaExpression() IStandardLambdaExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStandardLambdaExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStandardLambdaExpressionContext)
}

func (s *EnhancedStatementExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnhancedStatementExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnhancedStatementExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterEnhancedStatementExpression(s)
	}
}

func (s *EnhancedStatementExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitEnhancedStatementExpression(s)
	}
}

func (p *GroovyParser) EnhancedStatementExpression() (localctx IEnhancedStatementExpressionContext) {
	localctx = NewEnhancedStatementExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 226, GroovyParserRULE_enhancedStatementExpression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1253)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 139, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1251)
			p.StatementExpression()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1252)
			p.StandardLambdaExpression()
		}

	}

	return localctx
}

// IStatementExpressionContext is an interface to support dynamic dispatch.
type IStatementExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStatementExpressionContext differentiates from other interfaces.
	IsStatementExpressionContext()
}

type StatementExpressionContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatementExpressionContext() *StatementExpressionContext {
	var p = new(StatementExpressionContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_statementExpression
	return p
}

func (*StatementExpressionContext) IsStatementExpressionContext() {}

func NewStatementExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatementExpressionContext {
	var p = new(StatementExpressionContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_statementExpression

	return p
}

func (s *StatementExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *StatementExpressionContext) CopyFrom(ctx *StatementExpressionContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *StatementExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type CommandExprAltContext struct {
	*StatementExpressionContext
}

func NewCommandExprAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CommandExprAltContext {
	var p = new(CommandExprAltContext)

	p.StatementExpressionContext = NewEmptyStatementExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementExpressionContext))

	return p
}

func (s *CommandExprAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CommandExprAltContext) CommandExpression() ICommandExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICommandExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICommandExpressionContext)
}

func (s *CommandExprAltContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterCommandExprAlt(s)
	}
}

func (s *CommandExprAltContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitCommandExprAlt(s)
	}
}

func (p *GroovyParser) StatementExpression() (localctx IStatementExpressionContext) {
	localctx = NewStatementExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 228, GroovyParserRULE_statementExpression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	localctx = NewCommandExprAltContext(p, localctx)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1255)
		p.CommandExpression()
	}

	return localctx
}

// IPostfixExpressionContext is an interface to support dynamic dispatch.
type IPostfixExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOp returns the op token.
	GetOp() antlr.Token

	// SetOp sets the op token.
	SetOp(antlr.Token)

	// IsPostfixExpressionContext differentiates from other interfaces.
	IsPostfixExpressionContext()
}

type PostfixExpressionContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
	op     antlr.Token
}

func NewEmptyPostfixExpressionContext() *PostfixExpressionContext {
	var p = new(PostfixExpressionContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_postfixExpression
	return p
}

func (*PostfixExpressionContext) IsPostfixExpressionContext() {}

func NewPostfixExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PostfixExpressionContext {
	var p = new(PostfixExpressionContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_postfixExpression

	return p
}

func (s *PostfixExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *PostfixExpressionContext) GetOp() antlr.Token { return s.op }

func (s *PostfixExpressionContext) SetOp(v antlr.Token) { s.op = v }

func (s *PostfixExpressionContext) PathExpression() IPathExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPathExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPathExpressionContext)
}

func (s *PostfixExpressionContext) INC() antlr.TerminalNode {
	return s.GetToken(GroovyParserINC, 0)
}

func (s *PostfixExpressionContext) DEC() antlr.TerminalNode {
	return s.GetToken(GroovyParserDEC, 0)
}

func (s *PostfixExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PostfixExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PostfixExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterPostfixExpression(s)
	}
}

func (s *PostfixExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitPostfixExpression(s)
	}
}

func (p *GroovyParser) PostfixExpression() (localctx IPostfixExpressionContext) {
	localctx = NewPostfixExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 230, GroovyParserRULE_postfixExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1257)
		p.PathExpression()
	}
	p.SetState(1259)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 140, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1258)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*PostfixExpressionContext).op = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == GroovyParserINC || _la == GroovyParserDEC) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*PostfixExpressionContext).op = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}

	return localctx
}

// IExpressionContext is an interface to support dynamic dispatch.
type IExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpressionContext differentiates from other interfaces.
	IsExpressionContext()
}

type ExpressionContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionContext() *ExpressionContext {
	var p = new(ExpressionContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_expression
	return p
}

func (*ExpressionContext) IsExpressionContext() {}

func NewExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionContext {
	var p = new(ExpressionContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_expression

	return p
}

func (s *ExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionContext) CopyFrom(ctx *ExpressionContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *ExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type CastExprAltForExprContext struct {
	*ExpressionContext
}

func NewCastExprAltForExprContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CastExprAltForExprContext {
	var p = new(CastExprAltForExprContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *CastExprAltForExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CastExprAltForExprContext) CastParExpression() ICastParExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICastParExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICastParExpressionContext)
}

func (s *CastExprAltForExprContext) CastOperandExpression() ICastOperandExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICastOperandExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICastOperandExpressionContext)
}

func (s *CastExprAltForExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterCastExprAltForExpr(s)
	}
}

func (s *CastExprAltForExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitCastExprAltForExpr(s)
	}
}

type ShiftExprAltContext struct {
	*ExpressionContext
	left    IExpressionContext
	dlOp    antlr.Token
	tgOp    antlr.Token
	dgOp    antlr.Token
	rangeOp antlr.Token
	right   IExpressionContext
}

func NewShiftExprAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShiftExprAltContext {
	var p = new(ShiftExprAltContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *ShiftExprAltContext) GetDlOp() antlr.Token { return s.dlOp }

func (s *ShiftExprAltContext) GetTgOp() antlr.Token { return s.tgOp }

func (s *ShiftExprAltContext) GetDgOp() antlr.Token { return s.dgOp }

func (s *ShiftExprAltContext) GetRangeOp() antlr.Token { return s.rangeOp }

func (s *ShiftExprAltContext) SetDlOp(v antlr.Token) { s.dlOp = v }

func (s *ShiftExprAltContext) SetTgOp(v antlr.Token) { s.tgOp = v }

func (s *ShiftExprAltContext) SetDgOp(v antlr.Token) { s.dgOp = v }

func (s *ShiftExprAltContext) SetRangeOp(v antlr.Token) { s.rangeOp = v }

func (s *ShiftExprAltContext) GetLeft() IExpressionContext { return s.left }

func (s *ShiftExprAltContext) GetRight() IExpressionContext { return s.right }

func (s *ShiftExprAltContext) SetLeft(v IExpressionContext) { s.left = v }

func (s *ShiftExprAltContext) SetRight(v IExpressionContext) { s.right = v }

func (s *ShiftExprAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShiftExprAltContext) AllNls() []INlsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INlsContext)(nil)).Elem())
	var tst = make([]INlsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INlsContext)
		}
	}

	return tst
}

func (s *ShiftExprAltContext) Nls(i int) INlsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INlsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *ShiftExprAltContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *ShiftExprAltContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ShiftExprAltContext) AllLT() []antlr.TerminalNode {
	return s.GetTokens(GroovyParserLT)
}

func (s *ShiftExprAltContext) LT(i int) antlr.TerminalNode {
	return s.GetToken(GroovyParserLT, i)
}

func (s *ShiftExprAltContext) AllGT() []antlr.TerminalNode {
	return s.GetTokens(GroovyParserGT)
}

func (s *ShiftExprAltContext) GT(i int) antlr.TerminalNode {
	return s.GetToken(GroovyParserGT, i)
}

func (s *ShiftExprAltContext) RANGE_INCLUSIVE() antlr.TerminalNode {
	return s.GetToken(GroovyParserRANGE_INCLUSIVE, 0)
}

func (s *ShiftExprAltContext) RANGE_EXCLUSIVE() antlr.TerminalNode {
	return s.GetToken(GroovyParserRANGE_EXCLUSIVE, 0)
}

func (s *ShiftExprAltContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterShiftExprAlt(s)
	}
}

func (s *ShiftExprAltContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitShiftExprAlt(s)
	}
}

type MultipleAssignmentExprAltContext struct {
	*ExpressionContext
	left  IVariableNamesContext
	op    antlr.Token
	right IStatementExpressionContext
}

func NewMultipleAssignmentExprAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *MultipleAssignmentExprAltContext {
	var p = new(MultipleAssignmentExprAltContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *MultipleAssignmentExprAltContext) GetOp() antlr.Token { return s.op }

func (s *MultipleAssignmentExprAltContext) SetOp(v antlr.Token) { s.op = v }

func (s *MultipleAssignmentExprAltContext) GetLeft() IVariableNamesContext { return s.left }

func (s *MultipleAssignmentExprAltContext) GetRight() IStatementExpressionContext { return s.right }

func (s *MultipleAssignmentExprAltContext) SetLeft(v IVariableNamesContext) { s.left = v }

func (s *MultipleAssignmentExprAltContext) SetRight(v IStatementExpressionContext) { s.right = v }

func (s *MultipleAssignmentExprAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultipleAssignmentExprAltContext) AllNls() []INlsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INlsContext)(nil)).Elem())
	var tst = make([]INlsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INlsContext)
		}
	}

	return tst
}

func (s *MultipleAssignmentExprAltContext) Nls(i int) INlsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INlsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *MultipleAssignmentExprAltContext) VariableNames() IVariableNamesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableNamesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariableNamesContext)
}

func (s *MultipleAssignmentExprAltContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(GroovyParserASSIGN, 0)
}

func (s *MultipleAssignmentExprAltContext) StatementExpression() IStatementExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatementExpressionContext)
}

func (s *MultipleAssignmentExprAltContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterMultipleAssignmentExprAlt(s)
	}
}

func (s *MultipleAssignmentExprAltContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitMultipleAssignmentExprAlt(s)
	}
}

type ExclusiveOrExprAltContext struct {
	*ExpressionContext
	left  IExpressionContext
	op    antlr.Token
	right IExpressionContext
}

func NewExclusiveOrExprAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExclusiveOrExprAltContext {
	var p = new(ExclusiveOrExprAltContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *ExclusiveOrExprAltContext) GetOp() antlr.Token { return s.op }

func (s *ExclusiveOrExprAltContext) SetOp(v antlr.Token) { s.op = v }

func (s *ExclusiveOrExprAltContext) GetLeft() IExpressionContext { return s.left }

func (s *ExclusiveOrExprAltContext) GetRight() IExpressionContext { return s.right }

func (s *ExclusiveOrExprAltContext) SetLeft(v IExpressionContext) { s.left = v }

func (s *ExclusiveOrExprAltContext) SetRight(v IExpressionContext) { s.right = v }

func (s *ExclusiveOrExprAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExclusiveOrExprAltContext) AllNls() []INlsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INlsContext)(nil)).Elem())
	var tst = make([]INlsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INlsContext)
		}
	}

	return tst
}

func (s *ExclusiveOrExprAltContext) Nls(i int) INlsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INlsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *ExclusiveOrExprAltContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *ExclusiveOrExprAltContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ExclusiveOrExprAltContext) XOR() antlr.TerminalNode {
	return s.GetToken(GroovyParserXOR, 0)
}

func (s *ExclusiveOrExprAltContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterExclusiveOrExprAlt(s)
	}
}

func (s *ExclusiveOrExprAltContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitExclusiveOrExprAlt(s)
	}
}

type AdditiveExprAltContext struct {
	*ExpressionContext
	left  IExpressionContext
	op    antlr.Token
	right IExpressionContext
}

func NewAdditiveExprAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AdditiveExprAltContext {
	var p = new(AdditiveExprAltContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *AdditiveExprAltContext) GetOp() antlr.Token { return s.op }

func (s *AdditiveExprAltContext) SetOp(v antlr.Token) { s.op = v }

func (s *AdditiveExprAltContext) GetLeft() IExpressionContext { return s.left }

func (s *AdditiveExprAltContext) GetRight() IExpressionContext { return s.right }

func (s *AdditiveExprAltContext) SetLeft(v IExpressionContext) { s.left = v }

func (s *AdditiveExprAltContext) SetRight(v IExpressionContext) { s.right = v }

func (s *AdditiveExprAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdditiveExprAltContext) Nls() INlsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INlsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *AdditiveExprAltContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *AdditiveExprAltContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *AdditiveExprAltContext) ADD() antlr.TerminalNode {
	return s.GetToken(GroovyParserADD, 0)
}

func (s *AdditiveExprAltContext) SUB() antlr.TerminalNode {
	return s.GetToken(GroovyParserSUB, 0)
}

func (s *AdditiveExprAltContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterAdditiveExprAlt(s)
	}
}

func (s *AdditiveExprAltContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitAdditiveExprAlt(s)
	}
}

type RegexExprAltContext struct {
	*ExpressionContext
	left  IExpressionContext
	op    antlr.Token
	right IExpressionContext
}

func NewRegexExprAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RegexExprAltContext {
	var p = new(RegexExprAltContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *RegexExprAltContext) GetOp() antlr.Token { return s.op }

func (s *RegexExprAltContext) SetOp(v antlr.Token) { s.op = v }

func (s *RegexExprAltContext) GetLeft() IExpressionContext { return s.left }

func (s *RegexExprAltContext) GetRight() IExpressionContext { return s.right }

func (s *RegexExprAltContext) SetLeft(v IExpressionContext) { s.left = v }

func (s *RegexExprAltContext) SetRight(v IExpressionContext) { s.right = v }

func (s *RegexExprAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RegexExprAltContext) AllNls() []INlsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INlsContext)(nil)).Elem())
	var tst = make([]INlsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INlsContext)
		}
	}

	return tst
}

func (s *RegexExprAltContext) Nls(i int) INlsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INlsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *RegexExprAltContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *RegexExprAltContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *RegexExprAltContext) REGEX_FIND() antlr.TerminalNode {
	return s.GetToken(GroovyParserREGEX_FIND, 0)
}

func (s *RegexExprAltContext) REGEX_MATCH() antlr.TerminalNode {
	return s.GetToken(GroovyParserREGEX_MATCH, 0)
}

func (s *RegexExprAltContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterRegexExprAlt(s)
	}
}

func (s *RegexExprAltContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitRegexExprAlt(s)
	}
}

type UnaryNotExprAltForExprContext struct {
	*ExpressionContext
}

func NewUnaryNotExprAltForExprContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UnaryNotExprAltForExprContext {
	var p = new(UnaryNotExprAltForExprContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *UnaryNotExprAltForExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnaryNotExprAltForExprContext) Nls() INlsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INlsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *UnaryNotExprAltForExprContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *UnaryNotExprAltForExprContext) BITNOT() antlr.TerminalNode {
	return s.GetToken(GroovyParserBITNOT, 0)
}

func (s *UnaryNotExprAltForExprContext) NOT() antlr.TerminalNode {
	return s.GetToken(GroovyParserNOT, 0)
}

func (s *UnaryNotExprAltForExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterUnaryNotExprAltForExpr(s)
	}
}

func (s *UnaryNotExprAltForExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitUnaryNotExprAltForExpr(s)
	}
}

type ConditionalExprAltContext struct {
	*ExpressionContext
	con IExpressionContext
	tb  IExpressionContext
	fb  IExpressionContext
}

func NewConditionalExprAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ConditionalExprAltContext {
	var p = new(ConditionalExprAltContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *ConditionalExprAltContext) GetCon() IExpressionContext { return s.con }

func (s *ConditionalExprAltContext) GetTb() IExpressionContext { return s.tb }

func (s *ConditionalExprAltContext) GetFb() IExpressionContext { return s.fb }

func (s *ConditionalExprAltContext) SetCon(v IExpressionContext) { s.con = v }

func (s *ConditionalExprAltContext) SetTb(v IExpressionContext) { s.tb = v }

func (s *ConditionalExprAltContext) SetFb(v IExpressionContext) { s.fb = v }

func (s *ConditionalExprAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConditionalExprAltContext) AllNls() []INlsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INlsContext)(nil)).Elem())
	var tst = make([]INlsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INlsContext)
		}
	}

	return tst
}

func (s *ConditionalExprAltContext) Nls(i int) INlsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INlsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *ConditionalExprAltContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *ConditionalExprAltContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ConditionalExprAltContext) QUESTION() antlr.TerminalNode {
	return s.GetToken(GroovyParserQUESTION, 0)
}

func (s *ConditionalExprAltContext) COLON() antlr.TerminalNode {
	return s.GetToken(GroovyParserCOLON, 0)
}

func (s *ConditionalExprAltContext) ELVIS() antlr.TerminalNode {
	return s.GetToken(GroovyParserELVIS, 0)
}

func (s *ConditionalExprAltContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterConditionalExprAlt(s)
	}
}

func (s *ConditionalExprAltContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitConditionalExprAlt(s)
	}
}

type PowerExprAltContext struct {
	*ExpressionContext
	left  IExpressionContext
	op    antlr.Token
	right IExpressionContext
}

func NewPowerExprAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PowerExprAltContext {
	var p = new(PowerExprAltContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *PowerExprAltContext) GetOp() antlr.Token { return s.op }

func (s *PowerExprAltContext) SetOp(v antlr.Token) { s.op = v }

func (s *PowerExprAltContext) GetLeft() IExpressionContext { return s.left }

func (s *PowerExprAltContext) GetRight() IExpressionContext { return s.right }

func (s *PowerExprAltContext) SetLeft(v IExpressionContext) { s.left = v }

func (s *PowerExprAltContext) SetRight(v IExpressionContext) { s.right = v }

func (s *PowerExprAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PowerExprAltContext) Nls() INlsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INlsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *PowerExprAltContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *PowerExprAltContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *PowerExprAltContext) POWER() antlr.TerminalNode {
	return s.GetToken(GroovyParserPOWER, 0)
}

func (s *PowerExprAltContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterPowerExprAlt(s)
	}
}

func (s *PowerExprAltContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitPowerExprAlt(s)
	}
}

type RelationalExprAltContext struct {
	*ExpressionContext
	left  IExpressionContext
	op    antlr.Token
	right IExpressionContext
}

func NewRelationalExprAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RelationalExprAltContext {
	var p = new(RelationalExprAltContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *RelationalExprAltContext) GetOp() antlr.Token { return s.op }

func (s *RelationalExprAltContext) SetOp(v antlr.Token) { s.op = v }

func (s *RelationalExprAltContext) GetLeft() IExpressionContext { return s.left }

func (s *RelationalExprAltContext) GetRight() IExpressionContext { return s.right }

func (s *RelationalExprAltContext) SetLeft(v IExpressionContext) { s.left = v }

func (s *RelationalExprAltContext) SetRight(v IExpressionContext) { s.right = v }

func (s *RelationalExprAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelationalExprAltContext) AllNls() []INlsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INlsContext)(nil)).Elem())
	var tst = make([]INlsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INlsContext)
		}
	}

	return tst
}

func (s *RelationalExprAltContext) Nls(i int) INlsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INlsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *RelationalExprAltContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *RelationalExprAltContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *RelationalExprAltContext) LE() antlr.TerminalNode {
	return s.GetToken(GroovyParserLE, 0)
}

func (s *RelationalExprAltContext) GE() antlr.TerminalNode {
	return s.GetToken(GroovyParserGE, 0)
}

func (s *RelationalExprAltContext) GT() antlr.TerminalNode {
	return s.GetToken(GroovyParserGT, 0)
}

func (s *RelationalExprAltContext) LT() antlr.TerminalNode {
	return s.GetToken(GroovyParserLT, 0)
}

func (s *RelationalExprAltContext) IN() antlr.TerminalNode {
	return s.GetToken(GroovyParserIN, 0)
}

func (s *RelationalExprAltContext) NOT_IN() antlr.TerminalNode {
	return s.GetToken(GroovyParserNOT_IN, 0)
}

func (s *RelationalExprAltContext) TypeType() ITypeTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeTypeContext)
}

func (s *RelationalExprAltContext) AS() antlr.TerminalNode {
	return s.GetToken(GroovyParserAS, 0)
}

func (s *RelationalExprAltContext) INSTANCEOF() antlr.TerminalNode {
	return s.GetToken(GroovyParserINSTANCEOF, 0)
}

func (s *RelationalExprAltContext) NOT_INSTANCEOF() antlr.TerminalNode {
	return s.GetToken(GroovyParserNOT_INSTANCEOF, 0)
}

func (s *RelationalExprAltContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterRelationalExprAlt(s)
	}
}

func (s *RelationalExprAltContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitRelationalExprAlt(s)
	}
}

type LogicalAndExprAltContext struct {
	*ExpressionContext
	left  IExpressionContext
	op    antlr.Token
	right IExpressionContext
}

func NewLogicalAndExprAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LogicalAndExprAltContext {
	var p = new(LogicalAndExprAltContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *LogicalAndExprAltContext) GetOp() antlr.Token { return s.op }

func (s *LogicalAndExprAltContext) SetOp(v antlr.Token) { s.op = v }

func (s *LogicalAndExprAltContext) GetLeft() IExpressionContext { return s.left }

func (s *LogicalAndExprAltContext) GetRight() IExpressionContext { return s.right }

func (s *LogicalAndExprAltContext) SetLeft(v IExpressionContext) { s.left = v }

func (s *LogicalAndExprAltContext) SetRight(v IExpressionContext) { s.right = v }

func (s *LogicalAndExprAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LogicalAndExprAltContext) AllNls() []INlsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INlsContext)(nil)).Elem())
	var tst = make([]INlsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INlsContext)
		}
	}

	return tst
}

func (s *LogicalAndExprAltContext) Nls(i int) INlsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INlsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *LogicalAndExprAltContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *LogicalAndExprAltContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *LogicalAndExprAltContext) AND() antlr.TerminalNode {
	return s.GetToken(GroovyParserAND, 0)
}

func (s *LogicalAndExprAltContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterLogicalAndExprAlt(s)
	}
}

func (s *LogicalAndExprAltContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitLogicalAndExprAlt(s)
	}
}

type AssignmentExprAltContext struct {
	*ExpressionContext
	left IExpressionContext
	op   antlr.Token
}

func NewAssignmentExprAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AssignmentExprAltContext {
	var p = new(AssignmentExprAltContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *AssignmentExprAltContext) GetOp() antlr.Token { return s.op }

func (s *AssignmentExprAltContext) SetOp(v antlr.Token) { s.op = v }

func (s *AssignmentExprAltContext) GetLeft() IExpressionContext { return s.left }

func (s *AssignmentExprAltContext) SetLeft(v IExpressionContext) { s.left = v }

func (s *AssignmentExprAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignmentExprAltContext) AllNls() []INlsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INlsContext)(nil)).Elem())
	var tst = make([]INlsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INlsContext)
		}
	}

	return tst
}

func (s *AssignmentExprAltContext) Nls(i int) INlsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INlsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *AssignmentExprAltContext) EnhancedStatementExpression() IEnhancedStatementExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnhancedStatementExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEnhancedStatementExpressionContext)
}

func (s *AssignmentExprAltContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *AssignmentExprAltContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(GroovyParserASSIGN, 0)
}

func (s *AssignmentExprAltContext) ADD_ASSIGN() antlr.TerminalNode {
	return s.GetToken(GroovyParserADD_ASSIGN, 0)
}

func (s *AssignmentExprAltContext) SUB_ASSIGN() antlr.TerminalNode {
	return s.GetToken(GroovyParserSUB_ASSIGN, 0)
}

func (s *AssignmentExprAltContext) MUL_ASSIGN() antlr.TerminalNode {
	return s.GetToken(GroovyParserMUL_ASSIGN, 0)
}

func (s *AssignmentExprAltContext) DIV_ASSIGN() antlr.TerminalNode {
	return s.GetToken(GroovyParserDIV_ASSIGN, 0)
}

func (s *AssignmentExprAltContext) AND_ASSIGN() antlr.TerminalNode {
	return s.GetToken(GroovyParserAND_ASSIGN, 0)
}

func (s *AssignmentExprAltContext) OR_ASSIGN() antlr.TerminalNode {
	return s.GetToken(GroovyParserOR_ASSIGN, 0)
}

func (s *AssignmentExprAltContext) XOR_ASSIGN() antlr.TerminalNode {
	return s.GetToken(GroovyParserXOR_ASSIGN, 0)
}

func (s *AssignmentExprAltContext) RSHIFT_ASSIGN() antlr.TerminalNode {
	return s.GetToken(GroovyParserRSHIFT_ASSIGN, 0)
}

func (s *AssignmentExprAltContext) URSHIFT_ASSIGN() antlr.TerminalNode {
	return s.GetToken(GroovyParserURSHIFT_ASSIGN, 0)
}

func (s *AssignmentExprAltContext) LSHIFT_ASSIGN() antlr.TerminalNode {
	return s.GetToken(GroovyParserLSHIFT_ASSIGN, 0)
}

func (s *AssignmentExprAltContext) MOD_ASSIGN() antlr.TerminalNode {
	return s.GetToken(GroovyParserMOD_ASSIGN, 0)
}

func (s *AssignmentExprAltContext) POWER_ASSIGN() antlr.TerminalNode {
	return s.GetToken(GroovyParserPOWER_ASSIGN, 0)
}

func (s *AssignmentExprAltContext) ELVIS_ASSIGN() antlr.TerminalNode {
	return s.GetToken(GroovyParserELVIS_ASSIGN, 0)
}

func (s *AssignmentExprAltContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterAssignmentExprAlt(s)
	}
}

func (s *AssignmentExprAltContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitAssignmentExprAlt(s)
	}
}

type PostfixExprAltForExprContext struct {
	*ExpressionContext
}

func NewPostfixExprAltForExprContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PostfixExprAltForExprContext {
	var p = new(PostfixExprAltForExprContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *PostfixExprAltForExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PostfixExprAltForExprContext) PostfixExpression() IPostfixExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPostfixExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPostfixExpressionContext)
}

func (s *PostfixExprAltForExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterPostfixExprAltForExpr(s)
	}
}

func (s *PostfixExprAltForExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitPostfixExprAltForExpr(s)
	}
}

type MultiplicativeExprAltContext struct {
	*ExpressionContext
	left  IExpressionContext
	op    antlr.Token
	right IExpressionContext
}

func NewMultiplicativeExprAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *MultiplicativeExprAltContext {
	var p = new(MultiplicativeExprAltContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *MultiplicativeExprAltContext) GetOp() antlr.Token { return s.op }

func (s *MultiplicativeExprAltContext) SetOp(v antlr.Token) { s.op = v }

func (s *MultiplicativeExprAltContext) GetLeft() IExpressionContext { return s.left }

func (s *MultiplicativeExprAltContext) GetRight() IExpressionContext { return s.right }

func (s *MultiplicativeExprAltContext) SetLeft(v IExpressionContext) { s.left = v }

func (s *MultiplicativeExprAltContext) SetRight(v IExpressionContext) { s.right = v }

func (s *MultiplicativeExprAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultiplicativeExprAltContext) AllNls() []INlsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INlsContext)(nil)).Elem())
	var tst = make([]INlsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INlsContext)
		}
	}

	return tst
}

func (s *MultiplicativeExprAltContext) Nls(i int) INlsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INlsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *MultiplicativeExprAltContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *MultiplicativeExprAltContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *MultiplicativeExprAltContext) MUL() antlr.TerminalNode {
	return s.GetToken(GroovyParserMUL, 0)
}

func (s *MultiplicativeExprAltContext) DIV() antlr.TerminalNode {
	return s.GetToken(GroovyParserDIV, 0)
}

func (s *MultiplicativeExprAltContext) MOD() antlr.TerminalNode {
	return s.GetToken(GroovyParserMOD, 0)
}

func (s *MultiplicativeExprAltContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterMultiplicativeExprAlt(s)
	}
}

func (s *MultiplicativeExprAltContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitMultiplicativeExprAlt(s)
	}
}

type InclusiveOrExprAltContext struct {
	*ExpressionContext
	left  IExpressionContext
	op    antlr.Token
	right IExpressionContext
}

func NewInclusiveOrExprAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *InclusiveOrExprAltContext {
	var p = new(InclusiveOrExprAltContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *InclusiveOrExprAltContext) GetOp() antlr.Token { return s.op }

func (s *InclusiveOrExprAltContext) SetOp(v antlr.Token) { s.op = v }

func (s *InclusiveOrExprAltContext) GetLeft() IExpressionContext { return s.left }

func (s *InclusiveOrExprAltContext) GetRight() IExpressionContext { return s.right }

func (s *InclusiveOrExprAltContext) SetLeft(v IExpressionContext) { s.left = v }

func (s *InclusiveOrExprAltContext) SetRight(v IExpressionContext) { s.right = v }

func (s *InclusiveOrExprAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InclusiveOrExprAltContext) AllNls() []INlsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INlsContext)(nil)).Elem())
	var tst = make([]INlsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INlsContext)
		}
	}

	return tst
}

func (s *InclusiveOrExprAltContext) Nls(i int) INlsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INlsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *InclusiveOrExprAltContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *InclusiveOrExprAltContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *InclusiveOrExprAltContext) BITOR() antlr.TerminalNode {
	return s.GetToken(GroovyParserBITOR, 0)
}

func (s *InclusiveOrExprAltContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterInclusiveOrExprAlt(s)
	}
}

func (s *InclusiveOrExprAltContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitInclusiveOrExprAlt(s)
	}
}

type LogicalOrExprAltContext struct {
	*ExpressionContext
	left  IExpressionContext
	op    antlr.Token
	right IExpressionContext
}

func NewLogicalOrExprAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LogicalOrExprAltContext {
	var p = new(LogicalOrExprAltContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *LogicalOrExprAltContext) GetOp() antlr.Token { return s.op }

func (s *LogicalOrExprAltContext) SetOp(v antlr.Token) { s.op = v }

func (s *LogicalOrExprAltContext) GetLeft() IExpressionContext { return s.left }

func (s *LogicalOrExprAltContext) GetRight() IExpressionContext { return s.right }

func (s *LogicalOrExprAltContext) SetLeft(v IExpressionContext) { s.left = v }

func (s *LogicalOrExprAltContext) SetRight(v IExpressionContext) { s.right = v }

func (s *LogicalOrExprAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LogicalOrExprAltContext) AllNls() []INlsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INlsContext)(nil)).Elem())
	var tst = make([]INlsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INlsContext)
		}
	}

	return tst
}

func (s *LogicalOrExprAltContext) Nls(i int) INlsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INlsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *LogicalOrExprAltContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *LogicalOrExprAltContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *LogicalOrExprAltContext) OR() antlr.TerminalNode {
	return s.GetToken(GroovyParserOR, 0)
}

func (s *LogicalOrExprAltContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterLogicalOrExprAlt(s)
	}
}

func (s *LogicalOrExprAltContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitLogicalOrExprAlt(s)
	}
}

type EqualityExprAltContext struct {
	*ExpressionContext
	left  IExpressionContext
	op    antlr.Token
	right IExpressionContext
}

func NewEqualityExprAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *EqualityExprAltContext {
	var p = new(EqualityExprAltContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *EqualityExprAltContext) GetOp() antlr.Token { return s.op }

func (s *EqualityExprAltContext) SetOp(v antlr.Token) { s.op = v }

func (s *EqualityExprAltContext) GetLeft() IExpressionContext { return s.left }

func (s *EqualityExprAltContext) GetRight() IExpressionContext { return s.right }

func (s *EqualityExprAltContext) SetLeft(v IExpressionContext) { s.left = v }

func (s *EqualityExprAltContext) SetRight(v IExpressionContext) { s.right = v }

func (s *EqualityExprAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EqualityExprAltContext) AllNls() []INlsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INlsContext)(nil)).Elem())
	var tst = make([]INlsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INlsContext)
		}
	}

	return tst
}

func (s *EqualityExprAltContext) Nls(i int) INlsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INlsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *EqualityExprAltContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *EqualityExprAltContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *EqualityExprAltContext) IDENTICAL() antlr.TerminalNode {
	return s.GetToken(GroovyParserIDENTICAL, 0)
}

func (s *EqualityExprAltContext) NOT_IDENTICAL() antlr.TerminalNode {
	return s.GetToken(GroovyParserNOT_IDENTICAL, 0)
}

func (s *EqualityExprAltContext) EQUAL() antlr.TerminalNode {
	return s.GetToken(GroovyParserEQUAL, 0)
}

func (s *EqualityExprAltContext) NOTEQUAL() antlr.TerminalNode {
	return s.GetToken(GroovyParserNOTEQUAL, 0)
}

func (s *EqualityExprAltContext) SPACESHIP() antlr.TerminalNode {
	return s.GetToken(GroovyParserSPACESHIP, 0)
}

func (s *EqualityExprAltContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterEqualityExprAlt(s)
	}
}

func (s *EqualityExprAltContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitEqualityExprAlt(s)
	}
}

type AndExprAltContext struct {
	*ExpressionContext
	left  IExpressionContext
	op    antlr.Token
	right IExpressionContext
}

func NewAndExprAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AndExprAltContext {
	var p = new(AndExprAltContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *AndExprAltContext) GetOp() antlr.Token { return s.op }

func (s *AndExprAltContext) SetOp(v antlr.Token) { s.op = v }

func (s *AndExprAltContext) GetLeft() IExpressionContext { return s.left }

func (s *AndExprAltContext) GetRight() IExpressionContext { return s.right }

func (s *AndExprAltContext) SetLeft(v IExpressionContext) { s.left = v }

func (s *AndExprAltContext) SetRight(v IExpressionContext) { s.right = v }

func (s *AndExprAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AndExprAltContext) AllNls() []INlsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INlsContext)(nil)).Elem())
	var tst = make([]INlsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INlsContext)
		}
	}

	return tst
}

func (s *AndExprAltContext) Nls(i int) INlsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INlsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *AndExprAltContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *AndExprAltContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *AndExprAltContext) BITAND() antlr.TerminalNode {
	return s.GetToken(GroovyParserBITAND, 0)
}

func (s *AndExprAltContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterAndExprAlt(s)
	}
}

func (s *AndExprAltContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitAndExprAlt(s)
	}
}

type UnaryAddExprAltForExprContext struct {
	*ExpressionContext
	op antlr.Token
}

func NewUnaryAddExprAltForExprContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UnaryAddExprAltForExprContext {
	var p = new(UnaryAddExprAltForExprContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *UnaryAddExprAltForExprContext) GetOp() antlr.Token { return s.op }

func (s *UnaryAddExprAltForExprContext) SetOp(v antlr.Token) { s.op = v }

func (s *UnaryAddExprAltForExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnaryAddExprAltForExprContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *UnaryAddExprAltForExprContext) INC() antlr.TerminalNode {
	return s.GetToken(GroovyParserINC, 0)
}

func (s *UnaryAddExprAltForExprContext) DEC() antlr.TerminalNode {
	return s.GetToken(GroovyParserDEC, 0)
}

func (s *UnaryAddExprAltForExprContext) ADD() antlr.TerminalNode {
	return s.GetToken(GroovyParserADD, 0)
}

func (s *UnaryAddExprAltForExprContext) SUB() antlr.TerminalNode {
	return s.GetToken(GroovyParserSUB, 0)
}

func (s *UnaryAddExprAltForExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterUnaryAddExprAltForExpr(s)
	}
}

func (s *UnaryAddExprAltForExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitUnaryAddExprAltForExpr(s)
	}
}

func (p *GroovyParser) Expression() (localctx IExpressionContext) {
	return p.expression(0)
}

func (p *GroovyParser) expression(_p int) (localctx IExpressionContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewExpressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IExpressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 232
	p.EnterRecursionRule(localctx, 232, GroovyParserRULE_expression, _p)
	var _la int

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1278)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 141, p.GetParserRuleContext()) {
	case 1:
		localctx = NewCastExprAltForExprContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx

		{
			p.SetState(1262)
			p.CastParExpression()
		}
		{
			p.SetState(1263)
			p.CastOperandExpression()
		}

	case 2:
		localctx = NewPostfixExprAltForExprContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1265)
			p.PostfixExpression()
		}

	case 3:
		localctx = NewUnaryNotExprAltForExprContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1266)
			_la = p.GetTokenStream().LA(1)

			if !(_la == GroovyParserNOT || _la == GroovyParserBITNOT) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1267)
			p.Nls()
		}
		{
			p.SetState(1268)
			p.expression(18)
		}

	case 4:
		localctx = NewUnaryAddExprAltForExprContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1270)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*UnaryAddExprAltForExprContext).op = _lt

			_la = p.GetTokenStream().LA(1)

			if !(((_la-100)&-(0x1f+1)) == 0 && ((1<<uint((_la-100)))&((1<<(GroovyParserINC-100))|(1<<(GroovyParserDEC-100))|(1<<(GroovyParserADD-100))|(1<<(GroovyParserSUB-100)))) != 0) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*UnaryAddExprAltForExprContext).op = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1271)
			p.expression(16)
		}

	case 5:
		localctx = NewMultipleAssignmentExprAltContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1272)

			var _x = p.VariableNames()

			localctx.(*MultipleAssignmentExprAltContext).left = _x
		}
		{
			p.SetState(1273)
			p.Nls()
		}
		{
			p.SetState(1274)

			var _m = p.Match(GroovyParserASSIGN)

			localctx.(*MultipleAssignmentExprAltContext).op = _m
		}
		{
			p.SetState(1275)
			p.Nls()
		}
		{
			p.SetState(1276)

			var _x = p.StatementExpression()

			localctx.(*MultipleAssignmentExprAltContext).right = _x
		}

	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(1390)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 146, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(1388)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 145, p.GetParserRuleContext()) {
			case 1:
				localctx = NewPowerExprAltContext(p, NewExpressionContext(p, _parentctx, _parentState))
				localctx.(*PowerExprAltContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, GroovyParserRULE_expression)
				p.SetState(1280)

				if !(p.Precpred(p.GetParserRuleContext(), 17)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 17)", ""))
				}
				{
					p.SetState(1281)

					var _m = p.Match(GroovyParserPOWER)

					localctx.(*PowerExprAltContext).op = _m
				}
				{
					p.SetState(1282)
					p.Nls()
				}
				{
					p.SetState(1283)

					var _x = p.expression(18)

					localctx.(*PowerExprAltContext).right = _x
				}

			case 2:
				localctx = NewMultiplicativeExprAltContext(p, NewExpressionContext(p, _parentctx, _parentState))
				localctx.(*MultiplicativeExprAltContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, GroovyParserRULE_expression)
				p.SetState(1285)

				if !(p.Precpred(p.GetParserRuleContext(), 15)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 15)", ""))
				}
				{
					p.SetState(1286)
					p.Nls()
				}
				{
					p.SetState(1287)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*MultiplicativeExprAltContext).op = _lt

					_la = p.GetTokenStream().LA(1)

					if !(((_la-104)&-(0x1f+1)) == 0 && ((1<<uint((_la-104)))&((1<<(GroovyParserMUL-104))|(1<<(GroovyParserDIV-104))|(1<<(GroovyParserMOD-104)))) != 0) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*MultiplicativeExprAltContext).op = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(1288)
					p.Nls()
				}
				{
					p.SetState(1289)

					var _x = p.expression(16)

					localctx.(*MultiplicativeExprAltContext).right = _x
				}

			case 3:
				localctx = NewAdditiveExprAltContext(p, NewExpressionContext(p, _parentctx, _parentState))
				localctx.(*AdditiveExprAltContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, GroovyParserRULE_expression)
				p.SetState(1291)

				if !(p.Precpred(p.GetParserRuleContext(), 14)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 14)", ""))
				}
				{
					p.SetState(1292)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*AdditiveExprAltContext).op = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == GroovyParserADD || _la == GroovyParserSUB) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*AdditiveExprAltContext).op = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(1293)
					p.Nls()
				}
				{
					p.SetState(1294)

					var _x = p.expression(15)

					localctx.(*AdditiveExprAltContext).right = _x
				}

			case 4:
				localctx = NewShiftExprAltContext(p, NewExpressionContext(p, _parentctx, _parentState))
				localctx.(*ShiftExprAltContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, GroovyParserRULE_expression)
				p.SetState(1296)

				if !(p.Precpred(p.GetParserRuleContext(), 13)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 13)", ""))
				}
				{
					p.SetState(1297)
					p.Nls()
				}
				p.SetState(1308)
				p.GetErrorHandler().Sync(p)

				switch p.GetTokenStream().LA(1) {
				case GroovyParserGT, GroovyParserLT:
					p.SetState(1305)
					p.GetErrorHandler().Sync(p)
					switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 142, p.GetParserRuleContext()) {
					case 1:
						{
							p.SetState(1298)

							var _m = p.Match(GroovyParserLT)

							localctx.(*ShiftExprAltContext).dlOp = _m
						}
						{
							p.SetState(1299)
							p.Match(GroovyParserLT)
						}

					case 2:
						{
							p.SetState(1300)

							var _m = p.Match(GroovyParserGT)

							localctx.(*ShiftExprAltContext).tgOp = _m
						}
						{
							p.SetState(1301)
							p.Match(GroovyParserGT)
						}
						{
							p.SetState(1302)
							p.Match(GroovyParserGT)
						}

					case 3:
						{
							p.SetState(1303)

							var _m = p.Match(GroovyParserGT)

							localctx.(*ShiftExprAltContext).dgOp = _m
						}
						{
							p.SetState(1304)
							p.Match(GroovyParserGT)
						}

					}

				case GroovyParserRANGE_INCLUSIVE, GroovyParserRANGE_EXCLUSIVE:
					{
						p.SetState(1307)

						var _lt = p.GetTokenStream().LT(1)

						localctx.(*ShiftExprAltContext).rangeOp = _lt

						_la = p.GetTokenStream().LA(1)

						if !(_la == GroovyParserRANGE_INCLUSIVE || _la == GroovyParserRANGE_EXCLUSIVE) {
							var _ri = p.GetErrorHandler().RecoverInline(p)

							localctx.(*ShiftExprAltContext).rangeOp = _ri
						} else {
							p.GetErrorHandler().ReportMatch(p)
							p.Consume()
						}
					}

				default:
					panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				}
				{
					p.SetState(1310)
					p.Nls()
				}
				{
					p.SetState(1311)

					var _x = p.expression(14)

					localctx.(*ShiftExprAltContext).right = _x
				}

			case 5:
				localctx = NewRelationalExprAltContext(p, NewExpressionContext(p, _parentctx, _parentState))
				localctx.(*RelationalExprAltContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, GroovyParserRULE_expression)
				p.SetState(1313)

				if !(p.Precpred(p.GetParserRuleContext(), 11)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 11)", ""))
				}
				{
					p.SetState(1314)
					p.Nls()
				}
				{
					p.SetState(1315)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*RelationalExprAltContext).op = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == GroovyParserIN || (((_la-77)&-(0x1f+1)) == 0 && ((1<<uint((_la-77)))&((1<<(GroovyParserNOT_IN-77))|(1<<(GroovyParserGT-77))|(1<<(GroovyParserLT-77))|(1<<(GroovyParserLE-77))|(1<<(GroovyParserGE-77)))) != 0)) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*RelationalExprAltContext).op = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(1316)
					p.Nls()
				}
				{
					p.SetState(1317)

					var _x = p.expression(12)

					localctx.(*RelationalExprAltContext).right = _x
				}

			case 6:
				localctx = NewEqualityExprAltContext(p, NewExpressionContext(p, _parentctx, _parentState))
				localctx.(*EqualityExprAltContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, GroovyParserRULE_expression)
				p.SetState(1319)

				if !(p.Precpred(p.GetParserRuleContext(), 10)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 10)", ""))
				}
				{
					p.SetState(1320)
					p.Nls()
				}
				{
					p.SetState(1321)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*EqualityExprAltContext).op = _lt

					_la = p.GetTokenStream().LA(1)

					if !(((_la-72)&-(0x1f+1)) == 0 && ((1<<uint((_la-72)))&((1<<(GroovyParserSPACESHIP-72))|(1<<(GroovyParserIDENTICAL-72))|(1<<(GroovyParserNOT_IDENTICAL-72))|(1<<(GroovyParserEQUAL-72))|(1<<(GroovyParserNOTEQUAL-72)))) != 0) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*EqualityExprAltContext).op = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(1322)
					p.Nls()
				}
				{
					p.SetState(1323)

					var _x = p.expression(11)

					localctx.(*EqualityExprAltContext).right = _x
				}

			case 7:
				localctx = NewRegexExprAltContext(p, NewExpressionContext(p, _parentctx, _parentState))
				localctx.(*RegexExprAltContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, GroovyParserRULE_expression)
				p.SetState(1325)

				if !(p.Precpred(p.GetParserRuleContext(), 9)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 9)", ""))
				}
				{
					p.SetState(1326)
					p.Nls()
				}
				{
					p.SetState(1327)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*RegexExprAltContext).op = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == GroovyParserREGEX_FIND || _la == GroovyParserREGEX_MATCH) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*RegexExprAltContext).op = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(1328)
					p.Nls()
				}
				{
					p.SetState(1329)

					var _x = p.expression(10)

					localctx.(*RegexExprAltContext).right = _x
				}

			case 8:
				localctx = NewAndExprAltContext(p, NewExpressionContext(p, _parentctx, _parentState))
				localctx.(*AndExprAltContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, GroovyParserRULE_expression)
				p.SetState(1331)

				if !(p.Precpred(p.GetParserRuleContext(), 8)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 8)", ""))
				}
				{
					p.SetState(1332)
					p.Nls()
				}
				{
					p.SetState(1333)

					var _m = p.Match(GroovyParserBITAND)

					localctx.(*AndExprAltContext).op = _m
				}
				{
					p.SetState(1334)
					p.Nls()
				}
				{
					p.SetState(1335)

					var _x = p.expression(9)

					localctx.(*AndExprAltContext).right = _x
				}

			case 9:
				localctx = NewExclusiveOrExprAltContext(p, NewExpressionContext(p, _parentctx, _parentState))
				localctx.(*ExclusiveOrExprAltContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, GroovyParserRULE_expression)
				p.SetState(1337)

				if !(p.Precpred(p.GetParserRuleContext(), 7)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 7)", ""))
				}
				{
					p.SetState(1338)
					p.Nls()
				}
				{
					p.SetState(1339)

					var _m = p.Match(GroovyParserXOR)

					localctx.(*ExclusiveOrExprAltContext).op = _m
				}
				{
					p.SetState(1340)
					p.Nls()
				}
				{
					p.SetState(1341)

					var _x = p.expression(8)

					localctx.(*ExclusiveOrExprAltContext).right = _x
				}

			case 10:
				localctx = NewInclusiveOrExprAltContext(p, NewExpressionContext(p, _parentctx, _parentState))
				localctx.(*InclusiveOrExprAltContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, GroovyParserRULE_expression)
				p.SetState(1343)

				if !(p.Precpred(p.GetParserRuleContext(), 6)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 6)", ""))
				}
				{
					p.SetState(1344)
					p.Nls()
				}
				{
					p.SetState(1345)

					var _m = p.Match(GroovyParserBITOR)

					localctx.(*InclusiveOrExprAltContext).op = _m
				}
				{
					p.SetState(1346)
					p.Nls()
				}
				{
					p.SetState(1347)

					var _x = p.expression(7)

					localctx.(*InclusiveOrExprAltContext).right = _x
				}

			case 11:
				localctx = NewLogicalAndExprAltContext(p, NewExpressionContext(p, _parentctx, _parentState))
				localctx.(*LogicalAndExprAltContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, GroovyParserRULE_expression)
				p.SetState(1349)

				if !(p.Precpred(p.GetParserRuleContext(), 5)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 5)", ""))
				}
				{
					p.SetState(1350)
					p.Nls()
				}
				{
					p.SetState(1351)

					var _m = p.Match(GroovyParserAND)

					localctx.(*LogicalAndExprAltContext).op = _m
				}
				{
					p.SetState(1352)
					p.Nls()
				}
				{
					p.SetState(1353)

					var _x = p.expression(6)

					localctx.(*LogicalAndExprAltContext).right = _x
				}

			case 12:
				localctx = NewLogicalOrExprAltContext(p, NewExpressionContext(p, _parentctx, _parentState))
				localctx.(*LogicalOrExprAltContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, GroovyParserRULE_expression)
				p.SetState(1355)

				if !(p.Precpred(p.GetParserRuleContext(), 4)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 4)", ""))
				}
				{
					p.SetState(1356)
					p.Nls()
				}
				{
					p.SetState(1357)

					var _m = p.Match(GroovyParserOR)

					localctx.(*LogicalOrExprAltContext).op = _m
				}
				{
					p.SetState(1358)
					p.Nls()
				}
				{
					p.SetState(1359)

					var _x = p.expression(5)

					localctx.(*LogicalOrExprAltContext).right = _x
				}

			case 13:
				localctx = NewConditionalExprAltContext(p, NewExpressionContext(p, _parentctx, _parentState))
				localctx.(*ConditionalExprAltContext).con = _prevctx

				p.PushNewRecursionContext(localctx, _startState, GroovyParserRULE_expression)
				p.SetState(1361)

				if !(p.Precpred(p.GetParserRuleContext(), 3)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))
				}
				{
					p.SetState(1362)
					p.Nls()
				}
				p.SetState(1372)
				p.GetErrorHandler().Sync(p)

				switch p.GetTokenStream().LA(1) {
				case GroovyParserQUESTION:
					{
						p.SetState(1363)
						p.Match(GroovyParserQUESTION)
					}
					{
						p.SetState(1364)
						p.Nls()
					}
					{
						p.SetState(1365)

						var _x = p.expression(0)

						localctx.(*ConditionalExprAltContext).tb = _x
					}
					{
						p.SetState(1366)
						p.Nls()
					}
					{
						p.SetState(1367)
						p.Match(GroovyParserCOLON)
					}
					{
						p.SetState(1368)
						p.Nls()
					}

				case GroovyParserELVIS:
					{
						p.SetState(1370)
						p.Match(GroovyParserELVIS)
					}
					{
						p.SetState(1371)
						p.Nls()
					}

				default:
					panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				}
				{
					p.SetState(1374)

					var _x = p.expression(3)

					localctx.(*ConditionalExprAltContext).fb = _x
				}

			case 14:
				localctx = NewRelationalExprAltContext(p, NewExpressionContext(p, _parentctx, _parentState))
				localctx.(*RelationalExprAltContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, GroovyParserRULE_expression)
				p.SetState(1376)

				if !(p.Precpred(p.GetParserRuleContext(), 12)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 12)", ""))
				}
				{
					p.SetState(1377)
					p.Nls()
				}
				{
					p.SetState(1378)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*RelationalExprAltContext).op = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == GroovyParserAS || _la == GroovyParserINSTANCEOF || _la == GroovyParserNOT_INSTANCEOF) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*RelationalExprAltContext).op = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(1379)
					p.Nls()
				}
				{
					p.SetState(1380)
					p.TypeType()
				}

			case 15:
				localctx = NewAssignmentExprAltContext(p, NewExpressionContext(p, _parentctx, _parentState))
				localctx.(*AssignmentExprAltContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, GroovyParserRULE_expression)
				p.SetState(1382)

				if !(p.Precpred(p.GetParserRuleContext(), 1)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
				}
				{
					p.SetState(1383)
					p.Nls()
				}
				{
					p.SetState(1384)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*AssignmentExprAltContext).op = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == GroovyParserPOWER_ASSIGN || _la == GroovyParserASSIGN || (((_la-110)&-(0x1f+1)) == 0 && ((1<<uint((_la-110)))&((1<<(GroovyParserADD_ASSIGN-110))|(1<<(GroovyParserSUB_ASSIGN-110))|(1<<(GroovyParserMUL_ASSIGN-110))|(1<<(GroovyParserDIV_ASSIGN-110))|(1<<(GroovyParserAND_ASSIGN-110))|(1<<(GroovyParserOR_ASSIGN-110))|(1<<(GroovyParserXOR_ASSIGN-110))|(1<<(GroovyParserMOD_ASSIGN-110))|(1<<(GroovyParserLSHIFT_ASSIGN-110))|(1<<(GroovyParserRSHIFT_ASSIGN-110))|(1<<(GroovyParserURSHIFT_ASSIGN-110))|(1<<(GroovyParserELVIS_ASSIGN-110)))) != 0)) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*AssignmentExprAltContext).op = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(1385)
					p.Nls()
				}
				{
					p.SetState(1386)
					p.EnhancedStatementExpression()
				}

			}

		}
		p.SetState(1392)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 146, p.GetParserRuleContext())
	}

	return localctx
}

// ICastOperandExpressionContext is an interface to support dynamic dispatch.
type ICastOperandExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCastOperandExpressionContext differentiates from other interfaces.
	IsCastOperandExpressionContext()
}

type CastOperandExpressionContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyCastOperandExpressionContext() *CastOperandExpressionContext {
	var p = new(CastOperandExpressionContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_castOperandExpression
	return p
}

func (*CastOperandExpressionContext) IsCastOperandExpressionContext() {}

func NewCastOperandExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CastOperandExpressionContext {
	var p = new(CastOperandExpressionContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_castOperandExpression

	return p
}

func (s *CastOperandExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *CastOperandExpressionContext) CopyFrom(ctx *CastOperandExpressionContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *CastOperandExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CastOperandExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type PostfixExprAltContext struct {
	*CastOperandExpressionContext
}

func NewPostfixExprAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PostfixExprAltContext {
	var p = new(PostfixExprAltContext)

	p.CastOperandExpressionContext = NewEmptyCastOperandExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*CastOperandExpressionContext))

	return p
}

func (s *PostfixExprAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PostfixExprAltContext) PostfixExpression() IPostfixExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPostfixExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPostfixExpressionContext)
}

func (s *PostfixExprAltContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterPostfixExprAlt(s)
	}
}

func (s *PostfixExprAltContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitPostfixExprAlt(s)
	}
}

type UnaryNotExprAltContext struct {
	*CastOperandExpressionContext
}

func NewUnaryNotExprAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UnaryNotExprAltContext {
	var p = new(UnaryNotExprAltContext)

	p.CastOperandExpressionContext = NewEmptyCastOperandExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*CastOperandExpressionContext))

	return p
}

func (s *UnaryNotExprAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnaryNotExprAltContext) Nls() INlsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INlsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *UnaryNotExprAltContext) CastOperandExpression() ICastOperandExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICastOperandExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICastOperandExpressionContext)
}

func (s *UnaryNotExprAltContext) BITNOT() antlr.TerminalNode {
	return s.GetToken(GroovyParserBITNOT, 0)
}

func (s *UnaryNotExprAltContext) NOT() antlr.TerminalNode {
	return s.GetToken(GroovyParserNOT, 0)
}

func (s *UnaryNotExprAltContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterUnaryNotExprAlt(s)
	}
}

func (s *UnaryNotExprAltContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitUnaryNotExprAlt(s)
	}
}

type UnaryAddExprAltContext struct {
	*CastOperandExpressionContext
	op antlr.Token
}

func NewUnaryAddExprAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UnaryAddExprAltContext {
	var p = new(UnaryAddExprAltContext)

	p.CastOperandExpressionContext = NewEmptyCastOperandExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*CastOperandExpressionContext))

	return p
}

func (s *UnaryAddExprAltContext) GetOp() antlr.Token { return s.op }

func (s *UnaryAddExprAltContext) SetOp(v antlr.Token) { s.op = v }

func (s *UnaryAddExprAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnaryAddExprAltContext) CastOperandExpression() ICastOperandExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICastOperandExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICastOperandExpressionContext)
}

func (s *UnaryAddExprAltContext) INC() antlr.TerminalNode {
	return s.GetToken(GroovyParserINC, 0)
}

func (s *UnaryAddExprAltContext) DEC() antlr.TerminalNode {
	return s.GetToken(GroovyParserDEC, 0)
}

func (s *UnaryAddExprAltContext) ADD() antlr.TerminalNode {
	return s.GetToken(GroovyParserADD, 0)
}

func (s *UnaryAddExprAltContext) SUB() antlr.TerminalNode {
	return s.GetToken(GroovyParserSUB, 0)
}

func (s *UnaryAddExprAltContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterUnaryAddExprAlt(s)
	}
}

func (s *UnaryAddExprAltContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitUnaryAddExprAlt(s)
	}
}

type CastExprAltContext struct {
	*CastOperandExpressionContext
}

func NewCastExprAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CastExprAltContext {
	var p = new(CastExprAltContext)

	p.CastOperandExpressionContext = NewEmptyCastOperandExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*CastOperandExpressionContext))

	return p
}

func (s *CastExprAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CastExprAltContext) CastParExpression() ICastParExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICastParExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICastParExpressionContext)
}

func (s *CastExprAltContext) CastOperandExpression() ICastOperandExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICastOperandExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICastOperandExpressionContext)
}

func (s *CastExprAltContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterCastExprAlt(s)
	}
}

func (s *CastExprAltContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitCastExprAlt(s)
	}
}

func (p *GroovyParser) CastOperandExpression() (localctx ICastOperandExpressionContext) {
	localctx = NewCastOperandExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 234, GroovyParserRULE_castOperandExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1403)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 147, p.GetParserRuleContext()) {
	case 1:
		localctx = NewCastExprAltContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1393)
			p.CastParExpression()
		}
		{
			p.SetState(1394)
			p.CastOperandExpression()
		}

	case 2:
		localctx = NewPostfixExprAltContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1396)
			p.PostfixExpression()
		}

	case 3:
		localctx = NewUnaryNotExprAltContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1397)
			_la = p.GetTokenStream().LA(1)

			if !(_la == GroovyParserNOT || _la == GroovyParserBITNOT) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1398)
			p.Nls()
		}
		{
			p.SetState(1399)
			p.CastOperandExpression()
		}

	case 4:
		localctx = NewUnaryAddExprAltContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1401)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*UnaryAddExprAltContext).op = _lt

			_la = p.GetTokenStream().LA(1)

			if !(((_la-100)&-(0x1f+1)) == 0 && ((1<<uint((_la-100)))&((1<<(GroovyParserINC-100))|(1<<(GroovyParserDEC-100))|(1<<(GroovyParserADD-100))|(1<<(GroovyParserSUB-100)))) != 0) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*UnaryAddExprAltContext).op = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1402)
			p.CastOperandExpression()
		}

	}

	return localctx
}

// ICommandExpressionContext is an interface to support dynamic dispatch.
type ICommandExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_expression returns the _expression rule contexts.
	Get_expression() IExpressionContext

	// Set_expression sets the _expression rule contexts.
	Set_expression(IExpressionContext)

	// IsCommandExpressionContext differentiates from other interfaces.
	IsCommandExpressionContext()
}

type CommandExpressionContext struct {
	*GroovyParserRuleContext
	parser      antlr.Parser
	_expression IExpressionContext
}

func NewEmptyCommandExpressionContext() *CommandExpressionContext {
	var p = new(CommandExpressionContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_commandExpression
	return p
}

func (*CommandExpressionContext) IsCommandExpressionContext() {}

func NewCommandExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CommandExpressionContext {
	var p = new(CommandExpressionContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_commandExpression

	return p
}

func (s *CommandExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *CommandExpressionContext) Get_expression() IExpressionContext { return s._expression }

func (s *CommandExpressionContext) Set_expression(v IExpressionContext) { s._expression = v }

func (s *CommandExpressionContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *CommandExpressionContext) ArgumentList() IArgumentListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArgumentListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArgumentListContext)
}

func (s *CommandExpressionContext) AllCommandArgument() []ICommandArgumentContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICommandArgumentContext)(nil)).Elem())
	var tst = make([]ICommandArgumentContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICommandArgumentContext)
		}
	}

	return tst
}

func (s *CommandExpressionContext) CommandArgument(i int) ICommandArgumentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICommandArgumentContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICommandArgumentContext)
}

func (s *CommandExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CommandExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CommandExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterCommandExpression(s)
	}
}

func (s *CommandExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitCommandExpression(s)
	}
}

func (p *GroovyParser) CommandExpression() (localctx ICommandExpressionContext) {
	localctx = NewCommandExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 236, GroovyParserRULE_commandExpression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1405)

		var _x = p.expression(0)

		localctx.(*CommandExpressionContext)._expression = _x
	}
	p.SetState(1409)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 148, p.GetParserRuleContext()) {
	case 1:
		p.SetState(1406)

		if !(!SemanticPredicates.isFollowingArgumentsOrClosure(localctx.(*CommandExpressionContext).Get_expression())) {
			panic(antlr.NewFailedPredicateException(p, " !SemanticPredicates.isFollowingArgumentsOrClosure($expression.ctx) ", ""))
		}
		{
			p.SetState(1407)
			p.ArgumentList()
		}

	case 2:

	}
	p.SetState(1414)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 149, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1411)
				p.CommandArgument()
			}

		}
		p.SetState(1416)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 149, p.GetParserRuleContext())
	}

	return localctx
}

// ICommandArgumentContext is an interface to support dynamic dispatch.
type ICommandArgumentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCommandArgumentContext differentiates from other interfaces.
	IsCommandArgumentContext()
}

type CommandArgumentContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyCommandArgumentContext() *CommandArgumentContext {
	var p = new(CommandArgumentContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_commandArgument
	return p
}

func (*CommandArgumentContext) IsCommandArgumentContext() {}

func NewCommandArgumentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CommandArgumentContext {
	var p = new(CommandArgumentContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_commandArgument

	return p
}

func (s *CommandArgumentContext) GetParser() antlr.Parser { return s.parser }

func (s *CommandArgumentContext) Primary() IPrimaryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrimaryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPrimaryContext)
}

func (s *CommandArgumentContext) ArgumentList() IArgumentListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArgumentListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArgumentListContext)
}

func (s *CommandArgumentContext) AllPathElement() []IPathElementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPathElementContext)(nil)).Elem())
	var tst = make([]IPathElementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPathElementContext)
		}
	}

	return tst
}

func (s *CommandArgumentContext) PathElement(i int) IPathElementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPathElementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPathElementContext)
}

func (s *CommandArgumentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CommandArgumentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CommandArgumentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterCommandArgument(s)
	}
}

func (s *CommandArgumentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitCommandArgument(s)
	}
}

func (p *GroovyParser) CommandArgument() (localctx ICommandArgumentContext) {
	localctx = NewCommandArgumentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 238, GroovyParserRULE_commandArgument)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1417)
		p.Primary()
	}
	p.SetState(1424)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 151, p.GetParserRuleContext()) == 1 {
		p.SetState(1419)
		p.GetErrorHandler().Sync(p)
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
				{
					p.SetState(1418)
					p.PathElement()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

			p.SetState(1421)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 150, p.GetParserRuleContext())
		}

	} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 151, p.GetParserRuleContext()) == 2 {
		{
			p.SetState(1423)
			p.ArgumentList()
		}

	}

	return localctx
}

// IPathExpressionContext is an interface to support dynamic dispatch.
type IPathExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_pathElement returns the _pathElement rule contexts.
	Get_pathElement() IPathElementContext

	// Set_pathElement sets the _pathElement rule contexts.
	Set_pathElement(IPathElementContext)

	// GetT returns the t attribute.
	GetT() int

	// SetT sets the t attribute.
	SetT(int)

	// IsPathExpressionContext differentiates from other interfaces.
	IsPathExpressionContext()
}

type PathExpressionContext struct {
	*GroovyParserRuleContext
	parser       antlr.Parser
	t            int
	_pathElement IPathElementContext
}

func NewEmptyPathExpressionContext() *PathExpressionContext {
	var p = new(PathExpressionContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_pathExpression
	return p
}

func (*PathExpressionContext) IsPathExpressionContext() {}

func NewPathExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PathExpressionContext {
	var p = new(PathExpressionContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_pathExpression

	return p
}

func (s *PathExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *PathExpressionContext) Get_pathElement() IPathElementContext { return s._pathElement }

func (s *PathExpressionContext) Set_pathElement(v IPathElementContext) { s._pathElement = v }

func (s *PathExpressionContext) GetT() int { return s.t }

func (s *PathExpressionContext) SetT(v int) { s.t = v }

func (s *PathExpressionContext) Primary() IPrimaryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrimaryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPrimaryContext)
}

func (s *PathExpressionContext) AllPathElement() []IPathElementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPathElementContext)(nil)).Elem())
	var tst = make([]IPathElementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPathElementContext)
		}
	}

	return tst
}

func (s *PathExpressionContext) PathElement(i int) IPathElementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPathElementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPathElementContext)
}

func (s *PathExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PathExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PathExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterPathExpression(s)
	}
}

func (s *PathExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitPathExpression(s)
	}
}

func (p *GroovyParser) PathExpression() (localctx IPathExpressionContext) {
	localctx = NewPathExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 240, GroovyParserRULE_pathExpression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1426)
		p.Primary()
	}
	p.SetState(1432)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 152, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1427)

				var _x = p.PathElement()

				localctx.(*PathExpressionContext)._pathElement = _x
			}
			localctx.(*PathExpressionContext).SetT(localctx.(*PathExpressionContext).Get_pathElement().GetT())

		}
		p.SetState(1434)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 152, p.GetParserRuleContext())
	}

	return localctx
}

// IPathElementContext is an interface to support dynamic dispatch.
type IPathElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetT returns the t attribute.
	GetT() int

	// SetT sets the t attribute.
	SetT(int)

	// IsPathElementContext differentiates from other interfaces.
	IsPathElementContext()
}

type PathElementContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
	t      int
}

func NewEmptyPathElementContext() *PathElementContext {
	var p = new(PathElementContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_pathElement
	return p
}

func (*PathElementContext) IsPathElementContext() {}

func NewPathElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PathElementContext {
	var p = new(PathElementContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_pathElement

	return p
}

func (s *PathElementContext) GetParser() antlr.Parser { return s.parser }

func (s *PathElementContext) GetT() int { return s.t }

func (s *PathElementContext) SetT(v int) { s.t = v }

func (s *PathElementContext) AllNls() []INlsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INlsContext)(nil)).Elem())
	var tst = make([]INlsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INlsContext)
		}
	}

	return tst
}

func (s *PathElementContext) Nls(i int) INlsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INlsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *PathElementContext) NamePart() INamePartContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INamePartContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INamePartContext)
}

func (s *PathElementContext) METHOD_POINTER() antlr.TerminalNode {
	return s.GetToken(GroovyParserMETHOD_POINTER, 0)
}

func (s *PathElementContext) METHOD_REFERENCE() antlr.TerminalNode {
	return s.GetToken(GroovyParserMETHOD_REFERENCE, 0)
}

func (s *PathElementContext) DOT() antlr.TerminalNode {
	return s.GetToken(GroovyParserDOT, 0)
}

func (s *PathElementContext) SPREAD_DOT() antlr.TerminalNode {
	return s.GetToken(GroovyParserSPREAD_DOT, 0)
}

func (s *PathElementContext) SAFE_DOT() antlr.TerminalNode {
	return s.GetToken(GroovyParserSAFE_DOT, 0)
}

func (s *PathElementContext) SAFE_CHAIN_DOT() antlr.TerminalNode {
	return s.GetToken(GroovyParserSAFE_CHAIN_DOT, 0)
}

func (s *PathElementContext) AT() antlr.TerminalNode {
	return s.GetToken(GroovyParserAT, 0)
}

func (s *PathElementContext) NonWildcardTypeArguments() INonWildcardTypeArgumentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INonWildcardTypeArgumentsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INonWildcardTypeArgumentsContext)
}

func (s *PathElementContext) NEW() antlr.TerminalNode {
	return s.GetToken(GroovyParserNEW, 0)
}

func (s *PathElementContext) Creator() ICreatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICreatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICreatorContext)
}

func (s *PathElementContext) Arguments() IArgumentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArgumentsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArgumentsContext)
}

func (s *PathElementContext) ClosureOrLambdaExpression() IClosureOrLambdaExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClosureOrLambdaExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClosureOrLambdaExpressionContext)
}

func (s *PathElementContext) IndexPropertyArgs() IIndexPropertyArgsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIndexPropertyArgsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIndexPropertyArgsContext)
}

func (s *PathElementContext) NamedPropertyArgs() INamedPropertyArgsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INamedPropertyArgsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INamedPropertyArgsContext)
}

func (s *PathElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PathElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PathElementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterPathElement(s)
	}
}

func (s *PathElementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitPathElement(s)
	}
}

func (p *GroovyParser) PathElement() (localctx IPathElementContext) {
	localctx = NewPathElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 242, GroovyParserRULE_pathElement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1471)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 155, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1435)
			p.Nls()
		}
		p.SetState(1446)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case GroovyParserSPREAD_DOT, GroovyParserSAFE_DOT, GroovyParserSAFE_CHAIN_DOT, GroovyParserDOT:
			{
				p.SetState(1436)
				_la = p.GetTokenStream().LA(1)

				if !(((_la-62)&-(0x1f+1)) == 0 && ((1<<uint((_la-62)))&((1<<(GroovyParserSPREAD_DOT-62))|(1<<(GroovyParserSAFE_DOT-62))|(1<<(GroovyParserSAFE_CHAIN_DOT-62))|(1<<(GroovyParserDOT-62)))) != 0) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(1437)
				p.Nls()
			}
			p.SetState(1440)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 153, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(1438)
					p.Match(GroovyParserAT)
				}

			} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 153, p.GetParserRuleContext()) == 2 {
				{
					p.SetState(1439)
					p.NonWildcardTypeArguments()
				}

			}

		case GroovyParserMETHOD_POINTER:
			{
				p.SetState(1442)
				p.Match(GroovyParserMETHOD_POINTER)
			}
			{
				p.SetState(1443)
				p.Nls()
			}

		case GroovyParserMETHOD_REFERENCE:
			{
				p.SetState(1444)
				p.Match(GroovyParserMETHOD_REFERENCE)
			}
			{
				p.SetState(1445)
				p.Nls()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}
		{
			p.SetState(1448)
			p.NamePart()
		}
		localctx.(*PathElementContext).SetT(1)

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1451)
			p.Nls()
		}
		{
			p.SetState(1452)
			p.Match(GroovyParserDOT)
		}
		{
			p.SetState(1453)
			p.Nls()
		}
		{
			p.SetState(1454)
			p.Match(GroovyParserNEW)
		}
		{
			p.SetState(1455)
			p.Creator(1)
		}
		localctx.(*PathElementContext).SetT(6)

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1458)
			p.Arguments()
		}
		localctx.(*PathElementContext).SetT(2)

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1461)
			p.Nls()
		}
		{
			p.SetState(1462)
			p.ClosureOrLambdaExpression()
		}
		localctx.(*PathElementContext).SetT(3)

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1465)
			p.IndexPropertyArgs()
		}
		localctx.(*PathElementContext).SetT(4)

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1468)
			p.NamedPropertyArgs()
		}
		localctx.(*PathElementContext).SetT(5)

	}

	return localctx
}

// INamePartContext is an interface to support dynamic dispatch.
type INamePartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNamePartContext differentiates from other interfaces.
	IsNamePartContext()
}

type NamePartContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyNamePartContext() *NamePartContext {
	var p = new(NamePartContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_namePart
	return p
}

func (*NamePartContext) IsNamePartContext() {}

func NewNamePartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NamePartContext {
	var p = new(NamePartContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_namePart

	return p
}

func (s *NamePartContext) GetParser() antlr.Parser { return s.parser }

func (s *NamePartContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *NamePartContext) StringLiteral() IStringLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStringLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *NamePartContext) DynamicMemberName() IDynamicMemberNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDynamicMemberNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDynamicMemberNameContext)
}

func (s *NamePartContext) Keywords() IKeywordsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IKeywordsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IKeywordsContext)
}

func (s *NamePartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NamePartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NamePartContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterNamePart(s)
	}
}

func (s *NamePartContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitNamePart(s)
	}
}

func (p *GroovyParser) NamePart() (localctx INamePartContext) {
	localctx = NewNamePartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 244, GroovyParserRULE_namePart)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1477)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 156, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1473)
			p.Identifier()
		}

	case 2:
		{
			p.SetState(1474)
			p.StringLiteral()
		}

	case 3:
		{
			p.SetState(1475)
			p.DynamicMemberName()
		}

	case 4:
		{
			p.SetState(1476)
			p.Keywords()
		}

	}

	return localctx
}

// IDynamicMemberNameContext is an interface to support dynamic dispatch.
type IDynamicMemberNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDynamicMemberNameContext differentiates from other interfaces.
	IsDynamicMemberNameContext()
}

type DynamicMemberNameContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyDynamicMemberNameContext() *DynamicMemberNameContext {
	var p = new(DynamicMemberNameContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_dynamicMemberName
	return p
}

func (*DynamicMemberNameContext) IsDynamicMemberNameContext() {}

func NewDynamicMemberNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DynamicMemberNameContext {
	var p = new(DynamicMemberNameContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_dynamicMemberName

	return p
}

func (s *DynamicMemberNameContext) GetParser() antlr.Parser { return s.parser }

func (s *DynamicMemberNameContext) ParExpression() IParExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParExpressionContext)
}

func (s *DynamicMemberNameContext) Gstring() IGstringContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGstringContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGstringContext)
}

func (s *DynamicMemberNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DynamicMemberNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DynamicMemberNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterDynamicMemberName(s)
	}
}

func (s *DynamicMemberNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitDynamicMemberName(s)
	}
}

func (p *GroovyParser) DynamicMemberName() (localctx IDynamicMemberNameContext) {
	localctx = NewDynamicMemberNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 246, GroovyParserRULE_dynamicMemberName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1481)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case GroovyParserLPAREN:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1479)
			p.ParExpression()
		}

	case GroovyParserGStringBegin:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1480)
			p.Gstring()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IIndexPropertyArgsContext is an interface to support dynamic dispatch.
type IIndexPropertyArgsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIndexPropertyArgsContext differentiates from other interfaces.
	IsIndexPropertyArgsContext()
}

type IndexPropertyArgsContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyIndexPropertyArgsContext() *IndexPropertyArgsContext {
	var p = new(IndexPropertyArgsContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_indexPropertyArgs
	return p
}

func (*IndexPropertyArgsContext) IsIndexPropertyArgsContext() {}

func NewIndexPropertyArgsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IndexPropertyArgsContext {
	var p = new(IndexPropertyArgsContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_indexPropertyArgs

	return p
}

func (s *IndexPropertyArgsContext) GetParser() antlr.Parser { return s.parser }

func (s *IndexPropertyArgsContext) LBRACK() antlr.TerminalNode {
	return s.GetToken(GroovyParserLBRACK, 0)
}

func (s *IndexPropertyArgsContext) RBRACK() antlr.TerminalNode {
	return s.GetToken(GroovyParserRBRACK, 0)
}

func (s *IndexPropertyArgsContext) QUESTION() antlr.TerminalNode {
	return s.GetToken(GroovyParserQUESTION, 0)
}

func (s *IndexPropertyArgsContext) ExpressionList() IExpressionListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *IndexPropertyArgsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IndexPropertyArgsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IndexPropertyArgsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterIndexPropertyArgs(s)
	}
}

func (s *IndexPropertyArgsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitIndexPropertyArgs(s)
	}
}

func (p *GroovyParser) IndexPropertyArgs() (localctx IIndexPropertyArgsContext) {
	localctx = NewIndexPropertyArgsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 248, GroovyParserRULE_indexPropertyArgs)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1484)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == GroovyParserQUESTION {
		{
			p.SetState(1483)
			p.Match(GroovyParserQUESTION)
		}

	}
	{
		p.SetState(1486)
		p.Match(GroovyParserLBRACK)
	}
	p.SetState(1488)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 159, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1487)
			p.ExpressionList(true)
		}

	}
	{
		p.SetState(1490)
		p.Match(GroovyParserRBRACK)
	}

	return localctx
}

// INamedPropertyArgsContext is an interface to support dynamic dispatch.
type INamedPropertyArgsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNamedPropertyArgsContext differentiates from other interfaces.
	IsNamedPropertyArgsContext()
}

type NamedPropertyArgsContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyNamedPropertyArgsContext() *NamedPropertyArgsContext {
	var p = new(NamedPropertyArgsContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_namedPropertyArgs
	return p
}

func (*NamedPropertyArgsContext) IsNamedPropertyArgsContext() {}

func NewNamedPropertyArgsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NamedPropertyArgsContext {
	var p = new(NamedPropertyArgsContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_namedPropertyArgs

	return p
}

func (s *NamedPropertyArgsContext) GetParser() antlr.Parser { return s.parser }

func (s *NamedPropertyArgsContext) LBRACK() antlr.TerminalNode {
	return s.GetToken(GroovyParserLBRACK, 0)
}

func (s *NamedPropertyArgsContext) RBRACK() antlr.TerminalNode {
	return s.GetToken(GroovyParserRBRACK, 0)
}

func (s *NamedPropertyArgsContext) MapEntryList() IMapEntryListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMapEntryListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMapEntryListContext)
}

func (s *NamedPropertyArgsContext) COLON() antlr.TerminalNode {
	return s.GetToken(GroovyParserCOLON, 0)
}

func (s *NamedPropertyArgsContext) QUESTION() antlr.TerminalNode {
	return s.GetToken(GroovyParserQUESTION, 0)
}

func (s *NamedPropertyArgsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NamedPropertyArgsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NamedPropertyArgsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterNamedPropertyArgs(s)
	}
}

func (s *NamedPropertyArgsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitNamedPropertyArgs(s)
	}
}

func (p *GroovyParser) NamedPropertyArgs() (localctx INamedPropertyArgsContext) {
	localctx = NewNamedPropertyArgsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 250, GroovyParserRULE_namedPropertyArgs)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1493)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == GroovyParserQUESTION {
		{
			p.SetState(1492)
			p.Match(GroovyParserQUESTION)
		}

	}
	{
		p.SetState(1495)
		p.Match(GroovyParserLBRACK)
	}
	p.SetState(1498)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 161, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1496)
			p.MapEntryList()
		}

	case 2:
		{
			p.SetState(1497)
			p.Match(GroovyParserCOLON)
		}

	}
	{
		p.SetState(1500)
		p.Match(GroovyParserRBRACK)
	}

	return localctx
}

// IPrimaryContext is an interface to support dynamic dispatch.
type IPrimaryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPrimaryContext differentiates from other interfaces.
	IsPrimaryContext()
}

type PrimaryContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrimaryContext() *PrimaryContext {
	var p = new(PrimaryContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_primary
	return p
}

func (*PrimaryContext) IsPrimaryContext() {}

func NewPrimaryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrimaryContext {
	var p = new(PrimaryContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_primary

	return p
}

func (s *PrimaryContext) GetParser() antlr.Parser { return s.parser }

func (s *PrimaryContext) CopyFrom(ctx *PrimaryContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *PrimaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimaryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type MapPrmrAltContext struct {
	*PrimaryContext
}

func NewMapPrmrAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *MapPrmrAltContext {
	var p = new(MapPrmrAltContext)

	p.PrimaryContext = NewEmptyPrimaryContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryContext))

	return p
}

func (s *MapPrmrAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MapPrmrAltContext) NormalMap() INormalMapContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INormalMapContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INormalMapContext)
}

func (s *MapPrmrAltContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterMapPrmrAlt(s)
	}
}

func (s *MapPrmrAltContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitMapPrmrAlt(s)
	}
}

type GstringPrmrAltContext struct {
	*PrimaryContext
}

func NewGstringPrmrAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *GstringPrmrAltContext {
	var p = new(GstringPrmrAltContext)

	p.PrimaryContext = NewEmptyPrimaryContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryContext))

	return p
}

func (s *GstringPrmrAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GstringPrmrAltContext) Gstring() IGstringContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGstringContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGstringContext)
}

func (s *GstringPrmrAltContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterGstringPrmrAlt(s)
	}
}

func (s *GstringPrmrAltContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitGstringPrmrAlt(s)
	}
}

type ListPrmrAltContext struct {
	*PrimaryContext
}

func NewListPrmrAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ListPrmrAltContext {
	var p = new(ListPrmrAltContext)

	p.PrimaryContext = NewEmptyPrimaryContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryContext))

	return p
}

func (s *ListPrmrAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ListPrmrAltContext) List() IListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IListContext)
}

func (s *ListPrmrAltContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterListPrmrAlt(s)
	}
}

func (s *ListPrmrAltContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitListPrmrAlt(s)
	}
}

type NewPrmrAltContext struct {
	*PrimaryContext
}

func NewNewPrmrAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NewPrmrAltContext {
	var p = new(NewPrmrAltContext)

	p.PrimaryContext = NewEmptyPrimaryContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryContext))

	return p
}

func (s *NewPrmrAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NewPrmrAltContext) NEW() antlr.TerminalNode {
	return s.GetToken(GroovyParserNEW, 0)
}

func (s *NewPrmrAltContext) Nls() INlsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INlsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *NewPrmrAltContext) Creator() ICreatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICreatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICreatorContext)
}

func (s *NewPrmrAltContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterNewPrmrAlt(s)
	}
}

func (s *NewPrmrAltContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitNewPrmrAlt(s)
	}
}

type LiteralPrmrAltContext struct {
	*PrimaryContext
}

func NewLiteralPrmrAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LiteralPrmrAltContext {
	var p = new(LiteralPrmrAltContext)

	p.PrimaryContext = NewEmptyPrimaryContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryContext))

	return p
}

func (s *LiteralPrmrAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralPrmrAltContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *LiteralPrmrAltContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterLiteralPrmrAlt(s)
	}
}

func (s *LiteralPrmrAltContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitLiteralPrmrAlt(s)
	}
}

type ThisPrmrAltContext struct {
	*PrimaryContext
}

func NewThisPrmrAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ThisPrmrAltContext {
	var p = new(ThisPrmrAltContext)

	p.PrimaryContext = NewEmptyPrimaryContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryContext))

	return p
}

func (s *ThisPrmrAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ThisPrmrAltContext) THIS() antlr.TerminalNode {
	return s.GetToken(GroovyParserTHIS, 0)
}

func (s *ThisPrmrAltContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterThisPrmrAlt(s)
	}
}

func (s *ThisPrmrAltContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitThisPrmrAlt(s)
	}
}

type ClosureOrLambdaExpressionPrmrAltContext struct {
	*PrimaryContext
}

func NewClosureOrLambdaExpressionPrmrAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ClosureOrLambdaExpressionPrmrAltContext {
	var p = new(ClosureOrLambdaExpressionPrmrAltContext)

	p.PrimaryContext = NewEmptyPrimaryContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryContext))

	return p
}

func (s *ClosureOrLambdaExpressionPrmrAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClosureOrLambdaExpressionPrmrAltContext) ClosureOrLambdaExpression() IClosureOrLambdaExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClosureOrLambdaExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClosureOrLambdaExpressionContext)
}

func (s *ClosureOrLambdaExpressionPrmrAltContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterClosureOrLambdaExpressionPrmrAlt(s)
	}
}

func (s *ClosureOrLambdaExpressionPrmrAltContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitClosureOrLambdaExpressionPrmrAlt(s)
	}
}

type BuiltInTypePrmrAltContext struct {
	*PrimaryContext
}

func NewBuiltInTypePrmrAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BuiltInTypePrmrAltContext {
	var p = new(BuiltInTypePrmrAltContext)

	p.PrimaryContext = NewEmptyPrimaryContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryContext))

	return p
}

func (s *BuiltInTypePrmrAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BuiltInTypePrmrAltContext) BuiltInType() IBuiltInTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBuiltInTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBuiltInTypeContext)
}

func (s *BuiltInTypePrmrAltContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterBuiltInTypePrmrAlt(s)
	}
}

func (s *BuiltInTypePrmrAltContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitBuiltInTypePrmrAlt(s)
	}
}

type IdentifierPrmrAltContext struct {
	*PrimaryContext
}

func NewIdentifierPrmrAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IdentifierPrmrAltContext {
	var p = new(IdentifierPrmrAltContext)

	p.PrimaryContext = NewEmptyPrimaryContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryContext))

	return p
}

func (s *IdentifierPrmrAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierPrmrAltContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *IdentifierPrmrAltContext) TypeArguments() ITypeArgumentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeArgumentsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeArgumentsContext)
}

func (s *IdentifierPrmrAltContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterIdentifierPrmrAlt(s)
	}
}

func (s *IdentifierPrmrAltContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitIdentifierPrmrAlt(s)
	}
}

type SuperPrmrAltContext struct {
	*PrimaryContext
}

func NewSuperPrmrAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SuperPrmrAltContext {
	var p = new(SuperPrmrAltContext)

	p.PrimaryContext = NewEmptyPrimaryContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryContext))

	return p
}

func (s *SuperPrmrAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SuperPrmrAltContext) SUPER() antlr.TerminalNode {
	return s.GetToken(GroovyParserSUPER, 0)
}

func (s *SuperPrmrAltContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterSuperPrmrAlt(s)
	}
}

func (s *SuperPrmrAltContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitSuperPrmrAlt(s)
	}
}

type ParenPrmrAltContext struct {
	*PrimaryContext
}

func NewParenPrmrAltContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ParenPrmrAltContext {
	var p = new(ParenPrmrAltContext)

	p.PrimaryContext = NewEmptyPrimaryContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryContext))

	return p
}

func (s *ParenPrmrAltContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParenPrmrAltContext) ParExpression() IParExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParExpressionContext)
}

func (s *ParenPrmrAltContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterParenPrmrAlt(s)
	}
}

func (s *ParenPrmrAltContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitParenPrmrAlt(s)
	}
}

func (p *GroovyParser) Primary() (localctx IPrimaryContext) {
	localctx = NewPrimaryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 252, GroovyParserRULE_primary)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1519)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 163, p.GetParserRuleContext()) {
	case 1:
		localctx = NewIdentifierPrmrAltContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1502)
			p.Identifier()
		}
		p.SetState(1504)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 162, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1503)
				p.TypeArguments()
			}

		}

	case 2:
		localctx = NewLiteralPrmrAltContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1506)
			p.Literal()
		}

	case 3:
		localctx = NewGstringPrmrAltContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1507)
			p.Gstring()
		}

	case 4:
		localctx = NewNewPrmrAltContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1508)
			p.Match(GroovyParserNEW)
		}
		{
			p.SetState(1509)
			p.Nls()
		}
		{
			p.SetState(1510)
			p.Creator(0)
		}

	case 5:
		localctx = NewThisPrmrAltContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1512)
			p.Match(GroovyParserTHIS)
		}

	case 6:
		localctx = NewSuperPrmrAltContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1513)
			p.Match(GroovyParserSUPER)
		}

	case 7:
		localctx = NewParenPrmrAltContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1514)
			p.ParExpression()
		}

	case 8:
		localctx = NewClosureOrLambdaExpressionPrmrAltContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1515)
			p.ClosureOrLambdaExpression()
		}

	case 9:
		localctx = NewListPrmrAltContext(p, localctx)
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1516)
			p.List()
		}

	case 10:
		localctx = NewMapPrmrAltContext(p, localctx)
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1517)
			p.NormalMap()
		}

	case 11:
		localctx = NewBuiltInTypePrmrAltContext(p, localctx)
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(1518)
			p.BuiltInType()
		}

	}

	return localctx
}

// IListContext is an interface to support dynamic dispatch.
type IListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsListContext differentiates from other interfaces.
	IsListContext()
}

type ListContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyListContext() *ListContext {
	var p = new(ListContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_list
	return p
}

func (*ListContext) IsListContext() {}

func NewListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ListContext {
	var p = new(ListContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_list

	return p
}

func (s *ListContext) GetParser() antlr.Parser { return s.parser }

func (s *ListContext) LBRACK() antlr.TerminalNode {
	return s.GetToken(GroovyParserLBRACK, 0)
}

func (s *ListContext) RBRACK() antlr.TerminalNode {
	return s.GetToken(GroovyParserRBRACK, 0)
}

func (s *ListContext) ExpressionList() IExpressionListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *ListContext) COMMA() antlr.TerminalNode {
	return s.GetToken(GroovyParserCOMMA, 0)
}

func (s *ListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterList(s)
	}
}

func (s *ListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitList(s)
	}
}

func (p *GroovyParser) List() (localctx IListContext) {
	localctx = NewListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 254, GroovyParserRULE_list)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1521)
		p.Match(GroovyParserLBRACK)
	}
	p.SetState(1523)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 164, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1522)
			p.ExpressionList(true)
		}

	}
	p.SetState(1526)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == GroovyParserCOMMA {
		{
			p.SetState(1525)
			p.Match(GroovyParserCOMMA)
		}

	}
	{
		p.SetState(1528)
		p.Match(GroovyParserRBRACK)
	}

	return localctx
}

// INormalMapContext is an interface to support dynamic dispatch.
type INormalMapContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNormalMapContext differentiates from other interfaces.
	IsNormalMapContext()
}

type NormalMapContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyNormalMapContext() *NormalMapContext {
	var p = new(NormalMapContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_normalMap
	return p
}

func (*NormalMapContext) IsNormalMapContext() {}

func NewNormalMapContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NormalMapContext {
	var p = new(NormalMapContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_normalMap

	return p
}

func (s *NormalMapContext) GetParser() antlr.Parser { return s.parser }

func (s *NormalMapContext) LBRACK() antlr.TerminalNode {
	return s.GetToken(GroovyParserLBRACK, 0)
}

func (s *NormalMapContext) RBRACK() antlr.TerminalNode {
	return s.GetToken(GroovyParserRBRACK, 0)
}

func (s *NormalMapContext) MapEntryList() IMapEntryListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMapEntryListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMapEntryListContext)
}

func (s *NormalMapContext) COLON() antlr.TerminalNode {
	return s.GetToken(GroovyParserCOLON, 0)
}

func (s *NormalMapContext) COMMA() antlr.TerminalNode {
	return s.GetToken(GroovyParserCOMMA, 0)
}

func (s *NormalMapContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NormalMapContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NormalMapContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterNormalMap(s)
	}
}

func (s *NormalMapContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitNormalMap(s)
	}
}

func (p *GroovyParser) NormalMap() (localctx INormalMapContext) {
	localctx = NewNormalMapContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 256, GroovyParserRULE_normalMap)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1530)
		p.Match(GroovyParserLBRACK)
	}
	p.SetState(1536)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 167, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1531)
			p.MapEntryList()
		}
		p.SetState(1533)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == GroovyParserCOMMA {
			{
				p.SetState(1532)
				p.Match(GroovyParserCOMMA)
			}

		}

	case 2:
		{
			p.SetState(1535)
			p.Match(GroovyParserCOLON)
		}

	}
	{
		p.SetState(1538)
		p.Match(GroovyParserRBRACK)
	}

	return localctx
}

// IMapEntryListContext is an interface to support dynamic dispatch.
type IMapEntryListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMapEntryListContext differentiates from other interfaces.
	IsMapEntryListContext()
}

type MapEntryListContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyMapEntryListContext() *MapEntryListContext {
	var p = new(MapEntryListContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_mapEntryList
	return p
}

func (*MapEntryListContext) IsMapEntryListContext() {}

func NewMapEntryListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MapEntryListContext {
	var p = new(MapEntryListContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_mapEntryList

	return p
}

func (s *MapEntryListContext) GetParser() antlr.Parser { return s.parser }

func (s *MapEntryListContext) AllMapEntry() []IMapEntryContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IMapEntryContext)(nil)).Elem())
	var tst = make([]IMapEntryContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IMapEntryContext)
		}
	}

	return tst
}

func (s *MapEntryListContext) MapEntry(i int) IMapEntryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMapEntryContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IMapEntryContext)
}

func (s *MapEntryListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(GroovyParserCOMMA)
}

func (s *MapEntryListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(GroovyParserCOMMA, i)
}

func (s *MapEntryListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MapEntryListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MapEntryListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterMapEntryList(s)
	}
}

func (s *MapEntryListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitMapEntryList(s)
	}
}

func (p *GroovyParser) MapEntryList() (localctx IMapEntryListContext) {
	localctx = NewMapEntryListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 258, GroovyParserRULE_mapEntryList)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1540)
		p.MapEntry()
	}
	p.SetState(1545)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 168, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1541)
				p.Match(GroovyParserCOMMA)
			}
			{
				p.SetState(1542)
				p.MapEntry()
			}

		}
		p.SetState(1547)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 168, p.GetParserRuleContext())
	}

	return localctx
}

// IMapEntryContext is an interface to support dynamic dispatch.
type IMapEntryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMapEntryContext differentiates from other interfaces.
	IsMapEntryContext()
}

type MapEntryContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyMapEntryContext() *MapEntryContext {
	var p = new(MapEntryContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_mapEntry
	return p
}

func (*MapEntryContext) IsMapEntryContext() {}

func NewMapEntryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MapEntryContext {
	var p = new(MapEntryContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_mapEntry

	return p
}

func (s *MapEntryContext) GetParser() antlr.Parser { return s.parser }

func (s *MapEntryContext) MapEntryLabel() IMapEntryLabelContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMapEntryLabelContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMapEntryLabelContext)
}

func (s *MapEntryContext) COLON() antlr.TerminalNode {
	return s.GetToken(GroovyParserCOLON, 0)
}

func (s *MapEntryContext) Nls() INlsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INlsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *MapEntryContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *MapEntryContext) MUL() antlr.TerminalNode {
	return s.GetToken(GroovyParserMUL, 0)
}

func (s *MapEntryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MapEntryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MapEntryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterMapEntry(s)
	}
}

func (s *MapEntryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitMapEntry(s)
	}
}

func (p *GroovyParser) MapEntry() (localctx IMapEntryContext) {
	localctx = NewMapEntryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 260, GroovyParserRULE_mapEntry)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1558)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 169, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1548)
			p.MapEntryLabel()
		}
		{
			p.SetState(1549)
			p.Match(GroovyParserCOLON)
		}
		{
			p.SetState(1550)
			p.Nls()
		}
		{
			p.SetState(1551)
			p.expression(0)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1553)
			p.Match(GroovyParserMUL)
		}
		{
			p.SetState(1554)
			p.Match(GroovyParserCOLON)
		}
		{
			p.SetState(1555)
			p.Nls()
		}
		{
			p.SetState(1556)
			p.expression(0)
		}

	}

	return localctx
}

// IMapEntryLabelContext is an interface to support dynamic dispatch.
type IMapEntryLabelContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMapEntryLabelContext differentiates from other interfaces.
	IsMapEntryLabelContext()
}

type MapEntryLabelContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyMapEntryLabelContext() *MapEntryLabelContext {
	var p = new(MapEntryLabelContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_mapEntryLabel
	return p
}

func (*MapEntryLabelContext) IsMapEntryLabelContext() {}

func NewMapEntryLabelContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MapEntryLabelContext {
	var p = new(MapEntryLabelContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_mapEntryLabel

	return p
}

func (s *MapEntryLabelContext) GetParser() antlr.Parser { return s.parser }

func (s *MapEntryLabelContext) Keywords() IKeywordsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IKeywordsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IKeywordsContext)
}

func (s *MapEntryLabelContext) Primary() IPrimaryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrimaryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPrimaryContext)
}

func (s *MapEntryLabelContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MapEntryLabelContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MapEntryLabelContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterMapEntryLabel(s)
	}
}

func (s *MapEntryLabelContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitMapEntryLabel(s)
	}
}

func (p *GroovyParser) MapEntryLabel() (localctx IMapEntryLabelContext) {
	localctx = NewMapEntryLabelContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 262, GroovyParserRULE_mapEntryLabel)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1562)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 170, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1560)
			p.Keywords()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1561)
			p.Primary()
		}

	}

	return localctx
}

// ICreatorContext is an interface to support dynamic dispatch.
type ICreatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetT returns the t attribute.
	GetT() int

	// SetT sets the t attribute.
	SetT(int)

	// IsCreatorContext differentiates from other interfaces.
	IsCreatorContext()
}

type CreatorContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
	t      int
}

func NewEmptyCreatorContext() *CreatorContext {
	var p = new(CreatorContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_creator
	return p
}

func (*CreatorContext) IsCreatorContext() {}

func NewCreatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int, t int) *CreatorContext {
	var p = new(CreatorContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_creator

	p.t = t

	return p
}

func (s *CreatorContext) GetParser() antlr.Parser { return s.parser }

func (s *CreatorContext) GetT() int { return s.t }

func (s *CreatorContext) SetT(v int) { s.t = v }

func (s *CreatorContext) CreatedName() ICreatedNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICreatedNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICreatedNameContext)
}

func (s *CreatorContext) Nls() INlsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INlsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *CreatorContext) Arguments() IArgumentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArgumentsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArgumentsContext)
}

func (s *CreatorContext) DimsOpt() IDimsOptContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDimsOptContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDimsOptContext)
}

func (s *CreatorContext) Dims() IDimsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDimsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDimsContext)
}

func (s *CreatorContext) ArrayInitializer() IArrayInitializerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArrayInitializerContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArrayInitializerContext)
}

func (s *CreatorContext) AnonymousInnerClassDeclaration() IAnonymousInnerClassDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnonymousInnerClassDeclarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAnonymousInnerClassDeclarationContext)
}

func (s *CreatorContext) AllAnnotationsOpt() []IAnnotationsOptContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAnnotationsOptContext)(nil)).Elem())
	var tst = make([]IAnnotationsOptContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAnnotationsOptContext)
		}
	}

	return tst
}

func (s *CreatorContext) AnnotationsOpt(i int) IAnnotationsOptContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotationsOptContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAnnotationsOptContext)
}

func (s *CreatorContext) AllLBRACK() []antlr.TerminalNode {
	return s.GetTokens(GroovyParserLBRACK)
}

func (s *CreatorContext) LBRACK(i int) antlr.TerminalNode {
	return s.GetToken(GroovyParserLBRACK, i)
}

func (s *CreatorContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *CreatorContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *CreatorContext) AllRBRACK() []antlr.TerminalNode {
	return s.GetTokens(GroovyParserRBRACK)
}

func (s *CreatorContext) RBRACK(i int) antlr.TerminalNode {
	return s.GetToken(GroovyParserRBRACK, i)
}

func (s *CreatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterCreator(s)
	}
}

func (s *CreatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitCreator(s)
	}
}

func (p *GroovyParser) Creator(t int) (localctx ICreatorContext) {
	localctx = NewCreatorContext(p, p.GetParserRuleContext(), p.GetState(), t)
	p.EnterRule(localctx, 264, GroovyParserRULE_creator)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1564)
		p.CreatedName()
	}
	p.SetState(1588)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 173, p.GetParserRuleContext()) {
	case 1:
		p.SetState(1565)

		if !(0 == localctx.(*CreatorContext).t || 1 == localctx.(*CreatorContext).t) {
			panic(antlr.NewFailedPredicateException(p, "0 == $t || 1 == $t", ""))
		}
		{
			p.SetState(1566)
			p.Nls()
		}
		{
			p.SetState(1567)
			p.Arguments()
		}
		p.SetState(1569)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 171, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1568)
				p.AnonymousInnerClassDeclaration(0)
			}

		}

	case 2:
		p.SetState(1571)

		if !(0 == localctx.(*CreatorContext).t) {
			panic(antlr.NewFailedPredicateException(p, "0 == $t", ""))
		}
		p.SetState(1577)
		p.GetErrorHandler().Sync(p)
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
				{
					p.SetState(1572)
					p.AnnotationsOpt()
				}
				{
					p.SetState(1573)
					p.Match(GroovyParserLBRACK)
				}
				{
					p.SetState(1574)
					p.expression(0)
				}
				{
					p.SetState(1575)
					p.Match(GroovyParserRBRACK)
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

			p.SetState(1579)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 172, p.GetParserRuleContext())
		}
		{
			p.SetState(1581)
			p.DimsOpt()
		}

	case 3:
		p.SetState(1583)

		if !(0 == localctx.(*CreatorContext).t) {
			panic(antlr.NewFailedPredicateException(p, "0 == $t", ""))
		}
		{
			p.SetState(1584)
			p.Dims()
		}
		{
			p.SetState(1585)
			p.Nls()
		}
		{
			p.SetState(1586)
			p.ArrayInitializer()
		}

	}

	return localctx
}

// IArrayInitializerContext is an interface to support dynamic dispatch.
type IArrayInitializerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArrayInitializerContext differentiates from other interfaces.
	IsArrayInitializerContext()
}

type ArrayInitializerContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrayInitializerContext() *ArrayInitializerContext {
	var p = new(ArrayInitializerContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_arrayInitializer
	return p
}

func (*ArrayInitializerContext) IsArrayInitializerContext() {}

func NewArrayInitializerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrayInitializerContext {
	var p = new(ArrayInitializerContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_arrayInitializer

	return p
}

func (s *ArrayInitializerContext) GetParser() antlr.Parser { return s.parser }

func (s *ArrayInitializerContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(GroovyParserLBRACE, 0)
}

func (s *ArrayInitializerContext) AllNls() []INlsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INlsContext)(nil)).Elem())
	var tst = make([]INlsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INlsContext)
		}
	}

	return tst
}

func (s *ArrayInitializerContext) Nls(i int) INlsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INlsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *ArrayInitializerContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(GroovyParserRBRACE, 0)
}

func (s *ArrayInitializerContext) VariableInitializers() IVariableInitializersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableInitializersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariableInitializersContext)
}

func (s *ArrayInitializerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayInitializerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArrayInitializerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterArrayInitializer(s)
	}
}

func (s *ArrayInitializerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitArrayInitializer(s)
	}
}

func (p *GroovyParser) ArrayInitializer() (localctx IArrayInitializerContext) {
	localctx = NewArrayInitializerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 266, GroovyParserRULE_arrayInitializer)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1590)
		p.Match(GroovyParserLBRACE)
	}
	{
		p.SetState(1591)
		p.Nls()
	}
	p.SetState(1593)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 174, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1592)
			p.VariableInitializers()
		}

	}
	{
		p.SetState(1595)
		p.Nls()
	}
	{
		p.SetState(1596)
		p.Match(GroovyParserRBRACE)
	}

	return localctx
}

// IAnonymousInnerClassDeclarationContext is an interface to support dynamic dispatch.
type IAnonymousInnerClassDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetT returns the t attribute.
	GetT() int

	// SetT sets the t attribute.
	SetT(int)

	// IsAnonymousInnerClassDeclarationContext differentiates from other interfaces.
	IsAnonymousInnerClassDeclarationContext()
}

type AnonymousInnerClassDeclarationContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
	t      int
}

func NewEmptyAnonymousInnerClassDeclarationContext() *AnonymousInnerClassDeclarationContext {
	var p = new(AnonymousInnerClassDeclarationContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_anonymousInnerClassDeclaration
	return p
}

func (*AnonymousInnerClassDeclarationContext) IsAnonymousInnerClassDeclarationContext() {}

func NewAnonymousInnerClassDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int, t int) *AnonymousInnerClassDeclarationContext {
	var p = new(AnonymousInnerClassDeclarationContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_anonymousInnerClassDeclaration

	p.t = t

	return p
}

func (s *AnonymousInnerClassDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *AnonymousInnerClassDeclarationContext) GetT() int { return s.t }

func (s *AnonymousInnerClassDeclarationContext) SetT(v int) { s.t = v }

func (s *AnonymousInnerClassDeclarationContext) ClassBody() IClassBodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClassBodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClassBodyContext)
}

func (s *AnonymousInnerClassDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnonymousInnerClassDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AnonymousInnerClassDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterAnonymousInnerClassDeclaration(s)
	}
}

func (s *AnonymousInnerClassDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitAnonymousInnerClassDeclaration(s)
	}
}

func (p *GroovyParser) AnonymousInnerClassDeclaration(t int) (localctx IAnonymousInnerClassDeclarationContext) {
	localctx = NewAnonymousInnerClassDeclarationContext(p, p.GetParserRuleContext(), p.GetState(), t)
	p.EnterRule(localctx, 268, GroovyParserRULE_anonymousInnerClassDeclaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1598)
		p.ClassBody(0)
	}

	return localctx
}

// ICreatedNameContext is an interface to support dynamic dispatch.
type ICreatedNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCreatedNameContext differentiates from other interfaces.
	IsCreatedNameContext()
}

type CreatedNameContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreatedNameContext() *CreatedNameContext {
	var p = new(CreatedNameContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_createdName
	return p
}

func (*CreatedNameContext) IsCreatedNameContext() {}

func NewCreatedNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreatedNameContext {
	var p = new(CreatedNameContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_createdName

	return p
}

func (s *CreatedNameContext) GetParser() antlr.Parser { return s.parser }

func (s *CreatedNameContext) AnnotationsOpt() IAnnotationsOptContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotationsOptContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAnnotationsOptContext)
}

func (s *CreatedNameContext) PrimitiveType() IPrimitiveTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrimitiveTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPrimitiveTypeContext)
}

func (s *CreatedNameContext) QualifiedClassName() IQualifiedClassNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedClassNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedClassNameContext)
}

func (s *CreatedNameContext) TypeArgumentsOrDiamond() ITypeArgumentsOrDiamondContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeArgumentsOrDiamondContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeArgumentsOrDiamondContext)
}

func (s *CreatedNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreatedNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreatedNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterCreatedName(s)
	}
}

func (s *CreatedNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitCreatedName(s)
	}
}

func (p *GroovyParser) CreatedName() (localctx ICreatedNameContext) {
	localctx = NewCreatedNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 270, GroovyParserRULE_createdName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1600)
		p.AnnotationsOpt()
	}
	p.SetState(1606)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 176, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1601)
			p.PrimitiveType()
		}

	case 2:
		{
			p.SetState(1602)
			p.QualifiedClassName()
		}
		p.SetState(1604)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 175, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1603)
				p.TypeArgumentsOrDiamond()
			}

		}

	}

	return localctx
}

// INonWildcardTypeArgumentsContext is an interface to support dynamic dispatch.
type INonWildcardTypeArgumentsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNonWildcardTypeArgumentsContext differentiates from other interfaces.
	IsNonWildcardTypeArgumentsContext()
}

type NonWildcardTypeArgumentsContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyNonWildcardTypeArgumentsContext() *NonWildcardTypeArgumentsContext {
	var p = new(NonWildcardTypeArgumentsContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_nonWildcardTypeArguments
	return p
}

func (*NonWildcardTypeArgumentsContext) IsNonWildcardTypeArgumentsContext() {}

func NewNonWildcardTypeArgumentsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NonWildcardTypeArgumentsContext {
	var p = new(NonWildcardTypeArgumentsContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_nonWildcardTypeArguments

	return p
}

func (s *NonWildcardTypeArgumentsContext) GetParser() antlr.Parser { return s.parser }

func (s *NonWildcardTypeArgumentsContext) LT() antlr.TerminalNode {
	return s.GetToken(GroovyParserLT, 0)
}

func (s *NonWildcardTypeArgumentsContext) AllNls() []INlsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INlsContext)(nil)).Elem())
	var tst = make([]INlsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INlsContext)
		}
	}

	return tst
}

func (s *NonWildcardTypeArgumentsContext) Nls(i int) INlsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INlsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *NonWildcardTypeArgumentsContext) TypeList() ITypeListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeListContext)
}

func (s *NonWildcardTypeArgumentsContext) GT() antlr.TerminalNode {
	return s.GetToken(GroovyParserGT, 0)
}

func (s *NonWildcardTypeArgumentsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NonWildcardTypeArgumentsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NonWildcardTypeArgumentsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterNonWildcardTypeArguments(s)
	}
}

func (s *NonWildcardTypeArgumentsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitNonWildcardTypeArguments(s)
	}
}

func (p *GroovyParser) NonWildcardTypeArguments() (localctx INonWildcardTypeArgumentsContext) {
	localctx = NewNonWildcardTypeArgumentsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 272, GroovyParserRULE_nonWildcardTypeArguments)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1608)
		p.Match(GroovyParserLT)
	}
	{
		p.SetState(1609)
		p.Nls()
	}
	{
		p.SetState(1610)
		p.TypeList()
	}
	{
		p.SetState(1611)
		p.Nls()
	}
	{
		p.SetState(1612)
		p.Match(GroovyParserGT)
	}

	return localctx
}

// ITypeArgumentsOrDiamondContext is an interface to support dynamic dispatch.
type ITypeArgumentsOrDiamondContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeArgumentsOrDiamondContext differentiates from other interfaces.
	IsTypeArgumentsOrDiamondContext()
}

type TypeArgumentsOrDiamondContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeArgumentsOrDiamondContext() *TypeArgumentsOrDiamondContext {
	var p = new(TypeArgumentsOrDiamondContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_typeArgumentsOrDiamond
	return p
}

func (*TypeArgumentsOrDiamondContext) IsTypeArgumentsOrDiamondContext() {}

func NewTypeArgumentsOrDiamondContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeArgumentsOrDiamondContext {
	var p = new(TypeArgumentsOrDiamondContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_typeArgumentsOrDiamond

	return p
}

func (s *TypeArgumentsOrDiamondContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeArgumentsOrDiamondContext) LT() antlr.TerminalNode {
	return s.GetToken(GroovyParserLT, 0)
}

func (s *TypeArgumentsOrDiamondContext) GT() antlr.TerminalNode {
	return s.GetToken(GroovyParserGT, 0)
}

func (s *TypeArgumentsOrDiamondContext) TypeArguments() ITypeArgumentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeArgumentsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeArgumentsContext)
}

func (s *TypeArgumentsOrDiamondContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeArgumentsOrDiamondContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeArgumentsOrDiamondContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterTypeArgumentsOrDiamond(s)
	}
}

func (s *TypeArgumentsOrDiamondContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitTypeArgumentsOrDiamond(s)
	}
}

func (p *GroovyParser) TypeArgumentsOrDiamond() (localctx ITypeArgumentsOrDiamondContext) {
	localctx = NewTypeArgumentsOrDiamondContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 274, GroovyParserRULE_typeArgumentsOrDiamond)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1617)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 177, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1614)
			p.Match(GroovyParserLT)
		}
		{
			p.SetState(1615)
			p.Match(GroovyParserGT)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1616)
			p.TypeArguments()
		}

	}

	return localctx
}

// IArgumentsContext is an interface to support dynamic dispatch.
type IArgumentsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArgumentsContext differentiates from other interfaces.
	IsArgumentsContext()
}

type ArgumentsContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyArgumentsContext() *ArgumentsContext {
	var p = new(ArgumentsContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_arguments
	return p
}

func (*ArgumentsContext) IsArgumentsContext() {}

func NewArgumentsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArgumentsContext {
	var p = new(ArgumentsContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_arguments

	return p
}

func (s *ArgumentsContext) GetParser() antlr.Parser { return s.parser }

func (s *ArgumentsContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(GroovyParserLPAREN, 0)
}

func (s *ArgumentsContext) Rparen() IRparenContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRparenContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRparenContext)
}

func (s *ArgumentsContext) EnhancedArgumentList() IEnhancedArgumentListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnhancedArgumentListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEnhancedArgumentListContext)
}

func (s *ArgumentsContext) COMMA() antlr.TerminalNode {
	return s.GetToken(GroovyParserCOMMA, 0)
}

func (s *ArgumentsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArgumentsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArgumentsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterArguments(s)
	}
}

func (s *ArgumentsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitArguments(s)
	}
}

func (p *GroovyParser) Arguments() (localctx IArgumentsContext) {
	localctx = NewArgumentsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 276, GroovyParserRULE_arguments)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1619)
		p.Match(GroovyParserLPAREN)
	}
	p.SetState(1621)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 178, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1620)
			p.EnhancedArgumentList()
		}

	}
	p.SetState(1624)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 179, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1623)
			p.Match(GroovyParserCOMMA)
		}

	}
	{
		p.SetState(1626)
		p.Rparen()
	}

	return localctx
}

// IArgumentListContext is an interface to support dynamic dispatch.
type IArgumentListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArgumentListContext differentiates from other interfaces.
	IsArgumentListContext()
}

type ArgumentListContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyArgumentListContext() *ArgumentListContext {
	var p = new(ArgumentListContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_argumentList
	return p
}

func (*ArgumentListContext) IsArgumentListContext() {}

func NewArgumentListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArgumentListContext {
	var p = new(ArgumentListContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_argumentList

	return p
}

func (s *ArgumentListContext) GetParser() antlr.Parser { return s.parser }

func (s *ArgumentListContext) AllArgumentListElement() []IArgumentListElementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IArgumentListElementContext)(nil)).Elem())
	var tst = make([]IArgumentListElementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IArgumentListElementContext)
		}
	}

	return tst
}

func (s *ArgumentListContext) ArgumentListElement(i int) IArgumentListElementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArgumentListElementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IArgumentListElementContext)
}

func (s *ArgumentListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(GroovyParserCOMMA)
}

func (s *ArgumentListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(GroovyParserCOMMA, i)
}

func (s *ArgumentListContext) AllNls() []INlsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INlsContext)(nil)).Elem())
	var tst = make([]INlsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INlsContext)
		}
	}

	return tst
}

func (s *ArgumentListContext) Nls(i int) INlsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INlsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *ArgumentListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArgumentListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArgumentListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterArgumentList(s)
	}
}

func (s *ArgumentListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitArgumentList(s)
	}
}

func (p *GroovyParser) ArgumentList() (localctx IArgumentListContext) {
	localctx = NewArgumentListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 278, GroovyParserRULE_argumentList)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1628)
		p.ArgumentListElement()
	}
	p.SetState(1635)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 180, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1629)
				p.Match(GroovyParserCOMMA)
			}
			{
				p.SetState(1630)
				p.Nls()
			}
			{
				p.SetState(1631)
				p.ArgumentListElement()
			}

		}
		p.SetState(1637)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 180, p.GetParserRuleContext())
	}

	return localctx
}

// IEnhancedArgumentListContext is an interface to support dynamic dispatch.
type IEnhancedArgumentListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnhancedArgumentListContext differentiates from other interfaces.
	IsEnhancedArgumentListContext()
}

type EnhancedArgumentListContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnhancedArgumentListContext() *EnhancedArgumentListContext {
	var p = new(EnhancedArgumentListContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_enhancedArgumentList
	return p
}

func (*EnhancedArgumentListContext) IsEnhancedArgumentListContext() {}

func NewEnhancedArgumentListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnhancedArgumentListContext {
	var p = new(EnhancedArgumentListContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_enhancedArgumentList

	return p
}

func (s *EnhancedArgumentListContext) GetParser() antlr.Parser { return s.parser }

func (s *EnhancedArgumentListContext) AllEnhancedArgumentListElement() []IEnhancedArgumentListElementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IEnhancedArgumentListElementContext)(nil)).Elem())
	var tst = make([]IEnhancedArgumentListElementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IEnhancedArgumentListElementContext)
		}
	}

	return tst
}

func (s *EnhancedArgumentListContext) EnhancedArgumentListElement(i int) IEnhancedArgumentListElementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnhancedArgumentListElementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IEnhancedArgumentListElementContext)
}

func (s *EnhancedArgumentListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(GroovyParserCOMMA)
}

func (s *EnhancedArgumentListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(GroovyParserCOMMA, i)
}

func (s *EnhancedArgumentListContext) AllNls() []INlsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INlsContext)(nil)).Elem())
	var tst = make([]INlsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INlsContext)
		}
	}

	return tst
}

func (s *EnhancedArgumentListContext) Nls(i int) INlsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INlsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INlsContext)
}

func (s *EnhancedArgumentListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnhancedArgumentListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnhancedArgumentListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterEnhancedArgumentList(s)
	}
}

func (s *EnhancedArgumentListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitEnhancedArgumentList(s)
	}
}

func (p *GroovyParser) EnhancedArgumentList() (localctx IEnhancedArgumentListContext) {
	localctx = NewEnhancedArgumentListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 280, GroovyParserRULE_enhancedArgumentList)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1638)
		p.EnhancedArgumentListElement()
	}
	p.SetState(1645)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 181, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1639)
				p.Match(GroovyParserCOMMA)
			}
			{
				p.SetState(1640)
				p.Nls()
			}
			{
				p.SetState(1641)
				p.EnhancedArgumentListElement()
			}

		}
		p.SetState(1647)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 181, p.GetParserRuleContext())
	}

	return localctx
}

// IArgumentListElementContext is an interface to support dynamic dispatch.
type IArgumentListElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArgumentListElementContext differentiates from other interfaces.
	IsArgumentListElementContext()
}

type ArgumentListElementContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyArgumentListElementContext() *ArgumentListElementContext {
	var p = new(ArgumentListElementContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_argumentListElement
	return p
}

func (*ArgumentListElementContext) IsArgumentListElementContext() {}

func NewArgumentListElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArgumentListElementContext {
	var p = new(ArgumentListElementContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_argumentListElement

	return p
}

func (s *ArgumentListElementContext) GetParser() antlr.Parser { return s.parser }

func (s *ArgumentListElementContext) ExpressionListElement() IExpressionListElementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionListElementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionListElementContext)
}

func (s *ArgumentListElementContext) MapEntry() IMapEntryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMapEntryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMapEntryContext)
}

func (s *ArgumentListElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArgumentListElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArgumentListElementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterArgumentListElement(s)
	}
}

func (s *ArgumentListElementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitArgumentListElement(s)
	}
}

func (p *GroovyParser) ArgumentListElement() (localctx IArgumentListElementContext) {
	localctx = NewArgumentListElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 282, GroovyParserRULE_argumentListElement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1650)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 182, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1648)
			p.ExpressionListElement(true)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1649)
			p.MapEntry()
		}

	}

	return localctx
}

// IEnhancedArgumentListElementContext is an interface to support dynamic dispatch.
type IEnhancedArgumentListElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnhancedArgumentListElementContext differentiates from other interfaces.
	IsEnhancedArgumentListElementContext()
}

type EnhancedArgumentListElementContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnhancedArgumentListElementContext() *EnhancedArgumentListElementContext {
	var p = new(EnhancedArgumentListElementContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_enhancedArgumentListElement
	return p
}

func (*EnhancedArgumentListElementContext) IsEnhancedArgumentListElementContext() {}

func NewEnhancedArgumentListElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnhancedArgumentListElementContext {
	var p = new(EnhancedArgumentListElementContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_enhancedArgumentListElement

	return p
}

func (s *EnhancedArgumentListElementContext) GetParser() antlr.Parser { return s.parser }

func (s *EnhancedArgumentListElementContext) ExpressionListElement() IExpressionListElementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionListElementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionListElementContext)
}

func (s *EnhancedArgumentListElementContext) StandardLambdaExpression() IStandardLambdaExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStandardLambdaExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStandardLambdaExpressionContext)
}

func (s *EnhancedArgumentListElementContext) MapEntry() IMapEntryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMapEntryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMapEntryContext)
}

func (s *EnhancedArgumentListElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnhancedArgumentListElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnhancedArgumentListElementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterEnhancedArgumentListElement(s)
	}
}

func (s *EnhancedArgumentListElementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitEnhancedArgumentListElement(s)
	}
}

func (p *GroovyParser) EnhancedArgumentListElement() (localctx IEnhancedArgumentListElementContext) {
	localctx = NewEnhancedArgumentListElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 284, GroovyParserRULE_enhancedArgumentListElement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1655)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 183, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1652)
			p.ExpressionListElement(true)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1653)
			p.StandardLambdaExpression()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1654)
			p.MapEntry()
		}

	}

	return localctx
}

// IStringLiteralContext is an interface to support dynamic dispatch.
type IStringLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStringLiteralContext differentiates from other interfaces.
	IsStringLiteralContext()
}

type StringLiteralContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyStringLiteralContext() *StringLiteralContext {
	var p = new(StringLiteralContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_stringLiteral
	return p
}

func (*StringLiteralContext) IsStringLiteralContext() {}

func NewStringLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StringLiteralContext {
	var p = new(StringLiteralContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_stringLiteral

	return p
}

func (s *StringLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *StringLiteralContext) StringLiteral() antlr.TerminalNode {
	return s.GetToken(GroovyParserStringLiteral, 0)
}

func (s *StringLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StringLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterStringLiteral(s)
	}
}

func (s *StringLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitStringLiteral(s)
	}
}

func (p *GroovyParser) StringLiteral() (localctx IStringLiteralContext) {
	localctx = NewStringLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 286, GroovyParserRULE_stringLiteral)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1657)
		p.Match(GroovyParserStringLiteral)
	}

	return localctx
}

// IClassNameContext is an interface to support dynamic dispatch.
type IClassNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClassNameContext differentiates from other interfaces.
	IsClassNameContext()
}

type ClassNameContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassNameContext() *ClassNameContext {
	var p = new(ClassNameContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_className
	return p
}

func (*ClassNameContext) IsClassNameContext() {}

func NewClassNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassNameContext {
	var p = new(ClassNameContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_className

	return p
}

func (s *ClassNameContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassNameContext) CapitalizedIdentifier() antlr.TerminalNode {
	return s.GetToken(GroovyParserCapitalizedIdentifier, 0)
}

func (s *ClassNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterClassName(s)
	}
}

func (s *ClassNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitClassName(s)
	}
}

func (p *GroovyParser) ClassName() (localctx IClassNameContext) {
	localctx = NewClassNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 288, GroovyParserRULE_className)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1659)
		p.Match(GroovyParserCapitalizedIdentifier)
	}

	return localctx
}

// IIdentifierContext is an interface to support dynamic dispatch.
type IIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIdentifierContext differentiates from other interfaces.
	IsIdentifierContext()
}

type IdentifierContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierContext() *IdentifierContext {
	var p = new(IdentifierContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_identifier
	return p
}

func (*IdentifierContext) IsIdentifierContext() {}

func NewIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierContext {
	var p = new(IdentifierContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_identifier

	return p
}

func (s *IdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierContext) Identifier() antlr.TerminalNode {
	return s.GetToken(GroovyParserIdentifier, 0)
}

func (s *IdentifierContext) CapitalizedIdentifier() antlr.TerminalNode {
	return s.GetToken(GroovyParserCapitalizedIdentifier, 0)
}

func (s *IdentifierContext) VAR() antlr.TerminalNode {
	return s.GetToken(GroovyParserVAR, 0)
}

func (s *IdentifierContext) STATIC() antlr.TerminalNode {
	return s.GetToken(GroovyParserSTATIC, 0)
}

func (s *IdentifierContext) IN() antlr.TerminalNode {
	return s.GetToken(GroovyParserIN, 0)
}

func (s *IdentifierContext) TRAIT() antlr.TerminalNode {
	return s.GetToken(GroovyParserTRAIT, 0)
}

func (s *IdentifierContext) AS() antlr.TerminalNode {
	return s.GetToken(GroovyParserAS, 0)
}

func (s *IdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterIdentifier(s)
	}
}

func (s *IdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitIdentifier(s)
	}
}

func (p *GroovyParser) Identifier() (localctx IIdentifierContext) {
	localctx = NewIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 290, GroovyParserRULE_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1669)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 184, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1661)
			p.Match(GroovyParserIdentifier)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1662)
			p.Match(GroovyParserCapitalizedIdentifier)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1663)
			p.Match(GroovyParserVAR)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		p.SetState(1664)

		if !(DOT == _input.LT(2).getType()) {
			panic(antlr.NewFailedPredicateException(p, " DOT == _input.LT(2).getType() ", ""))
		}
		{
			p.SetState(1665)
			p.Match(GroovyParserSTATIC)
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1666)
			p.Match(GroovyParserIN)
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1667)
			p.Match(GroovyParserTRAIT)
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1668)
			p.Match(GroovyParserAS)
		}

	}

	return localctx
}

// IBuiltInTypeContext is an interface to support dynamic dispatch.
type IBuiltInTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBuiltInTypeContext differentiates from other interfaces.
	IsBuiltInTypeContext()
}

type BuiltInTypeContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyBuiltInTypeContext() *BuiltInTypeContext {
	var p = new(BuiltInTypeContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_builtInType
	return p
}

func (*BuiltInTypeContext) IsBuiltInTypeContext() {}

func NewBuiltInTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BuiltInTypeContext {
	var p = new(BuiltInTypeContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_builtInType

	return p
}

func (s *BuiltInTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *BuiltInTypeContext) BuiltInPrimitiveType() antlr.TerminalNode {
	return s.GetToken(GroovyParserBuiltInPrimitiveType, 0)
}

func (s *BuiltInTypeContext) VOID() antlr.TerminalNode {
	return s.GetToken(GroovyParserVOID, 0)
}

func (s *BuiltInTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BuiltInTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BuiltInTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterBuiltInType(s)
	}
}

func (s *BuiltInTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitBuiltInType(s)
	}
}

func (p *GroovyParser) BuiltInType() (localctx IBuiltInTypeContext) {
	localctx = NewBuiltInTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 292, GroovyParserRULE_builtInType)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1671)
		_la = p.GetTokenStream().LA(1)

		if !(_la == GroovyParserBuiltInPrimitiveType || _la == GroovyParserVOID) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IKeywordsContext is an interface to support dynamic dispatch.
type IKeywordsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsKeywordsContext differentiates from other interfaces.
	IsKeywordsContext()
}

type KeywordsContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyKeywordsContext() *KeywordsContext {
	var p = new(KeywordsContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_keywords
	return p
}

func (*KeywordsContext) IsKeywordsContext() {}

func NewKeywordsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KeywordsContext {
	var p = new(KeywordsContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_keywords

	return p
}

func (s *KeywordsContext) GetParser() antlr.Parser { return s.parser }

func (s *KeywordsContext) ABSTRACT() antlr.TerminalNode {
	return s.GetToken(GroovyParserABSTRACT, 0)
}

func (s *KeywordsContext) AS() antlr.TerminalNode {
	return s.GetToken(GroovyParserAS, 0)
}

func (s *KeywordsContext) ASSERT() antlr.TerminalNode {
	return s.GetToken(GroovyParserASSERT, 0)
}

func (s *KeywordsContext) BREAK() antlr.TerminalNode {
	return s.GetToken(GroovyParserBREAK, 0)
}

func (s *KeywordsContext) CASE() antlr.TerminalNode {
	return s.GetToken(GroovyParserCASE, 0)
}

func (s *KeywordsContext) CATCH() antlr.TerminalNode {
	return s.GetToken(GroovyParserCATCH, 0)
}

func (s *KeywordsContext) CLASS() antlr.TerminalNode {
	return s.GetToken(GroovyParserCLASS, 0)
}

func (s *KeywordsContext) CONST() antlr.TerminalNode {
	return s.GetToken(GroovyParserCONST, 0)
}

func (s *KeywordsContext) CONTINUE() antlr.TerminalNode {
	return s.GetToken(GroovyParserCONTINUE, 0)
}

func (s *KeywordsContext) DEF() antlr.TerminalNode {
	return s.GetToken(GroovyParserDEF, 0)
}

func (s *KeywordsContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(GroovyParserDEFAULT, 0)
}

func (s *KeywordsContext) DO() antlr.TerminalNode {
	return s.GetToken(GroovyParserDO, 0)
}

func (s *KeywordsContext) ELSE() antlr.TerminalNode {
	return s.GetToken(GroovyParserELSE, 0)
}

func (s *KeywordsContext) ENUM() antlr.TerminalNode {
	return s.GetToken(GroovyParserENUM, 0)
}

func (s *KeywordsContext) EXTENDS() antlr.TerminalNode {
	return s.GetToken(GroovyParserEXTENDS, 0)
}

func (s *KeywordsContext) FINAL() antlr.TerminalNode {
	return s.GetToken(GroovyParserFINAL, 0)
}

func (s *KeywordsContext) FINALLY() antlr.TerminalNode {
	return s.GetToken(GroovyParserFINALLY, 0)
}

func (s *KeywordsContext) FOR() antlr.TerminalNode {
	return s.GetToken(GroovyParserFOR, 0)
}

func (s *KeywordsContext) GOTO() antlr.TerminalNode {
	return s.GetToken(GroovyParserGOTO, 0)
}

func (s *KeywordsContext) IF() antlr.TerminalNode {
	return s.GetToken(GroovyParserIF, 0)
}

func (s *KeywordsContext) IMPLEMENTS() antlr.TerminalNode {
	return s.GetToken(GroovyParserIMPLEMENTS, 0)
}

func (s *KeywordsContext) IMPORT() antlr.TerminalNode {
	return s.GetToken(GroovyParserIMPORT, 0)
}

func (s *KeywordsContext) IN() antlr.TerminalNode {
	return s.GetToken(GroovyParserIN, 0)
}

func (s *KeywordsContext) INSTANCEOF() antlr.TerminalNode {
	return s.GetToken(GroovyParserINSTANCEOF, 0)
}

func (s *KeywordsContext) INTERFACE() antlr.TerminalNode {
	return s.GetToken(GroovyParserINTERFACE, 0)
}

func (s *KeywordsContext) NATIVE() antlr.TerminalNode {
	return s.GetToken(GroovyParserNATIVE, 0)
}

func (s *KeywordsContext) NEW() antlr.TerminalNode {
	return s.GetToken(GroovyParserNEW, 0)
}

func (s *KeywordsContext) PACKAGE() antlr.TerminalNode {
	return s.GetToken(GroovyParserPACKAGE, 0)
}

func (s *KeywordsContext) RETURN() antlr.TerminalNode {
	return s.GetToken(GroovyParserRETURN, 0)
}

func (s *KeywordsContext) STATIC() antlr.TerminalNode {
	return s.GetToken(GroovyParserSTATIC, 0)
}

func (s *KeywordsContext) STRICTFP() antlr.TerminalNode {
	return s.GetToken(GroovyParserSTRICTFP, 0)
}

func (s *KeywordsContext) SUPER() antlr.TerminalNode {
	return s.GetToken(GroovyParserSUPER, 0)
}

func (s *KeywordsContext) SWITCH() antlr.TerminalNode {
	return s.GetToken(GroovyParserSWITCH, 0)
}

func (s *KeywordsContext) SYNCHRONIZED() antlr.TerminalNode {
	return s.GetToken(GroovyParserSYNCHRONIZED, 0)
}

func (s *KeywordsContext) THIS() antlr.TerminalNode {
	return s.GetToken(GroovyParserTHIS, 0)
}

func (s *KeywordsContext) THROW() antlr.TerminalNode {
	return s.GetToken(GroovyParserTHROW, 0)
}

func (s *KeywordsContext) THROWS() antlr.TerminalNode {
	return s.GetToken(GroovyParserTHROWS, 0)
}

func (s *KeywordsContext) TRANSIENT() antlr.TerminalNode {
	return s.GetToken(GroovyParserTRANSIENT, 0)
}

func (s *KeywordsContext) TRAIT() antlr.TerminalNode {
	return s.GetToken(GroovyParserTRAIT, 0)
}

func (s *KeywordsContext) THREADSAFE() antlr.TerminalNode {
	return s.GetToken(GroovyParserTHREADSAFE, 0)
}

func (s *KeywordsContext) TRY() antlr.TerminalNode {
	return s.GetToken(GroovyParserTRY, 0)
}

func (s *KeywordsContext) VAR() antlr.TerminalNode {
	return s.GetToken(GroovyParserVAR, 0)
}

func (s *KeywordsContext) VOLATILE() antlr.TerminalNode {
	return s.GetToken(GroovyParserVOLATILE, 0)
}

func (s *KeywordsContext) WHILE() antlr.TerminalNode {
	return s.GetToken(GroovyParserWHILE, 0)
}

func (s *KeywordsContext) NullLiteral() antlr.TerminalNode {
	return s.GetToken(GroovyParserNullLiteral, 0)
}

func (s *KeywordsContext) BooleanLiteral() antlr.TerminalNode {
	return s.GetToken(GroovyParserBooleanLiteral, 0)
}

func (s *KeywordsContext) BuiltInPrimitiveType() antlr.TerminalNode {
	return s.GetToken(GroovyParserBuiltInPrimitiveType, 0)
}

func (s *KeywordsContext) VOID() antlr.TerminalNode {
	return s.GetToken(GroovyParserVOID, 0)
}

func (s *KeywordsContext) PUBLIC() antlr.TerminalNode {
	return s.GetToken(GroovyParserPUBLIC, 0)
}

func (s *KeywordsContext) PROTECTED() antlr.TerminalNode {
	return s.GetToken(GroovyParserPROTECTED, 0)
}

func (s *KeywordsContext) PRIVATE() antlr.TerminalNode {
	return s.GetToken(GroovyParserPRIVATE, 0)
}

func (s *KeywordsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KeywordsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KeywordsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterKeywords(s)
	}
}

func (s *KeywordsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitKeywords(s)
	}
}

func (p *GroovyParser) Keywords() (localctx IKeywordsContext) {
	localctx = NewKeywordsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 294, GroovyParserRULE_keywords)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1673)
		_la = p.GetTokenStream().LA(1)

		if !((((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<GroovyParserAS)|(1<<GroovyParserDEF)|(1<<GroovyParserIN)|(1<<GroovyParserTRAIT)|(1<<GroovyParserTHREADSAFE)|(1<<GroovyParserVAR)|(1<<GroovyParserBuiltInPrimitiveType)|(1<<GroovyParserABSTRACT)|(1<<GroovyParserASSERT)|(1<<GroovyParserBREAK)|(1<<GroovyParserCASE)|(1<<GroovyParserCATCH)|(1<<GroovyParserCLASS)|(1<<GroovyParserCONST)|(1<<GroovyParserCONTINUE)|(1<<GroovyParserDEFAULT)|(1<<GroovyParserDO)|(1<<GroovyParserELSE)|(1<<GroovyParserENUM)|(1<<GroovyParserEXTENDS)|(1<<GroovyParserFINAL)|(1<<GroovyParserFINALLY)|(1<<GroovyParserFOR)|(1<<GroovyParserIF)|(1<<GroovyParserGOTO))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(GroovyParserIMPLEMENTS-32))|(1<<(GroovyParserIMPORT-32))|(1<<(GroovyParserINSTANCEOF-32))|(1<<(GroovyParserINTERFACE-32))|(1<<(GroovyParserNATIVE-32))|(1<<(GroovyParserNEW-32))|(1<<(GroovyParserPACKAGE-32))|(1<<(GroovyParserPRIVATE-32))|(1<<(GroovyParserPROTECTED-32))|(1<<(GroovyParserPUBLIC-32))|(1<<(GroovyParserRETURN-32))|(1<<(GroovyParserSTATIC-32))|(1<<(GroovyParserSTRICTFP-32))|(1<<(GroovyParserSUPER-32))|(1<<(GroovyParserSWITCH-32))|(1<<(GroovyParserSYNCHRONIZED-32))|(1<<(GroovyParserTHIS-32))|(1<<(GroovyParserTHROW-32))|(1<<(GroovyParserTHROWS-32))|(1<<(GroovyParserTRANSIENT-32))|(1<<(GroovyParserTRY-32))|(1<<(GroovyParserVOID-32))|(1<<(GroovyParserVOLATILE-32))|(1<<(GroovyParserWHILE-32))|(1<<(GroovyParserBooleanLiteral-32))|(1<<(GroovyParserNullLiteral-32)))) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IRparenContext is an interface to support dynamic dispatch.
type IRparenContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRparenContext differentiates from other interfaces.
	IsRparenContext()
}

type RparenContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyRparenContext() *RparenContext {
	var p = new(RparenContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_rparen
	return p
}

func (*RparenContext) IsRparenContext() {}

func NewRparenContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RparenContext {
	var p = new(RparenContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_rparen

	return p
}

func (s *RparenContext) GetParser() antlr.Parser { return s.parser }

func (s *RparenContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(GroovyParserRPAREN, 0)
}

func (s *RparenContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RparenContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RparenContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterRparen(s)
	}
}

func (s *RparenContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitRparen(s)
	}
}

func (p *GroovyParser) Rparen() (localctx IRparenContext) {
	localctx = NewRparenContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 296, GroovyParserRULE_rparen)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1677)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 185, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1675)
			p.Match(GroovyParserRPAREN)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		require(false, "Missing ')'")

	}

	return localctx
}

// INlsContext is an interface to support dynamic dispatch.
type INlsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNlsContext differentiates from other interfaces.
	IsNlsContext()
}

type NlsContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptyNlsContext() *NlsContext {
	var p = new(NlsContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_nls
	return p
}

func (*NlsContext) IsNlsContext() {}

func NewNlsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NlsContext {
	var p = new(NlsContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_nls

	return p
}

func (s *NlsContext) GetParser() antlr.Parser { return s.parser }

func (s *NlsContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(GroovyParserNL)
}

func (s *NlsContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(GroovyParserNL, i)
}

func (s *NlsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NlsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NlsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterNls(s)
	}
}

func (s *NlsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitNls(s)
	}
}

func (p *GroovyParser) Nls() (localctx INlsContext) {
	localctx = NewNlsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 298, GroovyParserRULE_nls)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1682)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 186, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1679)
				p.Match(GroovyParserNL)
			}

		}
		p.SetState(1684)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 186, p.GetParserRuleContext())
	}

	return localctx
}

// ISepContext is an interface to support dynamic dispatch.
type ISepContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSepContext differentiates from other interfaces.
	IsSepContext()
}

type SepContext struct {
	*GroovyParserRuleContext
	parser antlr.Parser
}

func NewEmptySepContext() *SepContext {
	var p = new(SepContext)
	p.GroovyParserRuleContext = NewGroovyParserRuleContext(nil, -1)
	p.RuleIndex = GroovyParserRULE_sep
	return p
}

func (*SepContext) IsSepContext() {}

func NewSepContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SepContext {
	var p = new(SepContext)

	p.GroovyParserRuleContext = NewGroovyParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = GroovyParserRULE_sep

	return p
}

func (s *SepContext) GetParser() antlr.Parser { return s.parser }

func (s *SepContext) AllNL() []antlr.TerminalNode {
	return s.GetTokens(GroovyParserNL)
}

func (s *SepContext) NL(i int) antlr.TerminalNode {
	return s.GetToken(GroovyParserNL, i)
}

func (s *SepContext) AllSEMI() []antlr.TerminalNode {
	return s.GetTokens(GroovyParserSEMI)
}

func (s *SepContext) SEMI(i int) antlr.TerminalNode {
	return s.GetToken(GroovyParserSEMI, i)
}

func (s *SepContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SepContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SepContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.EnterSep(s)
	}
}

func (s *SepContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(GroovyParserListener); ok {
		listenerT.ExitSep(s)
	}
}

func (p *GroovyParser) Sep() (localctx ISepContext) {
	localctx = NewSepContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 300, GroovyParserRULE_sep)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1686)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(1685)
				_la = p.GetTokenStream().LA(1)

				if !(_la == GroovyParserSEMI || _la == GroovyParserNL) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(1688)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 187, p.GetParserRuleContext())
	}

	return localctx
}

func (p *GroovyParser) Sempred(localctx antlr.RuleContext, ruleIndex, predIndex int) bool {
	switch ruleIndex {
	case 19:
		var t *ClassDeclarationContext = nil
		if localctx != nil {
			t = localctx.(*ClassDeclarationContext)
		}
		return p.ClassDeclaration_Sempred(t, predIndex)

	case 20:
		var t *ClassBodyContext = nil
		if localctx != nil {
			t = localctx.(*ClassBodyContext)
		}
		return p.ClassBody_Sempred(t, predIndex)

	case 25:
		var t *MethodDeclarationContext = nil
		if localctx != nil {
			t = localctx.(*MethodDeclarationContext)
		}
		return p.MethodDeclaration_Sempred(t, predIndex)

	case 27:
		var t *ReturnTypeContext = nil
		if localctx != nil {
			t = localctx.(*ReturnTypeContext)
		}
		return p.ReturnType_Sempred(t, predIndex)

	case 80:
		var t *LocalVariableDeclarationContext = nil
		if localctx != nil {
			t = localctx.(*LocalVariableDeclarationContext)
		}
		return p.LocalVariableDeclaration_Sempred(t, predIndex)

	case 81:
		var t *ClassifiedModifiersContext = nil
		if localctx != nil {
			t = localctx.(*ClassifiedModifiersContext)
		}
		return p.ClassifiedModifiers_Sempred(t, predIndex)

	case 94:
		var t *StatementContext = nil
		if localctx != nil {
			t = localctx.(*StatementContext)
		}
		return p.Statement_Sempred(t, predIndex)

	case 116:
		var t *ExpressionContext = nil
		if localctx != nil {
			t = localctx.(*ExpressionContext)
		}
		return p.Expression_Sempred(t, predIndex)

	case 118:
		var t *CommandExpressionContext = nil
		if localctx != nil {
			t = localctx.(*CommandExpressionContext)
		}
		return p.CommandExpression_Sempred(t, predIndex)

	case 132:
		var t *CreatorContext = nil
		if localctx != nil {
			t = localctx.(*CreatorContext)
		}
		return p.Creator_Sempred(t, predIndex)

	case 145:
		var t *IdentifierContext = nil
		if localctx != nil {
			t = localctx.(*IdentifierContext)
		}
		return p.Identifier_Sempred(t, predIndex)

	default:
		panic("No predicate with index: " + fmt.Sprint(ruleIndex))
	}
}

func (p *GroovyParser) ClassDeclaration_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 0:
		return 3 != localctx.(*ClassDeclarationContext).t

	case 1:
		return 2 != localctx.(*ClassDeclarationContext).t

	case 2:
		return 1 == localctx.(*ClassDeclarationContext).t

	case 3:
		return 1 != localctx.(*ClassDeclarationContext).t

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *GroovyParser) ClassBody_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 4:
		return 2 == localctx.(*ClassBodyContext).t

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *GroovyParser) MethodDeclaration_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 5:
		return 3 == localctx.(*MethodDeclarationContext).ct

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *GroovyParser) ReturnType_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 6:
		return 3 != localctx.(*ReturnTypeContext).ct

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *GroovyParser) LocalVariableDeclaration_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 7:
		return !SemanticPredicates.isInvalidLocalVariableDeclaration(_input)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *GroovyParser) ClassifiedModifiers_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 8:
		return 0 == localctx.(*ClassifiedModifiersContext).t

	case 9:
		return 1 == localctx.(*ClassifiedModifiersContext).t

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *GroovyParser) Statement_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 10:
		return !SemanticPredicates.isInvalidMethodDeclaration(_input)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *GroovyParser) Expression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 11:
		return p.Precpred(p.GetParserRuleContext(), 17)

	case 12:
		return p.Precpred(p.GetParserRuleContext(), 15)

	case 13:
		return p.Precpred(p.GetParserRuleContext(), 14)

	case 14:
		return p.Precpred(p.GetParserRuleContext(), 13)

	case 15:
		return p.Precpred(p.GetParserRuleContext(), 11)

	case 16:
		return p.Precpred(p.GetParserRuleContext(), 10)

	case 17:
		return p.Precpred(p.GetParserRuleContext(), 9)

	case 18:
		return p.Precpred(p.GetParserRuleContext(), 8)

	case 19:
		return p.Precpred(p.GetParserRuleContext(), 7)

	case 20:
		return p.Precpred(p.GetParserRuleContext(), 6)

	case 21:
		return p.Precpred(p.GetParserRuleContext(), 5)

	case 22:
		return p.Precpred(p.GetParserRuleContext(), 4)

	case 23:
		return p.Precpred(p.GetParserRuleContext(), 3)

	case 24:
		return p.Precpred(p.GetParserRuleContext(), 12)

	case 25:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *GroovyParser) CommandExpression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 26:
		return !SemanticPredicates.isFollowingArgumentsOrClosure(localctx.(*CommandExpressionContext).Get_expression())

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *GroovyParser) Creator_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 27:
		return 0 == localctx.(*CreatorContext).t || 1 == localctx.(*CreatorContext).t

	case 28:
		return 0 == localctx.(*CreatorContext).t

	case 29:
		return 0 == localctx.(*CreatorContext).t

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *GroovyParser) Identifier_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 30:
		return DOT == _input.LT(2).getType()

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}
